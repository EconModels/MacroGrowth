\documentclass[10pt]{article}

\usepackage[margin=.5in]{geometry}

\begin{document}
<<setup,include=FALSE>>=
require(knitr)
require(lattice)
require(ggplot2)
require(car)
require(mosaic)
require(xtable)
trellis.par.set(theme=theme.mosaic())
options(width=75)
options(show.signif.stars=FALSE)
opts_chunk$set(
  tidy=FALSE,
  fig.width=4.5,
  fig.height=3.8,
  out.width=".45\\textwidth",
  out.height=".38\\textwidth",
  comment=NA)
@

<<loadData>>=
fileName <- "data/USData.txt"

# Read the data file as a table with a header.  
## dataTable is a poor name.  Name it after contents, unless this is the 
## start of a script where this will be provided at the command line.
dataTable <- read.table(fileName, header = TRUE)

# Identifies the header names associated with dataTable
names(dataTable)
@

\section{Cobb-Douglas Without Energy}

<<cobb-douglass>>=
# Establish guess values for alpha and lambda.
lambdaGuess <- 0.0 # guessing lambda = 0 means there is no technological progress.
alphaGuess <- 0.3 # a typical value for alpha, the coefficient on capital stock

# Runs a non-linear least squares fit to the data. We've replaced beta with 1-alpha for simplicity.
modelCD <- nls(iGDP ~ exp(lambda*iYear) * iCapStk^alpha * iLabor^(1 - alpha), 
               start=(list(lambda=lambdaGuess,alpha=alphaGuess)),
               data=dataTable)

# Checks validity of the model. AIC stands for Akaike's Information Criterion.
aicCD  <- AIC(modelCD, k=2); aicCD

summaryCD <- summary(modelCD) # Gives the nls summary table.
print(summaryCD)
ciCD <- confint(modelCD, level = 0.95); ciCD # Displays confidence intervals for the CD model.

# Calculate beta and its confidence interval and report it.
alpha <- as.numeric(coef(modelCD)["alpha"])
beta <- 1.0 - alpha
beta.est <- deltaMethod(modelCD, "1 - alpha"); beta.est # Estimates beta and its standard error (SE).
# Now calculate a confidence interval on beta
dofCD <- summaryCD$df[2]; dofCD # Gives the degrees of freedom for the model.
tvalCD <- qt(0.975, df = dofCD); tvalCD
betaCICD <- with(beta.est, Estimate + c(-1.0, 1.0) * tvalCD * SE); betaCICD # Gives the confidence interval on beta.

coef(modelCD)

# Combine all estimates and their confidence intervals into data frames with intelligent row names
estCD <- data.frame(lambda = coef(modelCD)["lambda"], alpha = coef(modelCD)["alpha"], beta = beta, gamma = NA)
row.names(estCD) <- "Cobb-Douglas"
#row.names(estCD) <- "Cobb-Douglas: $y = e^{\\lambda t}k^{\\alpha}l^{\\beta}$"
 # The [1] subscripts pick off the lower confidence interval
lowerCD <- data.frame(lambda = ciCD["lambda","2.5%"], alpha = ciCD["alpha", "2.5%"], beta = betaCICD[1], gamma = NA) 
row.names(lowerCD) <- "- 95% CI"
 # The [2] subscripts pick off the lower confidence interval
upperCD <- data.frame(lambda = ciCD["lambda","97.5%"], alpha = ciCD["alpha", "97.5%"], beta = betaCICD[2], gamma = NA)
row.names(upperCD) <- "+ 95% CI"

# Now create the data for a table.
dataCD <- rbind(lowerCD, estCD, upperCD); dataCD
colnames(dataCD)  <- c("$\\lambda$", "$\\alpha$", "$\\beta$", "$\\gamma$")
tableCD  <- xtable(dataCD)
@

<<CD Results, results='asis'>>=
print(xtable(dataCD), floating=FALSE)
# According to http://cran.r-project.org/web/packages/xtable/vignettes/xtableGallery.pdf, Section 3.1, I should 
# be able to use the "sanitize.text.function" parameter to allow markup in column headers. But this next
# line is not working at the present time. --MKH, 18 Jan 2012.
# print(tableCD, sanitize.text.function = function(x){x})
@

\section{Cobb-Douglas With Q}

<<cdq>>=
# Establish guess values for alpha, beta, and lambda.
# lambdaGuess <- 0.0 # guessing lambda = 0 means there is no technological progress.
# alphaGuess <- 0.2 # a typical value for alpha
# betaGuess <- 0.6 # a typical value for beta

# Runs a non-linear least squares fit to the data.
# modelCDQ <- nls(iGDP ~ exp(lambda*iYear) * iCapStk^alpha * iLabor^beta * iQ^(1.0 - alpha - beta), 
#                 start=(list(lambda=lambdaGuess,alpha=alphaGuess,beta=betaGuess)),
#                 data=dataTable)

# Reparameterize to ensure that we meet the constraint that alpha + beta + gamma = 1.0.
# 0 < a < 1
# 0 < b < 1
# alpha = min(a, b)
# beta = b - a
# gamma = 1 - max(a, b)

lambdaGuess <- 0.0 # guessing lambda = 0 means there is no technological progress.
alphaGuess <- 0.2 # a typical value for alpha
betaGuess <- 0.8 # a typical value for beta
modelCDq <- nls(iGDP ~ exp(lambda*iYear) * 
                            iCapStk^min(a,b) * iLabor^abs(b-a) * 
                            iQ^(1.0 - max(a,b)), 
  algorithm = "port",
  start = list(lambda=lambdaGuess, a=alphaGuess, b=alphaGuess+betaGuess),
	lower = list(lambda=-Inf, a=0, b=0),
	upper = list(lambda=Inf, a=1, b=1),
  data = dataTable)

aicCDq <- AIC(modelCDq, k=2); aicCDq # Checks validity of the model. AIC stands for Akaike's Information Criterion

summaryCDq <- summary(modelCDq); summaryCDq # Gives the nls summary table

# Provides confidence intervals on lambda, a, and b. But, we need CIs on alpha and beta.
ciCDq <- confint(modelCDq, level = 0.95); ciCDq 

a <- as.numeric(coef(modelCDq)["a"])
b <- as.numeric(coef(modelCDq)["b"])
lambda <- as.numeric(coef(modelCDq)["lambda"])
alpha <- a
beta <- b - a
gamma <- 1.0 - alpha - beta

# Report results with SE
beta.est <- deltaMethod(modelCDq, "b-a"); beta.est # Reports results for beta, because beta = b - a.
gamma.est <- deltaMethod(modelCDq, "1-b"); gamma.est # Reports results for gamma, because gamma = 1 - b.

# Now calculate confidence intervals.
dofCDq <- summaryCDq$df[2]; dofCDq # Gives the degrees of freedom for the model.
tvalCDq <- qt(0.975, df = dofCDq); tvalCDq
betaCICDq <- with(beta.est, Estimate + c(-1.0, 1.0) * tvalCDq * SE); betaCICDq # Gives the confidence interval on beta.
gammaCICDq <- with(gamma.est, Estimate + c(-1.0, 1.0) * tvalCDq * SE); gammaCICDq # Gives the confidence interval on alpha.

# Combine all estimates and their confidence intervals into data frames with intelligent row names
estCDq <- data.frame(lambda = lambda, alpha = alpha, beta = beta, gamma = gamma); estCDq
#row.names(estCDq) <- "Cobb-Douglas with q: $y = e^{\\lambda t}k^{\\alpha}l^{\\beta}q^{\\gamma}$"
row.names(estCDq) <- "CobbDouglas with q"
# The [1] subscripts pick off the lower confidence interval
lowerCDq <- data.frame(lambda = ciCDq["lambda","2.5%"], alpha = ciCDq["a", "2.5%"], beta = betaCICDq[1], gamma = gammaCICDq[1])
row.names(lowerCDq) <- "- 95% CI"
# The [2] subscripts pick off the lower confidence interval
upperCDq <- data.frame(lambda = ciCDq["lambda","97.5%"], alpha = ciCDq["a", "97.5%"], beta = betaCICDq[2], gamma = gammaCICDq[2])
row.names(upperCDq) <- "+ 95% CI"

# Now create the data for a table.
dataCDq <- rbind(lowerCDq, estCDq, upperCDq); dataCDq
colnames(dataCDq)  <- c("$\\lambda$", "$\\alpha$", "$\\beta$", "$\\gamma$")
tableCDq <- xtable(dataCDq)

dataAll <- rbind(dataCD, dataCDq); dataAll
@

<<CDq Results, results='asis'>>=
print(xtable(dataCDq), floating=FALSE)
# According to http://cran.r-project.org/web/packages/xtable/vignettes/xtableGallery.pdf, Section 3.1, I should 
# be able to use the "sanitize.text.function" parameter to allow markup in column headers. But this next
# line is not working at the present time. --MKH, 18 Jan 2012.
# print(tableCDq, sanitize.text.function = function(x){x})

print(xtable(dataAll, floating=FALSE))
@

<<Combined Table, results='asis'>>=

@

\section{Cobb-Douglas With X}

<<cdx>>=
# Establish guess values for alpha, beta, and lambda.
lambdaGuess <- 0.0 # guessing lambda = 0 means there is no technological progress.
alphaGuess <- 0.2 # a typical value for alpha
betaGuess <- 0.6 # a typical value for beta

# Runs a non-linear least squares fit to the data.
modelCDX <- nls(iGDP ~ exp(lambda*iYear) * iCapStk^alpha * iLabor^beta * iX^(1.0 - alpha - beta), 
                start=(list(lambda=lambdaGuess,alpha=alphaGuess,beta=betaGuess)),
                data=dataTable)

# Gives the nls summary table
summary(modelCDX)
confint(modelCDX, level = 0.95)

# Calculate gamma and report it.
alpha <- coef(modelCDX)["alpha"] 
beta <- coef(modelCDX)["beta"] 
gamma <- as.numeric(1.0 - alpha - beta)
c(coef(modelCDX),gamma=gamma)

# Checks validity of the model. AIC stands for Akaike's Information Criterion
AIC(modelCDX, k=2)
@

\section{Cobb-Douglas With U}

An issue arrises in this example because contraining $\alpha$ and $\beta$ is not sufficient to 
guarantee that $\gamma$ is properly constrained.

<<cdu>>=
# Establish guess values for alpha, beta, and lambda.
lambdaGuess <- 0.0 # guessing lambda = 0 means there is no technological progress.
alphaGuess <- 0.2 # a typical value for alpha
betaGuess <- 0.6 # a typical value for beta
gammaGuess <- 0.01 # a nice low value

# Runs a non-linear least squares fit to the data with constraints
modelCDU <- nls(iGDP ~ exp(lambda*iYear) * iCapStk^alpha * iLabor^beta * iU^(1.0 - alpha - beta), 
  algorithm="port",
	start = list(lambda=lambdaGuess, alpha=alphaGuess, beta=betaGuess),
	lower = list(lambda=-Inf, alpha=0, beta=0),
	upper = list(lambda=Inf, alpha=1, beta=1),
  data=dataTable)

# Gives the nls summary table
summary(modelCDU)
confint(modelCDU, level = 0.95)
@

<<>>=
# Checks validity of the model. AIC stands for Akaike's Information Criterion
AIC(modelCDU, k=2)
@

The problem here is that $\hat \gamma < 0$.
<<>>=
# Calculate gamma and report it.
alpha <- coef(modelCDU)["alpha"] 
beta <- coef(modelCDU)["beta"] 
gamma <- as.numeric(1.0 - alpha - beta)
c(coef(modelCDU), gamma=gamma)
@

Our $\hat\gamma$ is not much below $0$.  Let's compute the standard error.
<<>>=
require(car)  # the methods in alr3 have been deprecated.  Use car instead.
gamma.est <- deltaMethod(modelCDU, "1-alpha-beta"); gamma.est
# crude CI (using 2 as a rough estimate for critical value)
with(gamma.est, Estimate + c(-1,1) * 2 * SE)
@
So no real cause for concern: our data don't convince us that the real $\gamma$ is different from $0$.

\subsection{Forcing $\gamma\ge0$}

We can force $\alpha$, $\beta$, and $\gamma$ to be in $[0,1]$ by a reparameterization:

\[ a \in[0,1], b \in [0,1], \alpha=\min(a,b), \beta=|b-a|, \gamma = 1-\max(a,b) \]

<<>>=
modelCDUforced <- nls(iGDP ~ exp(lambda*iYear) * 
                            iCapStk^min(a,b) * iLabor^abs(b-a) * 
                            iU^(1.0 - max(a,b)), 
  algorithm="port",
	start = list(lambda=lambdaGuess, a=alphaGuess, b=alphaGuess + betaGuess),
	lower = list(lambda=-Inf, a=0, b=0),
	upper = list(lambda=Inf, a=1, b=1),
  data=dataTable)

coef(summary(modelCDUforced))
with( as.data.frame(t(coef(modelCDUforced))), c(alpha=min(a,b), beta=abs(b-a), gamma=1-max(a,b)))
@
But the naive delta method to calculate significance information fails because R doesn't know how to calculate the derivatives for the minimum and maximum functions.  So we need to be clever, using the fact that we know now that $a < b$:
<<>>=
# alpha = a
deltaMethod( modelCDUforced, "a")
# beta = b - a
deltaMethod( modelCDUforced, "b-a")
# gamma = 1-b
deltaMethod( modelCDUforced, "1-b")
@

So this seems to give us what we want for this case:  We have parameter estimates and standard errors subject to all of our constraints.  

It may be that we can avoid using min and max and just
use $a$, $b-a$ and $1-b$.  If that works, then this generalizes fairly easily to any number of parameters that must be bounded by 0 and 1 and sum to 1.  (Else we have to ``sort'' the dummy parameters first, which is OK but makes the coding a bit uglier.)

\section{CES With Q}

<<>>=
# Establish guess values for alpha, beta, and lambda.
phiGuess <- -20
betaGuess <- 0.5 # a typical value for beta (exponent on labor)
zetaGuess <- 0.0004 # a small value
lambda_LGuess <- 0.007 #assuming no technical progress on the labor-capital portion of the function
lambda_EGuess <- 0.008 #assuming no technical progress on the energy portion of the function

# Runs a non-linear least squares fit to the data with constraints
modelCESQ <- nls(iGDP ~ ((1-zeta) * (exp(lambda_L*iYear) * iLabor^beta * iCapStk^(1-beta))^phi 
                         + zeta*(exp(lambda_E*iYear) * iQ)^phi)^(1/phi), 
  algorithm = "port",
	control = nls.control(maxiter = 500, tol = 1e-06, minFactor = 1/1024, 
                        printEval = FALSE, warnOnly = FALSE),
	start = list(phi=phiGuess, beta=betaGuess, zeta=zetaGuess, lambda_L=lambda_LGuess, 
               lambda_E=lambda_EGuess),
	lower = list(phi=-Inf, beta=0, zeta=0, lambda_L=-Inf, lambda_E=-Inf),
	upper = list(phi=0, beta=1, zeta=1, lambda_L=Inf, lambda_E=Inf),
  data=dataTable)

# Gives the nls summary table
summary(modelCESQ)
xyplot( resid(modelCESQ) ~ fitted(modelCESQ) )
histogram( ~resid(modelCESQ) )
qqmath( ~resid(modelCESQ) )
@

\end{document}