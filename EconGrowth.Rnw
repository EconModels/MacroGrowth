% This article has been prepared for publication in Energy Economics in RStudio with knitr.
% According to http://www.elsevier.com/author-schemas/the-elsarticle-latex-document-class, we should be using the
% elsarticle.cls file.
% According to http://cdn.elsevier.com/assets/pdf_file/0006/109392/journal_refstyles.pdf, we should be using
% elsarticle-template-2-harv.tex as the template for the text.
% Furthermore, we should be using model2-names.bst for the bibliographic references.
% The approach here is to load the frontmatter and backmatter from elsarticle-template-2-harv.tex
% both ahead of and behind the text for our paper.
% -- Matthew Kuperus Heun, 2013-01-18

%% This is file `elsarticle-template-2-harv.tex',
%%
%% Copyright 2009 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle  Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for Elsevier's document class `elsarticle'
%% with harvard style bibliographic references
%%
%% $Id: elsarticle-template-2-harv.tex 155 2009-10-08 05:35:05Z rishi $
%% $URL: http://lenova.river-valley.com/svn/elsbst/trunk/elsarticle-template-2-harv.tex $
%%
\documentclass[preprint,authoryear,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[authoryear,preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,authoryear,1p,times]{elsarticle}
%% \documentclass[final,authoryear,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,authoryear,3p,times]{elsarticle}
%% \documentclass[final,authoryear,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,authoryear,5p,times]{elsarticle}
%% \documentclass[final,authoryear,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
%% \usepackage{graphics}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

\usepackage{soul} %Provides strikethrough text

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
%% \usepackage{lineno}

%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon (default)
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   authoryear - selects author-year citations (default)
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%   longnamesfirst  -  makes first citation full author list
%%
%% \biboptions{longnamesfirst,comma}

% \biboptions{}

\journal{Energy Economics}

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{An Empirical Analysis of the Role of Energy in Economic Growth}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{<author name>}
%% \address[label1]{<address>}
%% \address[label2]{<address>}

\author[Calvin]{Caleb Reese}
\author[Calvin]{Lucas Timmer}
\author[Calvin]{Matthew Kuperus Heun\corref{cor1}}
\ead{mkh2@calvin.edu, tel: +1 (616) 526-6663, fax: +1 (616) 526-6501}

\cortext[cor1]{Corresponding author}
\address[Calvin]{Engineering Department, Calvin College, Grand Rapids, MI 49546, USA}

\begin{abstract}
%% Text of abstract
*********** Add abstract ***********
\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
economic growth \sep energy \sep cobb-douglas \sep CES \sep LINEX
%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)
\end{keyword}

\end{frontmatter}

% \linenumbers
%% main text

**************** To Do List ********************
\begin{itemize}
\item Reese: Add text from Word verson of paper to the LaTeX version.
\item \st{Heun: Create a table of AIC values for each fit.}
\item \st{Heun: Add $u$ predictions for Cobb-Douglas}
\item Heun: Add covariance metrics.
\item Heun: Eliminate blanks in the coefficient tables for the 95\% CIs in the Cobb-Douglas with energy rows. Asked Pruim about this via email but have not heard a response.
      \begin{itemize}
      \item ZA: lower bound on $\lambda$ and upper bound on $\alpha$
      \item ZM: lower bound on $\lambda$
      \end{itemize}
\item Heun: Fix warnings of the form ``Warning:  step factor 0.000488281 reduced below ’minFactor’ of 0.000976562'' in the code that generates the Cobb-Douglas with energy fits.
\item Heun: Add CES production function fits
\item Heun: Add Linex production function fits
\item Heun: Add $k$, $l$, $q$, $x$, and $u$ ONLY fits
\end{itemize}
*************************************************

Caleb, put your LaTeX code here.



<<setup, echo=FALSE, message=FALSE>>=
require(knitr)
require(lattice)
require(latticeExtra)
require(ggplot2)
require(car)
require(mosaic)
require(xtable)
require(tikzDevice) #See http://r-forge.r-project.org/R/?group_id=440 for instructions on installing tikzDevice.
trellis.par.set(theme=theme.mosaic())
options(width=75)
options(show.signif.stars=FALSE)
opts_chunk$set(
  dev='tikz',    #Allows LaTeX code in graphical output. E.g., "$y$" for a variable name in the legend for a graph.
  tidy=FALSE,
  comment=NA,
  warning=TRUE, #Tells whether to show warnings.
  #Tells whether to cache output from chunks are saved. Cacheing saves time. 
  #However, references to LaTeX tables DO NOT WORK if cacheing is turned on (cache=TRUE).
  cache=FALSE,
  echo=FALSE,    #Tells whether to echo code for all chunks. Set TRUE on an individual chunk to see its code.
  message=FALSE) #Turns off messages for all chunks. Set TRUE on an individual chunk to see it.

# Statistical significance levels. We'll work with 95% CIs
ciLevel <- 0.95
ciHalfLevel <- ciLevel + (1.0-ciLevel)/2.0
# List of countries
countryAbbrevs <- c(US="US", UK="UK", JP="JP", CN="CN", ZA="ZA", SA="SA", IR="IR", TZ="TZ", ZM="ZM")
countryAbbrevsU <- c(US="US", UK="UK", JP="JP") #Only these countries have useful work data
countryNamesAlph <- c(CN="China", IR="Iran", JP="Japan", SA="Saudi Arabia", TZ="Tanzania", UK="United Kingdom", US="USA", ZA="South Africa", ZM="Zambia") #In alphabetical order.
# List of energy types
energyTypes <- c(Q="Q", X="X", U="U")
########### Several global parameters for graphs. Set here and use below to ensure consistent appearance of graphs.
# Set the order for presenting countries in 3x3 lattice graphs. Default is alphabetical. "1" means first alphabetically.
# The following list sets the order as US, UK, JP, CN, ZA, TZ, SA, IR, ZM.
countryOrderForGraphs <- c(7,6,3,1,8,5,4,2,9)
# Full page lattice plot sizes and other parameters
layoutSpec <- c(3,3) #indicates a 3x3 arrangement of panels.
figWidth <- 6.5 #Inches
figHeight <- 7.5 #Inches
keyTextSize <- 0.85 #85% of normal size
keyColumns <- 1 #Want only 1 column in the key for lattice graphs
keyXLoc <- 0.01 #x position of the key
keyYLoc <- 0.95 #y position of the key
scaleTextSize <- 1.0 #0.75 #75% of normal size
scaleTickSize <- -0.5 #50% of normal size and pointing INWARD!
@

<<Load Data>>=
#################################
# This function loads data given a country name.
# The file name from which data will be loaded is assumed to be of the form 
# "<countryName>Data.txt". The file is assumed to exist in a subfolder of this project called "data".
#
# countryName is a string containing the 2-letter abbreviation for the country, e.g. "US" or "CN"
#
# returns a matrix with the data that has been loaded
##
loadData <- function(countryName){
  # Read the data file as a table with a header.  
  fileName <- paste("data/", countryName, "Data.txt", sep="")
  dataTable <- read.table(fileName, header = TRUE)
  # Identifies the header names associated with dataTable
  #print(names(dataTable))
  return(dataTable)
}
@

\section{The Facts}

Figure \ref{fig:Factors_Lattice_Graph} shows the ``facts'' as they are known.

<<Factors_Lattice_Graph, fig.width=figWidth, fig.height=figHeight, fig.cap="The facts. Indexed GDP ($y$), capital stock ($k$), labor ($l$), thermal energy ($q$), exergy ($x$), and useful work ($u$).">>=
createFactorsLatticeGraph <- function(){
  dataTable <- loadData("All")
  graphType <- "b" #b is for both line and symbol
  lineTypes <- c(0, 1, 5, 2, 4, 1) #line types. See http://en.wikibooks.org/wiki/R_Programming/Graphics
  lineWidths <- c(0, 2, 2, 1, 1, 1) #line widths. 0 means no line.
  colors <- c("black", "black", "black", "red", "blue", "darkorange") #line and symbol colors
  symbols <- c(1, NA, NA, NA, NA, NA)  #NA gives no symbol.
  graph <- xyplot(iGDP+iCapStk+iLabor+iQ+iX+iU ~ Year | Country, data=dataTable,
                  type = graphType,
                  index.cond = list(countryOrderForGraphs), #orders the panels.
                  layout = layoutSpec, 
                  strip = strip.custom(factor.levels=countryNamesAlph, bg="white"), #Sets strip parameters
                  as.table = TRUE, #indexing of panels starts in upper left and goes across rows.
                  lty = lineTypes, lwd = lineWidths, col = colors, #Controls line parameters
                  pch = symbols, col.symbol = colors, #Controls symbol parameters
                  key=list(text=list(c("$y$", "$k$", "$l$", "$q$", "$x$", "$u$")),
                           type=graphType,
                           cex=keyTextSize, #controls size of text in the key
                           lines=list(lty=lineTypes, lwd=lineWidths), #controls line types
                           pch=symbols, col=colors, #controls symbol (plot characters) types
                           columns=keyColumns, x=keyXLoc, y=keyYLoc), #controls columns and position of the key
                  scales=list(cex=scaleTextSize, #controls text size on scales.
                              tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                              y=list(relation="free", #allows each axis to be different
                                     at=c(1,2,3,4,5,6,7,8,9,10) #tick mark locations
                                     )
                              ),
                  ylim=list(c(1,10), c(1,4), c(1,4), c(1,4), c(1,4), c(1,4), c(1,4), c(1,4), c(1,4)), #y axis limits
                  xlab="", ylab="Indexed (1980=1 or 1991=1)") #axis labels
  return(graph)
}
createFactorsLatticeGraph()
@

\section{Cobb-Douglas Without Energy}

<<cobb-douglas functions>>=
####################
# Returns an nls Cobb-Douglas model for the country specified
# Give an energyType ("Q", "X", or "U") if you want to include an energy term
##
cobbDouglasModel <- function(countryAbbrev, energyType){
  dataTable <- loadData(countryAbbrev) #Load the data that we need.
  #Run the non-linear least squares fit to the data based on whether we have an energy type or not.
  if (missing(energyType)){
    # No energy term desired in the Cobb-Douglas equation.
    # Establish guess values for alpha and lambda.
    lambdaGuess <- 0.0 #guessing lambda = 0 means there is no technological progress.
    alphaGuess <- 0.7 #0.7 gives good results for all countries.  
    # Runs a non-linear least squares fit to the data. We've replaced beta with 1-alpha for simplicity.
    modelCD <- nls(iGDP ~ exp(lambda*iYear) * iCapStk^alpha * iLabor^(1 - alpha), 
                   data=dataTable, 
                   start = list(lambda=lambdaGuess, alpha=alphaGuess),
                   #Include the next 3 lines to fit with constraints.
                   #algorithm = "port",
                   #lower = list(lambda=-Inf, alpha=0), #constraints on lambda and alpha
                   #upper = list(lambda=Inf, alpha=1)
                   )
    return(modelCD)
  } else {
    # We need to do the Cobb-Douglas fit with the desired energy data.
    # To achieve the correct fit, we'll change the name of the desired column
    # to "iEToFit" and use "iEToFit" in the nls function. 
    energyColumnName <- paste("i", energyType, sep="") #Energy term desired in the Cobb-Douglas equation.
    eColIndex <- which(names(dataTable) %in% energyColumnName) #Find index of desired column
    colnames(dataTable)[eColIndex] <- "iEToFit" #Change desired column name to "iEToFit"
    # Reparameterize to ensure that we meet the constraints:
    # * alpha + beta + gamma = 1.0.
    # * alpha, beta, and gamma are all between 0.0 and 1.0.
    # To do this, we reparameterize as
    # * 0 < a < 1
    # * 0 < b < 1
    # * alpha = min(a, b)
    # * beta = b - a
    # * gamma = 1 - max(a, b)
    # Establish guess values for lambda, alpha, and beta.
    lambdaGuess <- 0.0 #guessing lambda = 0 means there is no technological progress.
    alphaGuess <- 0.9
    betaGuess <- 1.0 - alphaGuess
    aGuess <- alphaGuess
    bGuess <- alphaGuess + betaGuess
    # Now actually do the fit, using the column name "iEToFit".
    modelCDe <- nls(iGDP ~ exp(lambda*iYear) * iCapStk^min(a,b) * iLabor^abs(b-a) * iEToFit^(1.0 - max(a,b)), 
                    data = dataTable,
                    start = list(lambda=lambdaGuess, a=aGuess, b=bGuess),
                    control = nls.control(maxiter = 200, 
                                          tol = 1e-05, 
                                          minFactor = 1/1024, 
                                          printEval=FALSE, #Tells whether to print details of curve fit process.
                                          warnOnly=TRUE),
                    #Include the next 3 lines to fit with constraints.
                    #algorithm = "port",
                    #lower = list(lambda=-Inf, a=0, b=0),
                    #upper = list(lambda= Inf, a=1, b=1)
                    )
    return(modelCDe)
  }
}

#########################
# Takes the Cobb-Douglas fitted models and creates per-country predictions for them.
# Returns a data.frame with the predictions.
##
cobbDouglasPredictions <- function(countryAbbrev, energyType){
  # Can't make predictions for any of CN, ZA, SA, IR, TZ, or ZM if we're interested in U
  if (!missing(energyType)){
    # Consider this replacement only if energyType has been specified.
    if (energyType == "U" && (countryAbbrev == "CN" || countryAbbrev == "ZA" || countryAbbrev == "SA" 
                              || countryAbbrev == "IR" || countryAbbrev == "TZ" || countryAbbrev == "ZM")){
      #Return a column of NAs if the above conditions have been met.
      nRows <- 21 # All of these countries need 21 rows.
      df <- as.data.frame(matrix(NA, ncol = 1, nrow = nRows))
      colnames(df) <- "pred"
      return(df)
    }
  }
  model <- cobbDouglasModel(countryAbbrev, energyType)
  pred <- predict(model) #See http://stackoverflow.com/questions/9918807/how-get-plot-from-nls-in-r
  df <- data.frame(pred)
  # Pad with rows as necessary
  df <- padRows(countryAbbrev, df)
  return(df)
}
  
#####################
# This function adds NA rows to a data.frame to ensure that the df is the same length as the country data set
##
padRows <- function(countryAbbrev, df){
  nRowsData <- nrow(loadData(countryAbbrev)) #Gets number of rows in data set
  nRowsDF <- nrow(df)
  nRowsToAdd <- nRowsData - nRowsDF
  nCol <- ncol(df)
  dfToAppend <- as.data.frame(matrix(NA, ncol=nCol, nrow=nRowsToAdd))
  colnames(dfToAppend) <- colnames(df)
  return(rbind(df, dfToAppend))
}

#########################
# Takes the Cobb-Douglas fitted models and creates a single column of predicted GDP values
# that corresponds, row for row, with the AllData.txt file.
##
cobbDouglasPredictionsColumn <- function(energyType){
  if (missing(energyType)){
    out <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasPredictions)) #rbinds all the predictions together
    colnames(out) <- c("predGDP")
  } else {
    out <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasPredictions, energyType=energyType))
    colnames(out) <- c(paste("predGDP", energyType, sep=""))
  }
  return(out)
}

#################################################
# Calculates parameter estimates and confidence intervals
# for the Cobb-Douglas production function given a country.
#
# countryName is a string containing the 2-letter abbreviation for the country, e.g. "US" or "CN"
# energyType is a string, one of "Q", "X", or "U"
#
# returns a vector of data for the Cobb-Douglas model. 
# First item is the +95% CI on all parameters
# Second item contains the parameter estimates
# Third item is the -95% CI on all parameters
# Each row has names: lambda, alpha, beta, gamma, corresponding to the parameters in the model.
##
cobbDouglasData <- function(countryName, energyType){
  modelCD <- cobbDouglasModel(countryName, energyType)
  summaryCD <- summary(modelCD) # Gives the nls summary table.
  ciCD <- confint(modelCD, level = ciLevel)  # Calculates confidence intervals for the CD model.
  dofCD <- summaryCD$df[2] # Gives the degrees of freedom for the model.
  tvalCD <- qt(ciHalfLevel, df = dofCD)
  if (missing(energyType)){
    #Cobb-Douglas without energy
    alpha <- as.numeric(coef(modelCD)["alpha"])
    beta <- 1.0 - alpha
    beta.est <- deltaMethod(modelCD, "1 - alpha") # Estimates beta and its standard error (SE).
    # Calculate beta and its confidence interval and report it.
    # Now calculate a confidence interval on beta
    betaCICD <- with(beta.est, Estimate + c(-1.0, 1.0) * tvalCD * SE); betaCICD # Gives the confidence interval on beta.  
    # Combine all estimates and their confidence intervals into data frames with intelligent row names
    estCD <- data.frame(lambda=coef(modelCD)["lambda"], alpha=coef(modelCD)["alpha"], beta=beta, gamma=0)
    row.names(estCD) <- "CD"
    # The [1] subscripts pick off the lower confidence interval
    lowerCD <- data.frame(lambda=ciCD["lambda","2.5%"], alpha=ciCD["alpha", "2.5%"], beta=betaCICD[1], gamma=NA) 
    row.names(lowerCD) <- "-95% CI"
    # The [2] subscripts pick off the lower confidence interval
    upperCD <- data.frame(lambda=ciCD["lambda","97.5%"], alpha=ciCD["alpha", "97.5%"], beta=betaCICD[2], gamma=NA)
    row.names(upperCD) <- "+95% CI"
  } else {
#     print("")
#     print(paste("In cobbDouglasData:", countryName, energyType))
#     print("summaryCD:")
#     print(paste("    df:", summaryCD$df))
#     print(paste("    sigma:", summaryCD$sigma))
#     print("    coeffs: ")
#     print(summaryCD$coefficients)
#     print("ciCD:")
#     print(ciCD)
    #Cobb-Douglas with energy
    a <- as.numeric(coef(modelCD)["a"])
    b <- as.numeric(coef(modelCD)["b"])
#     print(paste("a =", a))
#     print(paste("b =", b))
    lambda <- as.numeric(coef(modelCD)["lambda"])
    alpha <- a
    beta <- b - a
    gamma <- 1.0 - b
    # Report results with SE
    beta.est <- deltaMethod(modelCD, "b-a") # Reports results for beta, because beta = b - a.
#     print("beta.est = b-a")
#     print(beta.est)
    gamma.est <- deltaMethod(modelCD, "1-b") # Reports results for gamma, because gamma = 1 - b.
#     print("gamma.est = 1 - b")
#     print(gamma.est)
    # Now calculate confidence intervals.
#     print(paste("dofCD =", dofCD))
#     print(paste("tvalCD =", tvalCD))
    betaCICD <- with(beta.est, Estimate + c(-1.0, 1.0) * tvalCD * SE) # Gives the confidence interval on beta.
#     print("betaCICD:")
#     print(betaCICD)
    gammaCICD <- with(gamma.est, Estimate + c(-1.0, 1.0) * tvalCD * SE) # Gives the confidence interval on gamma.
#     print("gammaCICD:")
#     print(gammaCICD)
    # Combine all estimates and their confidence intervals into data frames with intelligent row names
    estCD <- data.frame(lambda = lambda, alpha = alpha, beta = beta, gamma = gamma)
    row.names(estCD) <- "CDe"
    # The [1] subscripts pick off the lower confidence interval
    lowerCD <- data.frame(lambda=ciCD["lambda","2.5%"], alpha=ciCD["a", "2.5%"], beta=betaCICD[1], gamma=gammaCICD[1])
    row.names(lowerCD) <- "-95% CI"
    # The [2] subscripts pick off the lower confidence interval
    upperCD <- data.frame(lambda=ciCD["lambda","97.5%"], alpha=ciCD["a", "97.5%"], beta=betaCICD[2], gamma=gammaCICD[2])
    row.names(upperCD) <- "+95% CI"
  }
  # Now create the data for a table.
  dataCD <- rbind(upperCD, estCD, lowerCD)
  return(dataCD)
}

############
# Creates a row for the Cobb Douglas parameters table for the given country (2-letter code) and energyType (Q, X, or U)
##
cobbDouglasCountryRow <- function(countryName, energyType){
  dataCD <- cobbDouglasData(countryName, energyType)
  if (missing(energyType)){
    out <- cbind(dataCD["-95% CI", "lambda"], dataCD["CD", "lambda"], dataCD["+95% CI", "lambda"],
                 dataCD["-95% CI", "alpha"],  dataCD["CD", "alpha"],  dataCD["+95% CI", "alpha"],
                 dataCD["-95% CI", "beta"],   dataCD["CD", "beta"],   dataCD["+95% CI", "beta"])
  } else {
    out <- cbind(dataCD["-95% CI", "lambda"], dataCD["CDe", "lambda"], dataCD["+95% CI", "lambda"],
                 dataCD["-95% CI", "alpha"],  dataCD["CDe", "alpha"],  dataCD["+95% CI", "alpha"],
                 dataCD["-95% CI", "beta"],   dataCD["CDe", "beta"],   dataCD["+95% CI", "beta"],
                 dataCD["-95% CI", "gamma"],  dataCD["CDe", "gamma"],  dataCD["+95% CI", "gamma"])
  }
  return(out)
}

###########################################
# Creates a number of rows in a data.frame that contain information 
# about the coefficients of a Cobb-Douglas model for countryName.
# Each parameter has its own row with confidence intervals.
# The country name is in a column. Which parameter is involved is
# also in a column.
# 
# The return type is a data.frame.
##
cobbDouglasCountryRowsForParamsGraph <- function(countryName, energyType){
  #Create three rows, one for each parameter. Each row is a data.frame so that it is plottable!
  if (missing(energyType)){
    valueRow <- "CD"
    dataCD <- cobbDouglasData(countryName)
  } else {
    valueRow <- "CDe"
    dataCD <- cobbDouglasData(countryName, energyType)
  }
  # These rows are common to the "with" and "without" energy cases.
  lambdaRow <- data.frame(country = countryName, 
                          parameter = "lambda", 
                          lowerCI = dataCD["-95% CI", "lambda"], 
                          value = dataCD[valueRow, "lambda"], 
                          upperCI = dataCD["+95% CI", "lambda"])
  alphaRow <- data.frame(country = countryName, 
                         parameter = "alpha",
                         lowerCI = dataCD["-95% CI", "alpha"],
                         value = dataCD[valueRow, "alpha"],  
                         upperCI = dataCD["+95% CI", "alpha"])
  betaRow <- data.frame(country = countryName, 
                        parameter = "beta",
                        lowerCI = dataCD["-95% CI", "beta"],
                        value = dataCD[valueRow, "beta"], 
                        upperCI = dataCD["+95% CI", "beta"])
  if (missing(energyType)){
    table <- rbind(lambdaRow, alphaRow, betaRow)
  } else {
#     print("In not missing energyType")
#     print(dataCD)
    gammaRow <- data.frame(country = countryName, 
                           parameter = "gamma",
                           lowerCI = dataCD["-95% CI", "gamma"],
                           value = dataCD[valueRow, "gamma"], 
                           upperCI = dataCD["+95% CI", "gamma"])
#     print(gammaRow)
    table <- rbind(lambdaRow, alphaRow, betaRow, gammaRow)
  }
  return(table)
}

############################
# Aggregates the Cobb-Douglas results into a big data table. No energy.
##
cobbDouglasParamsTableNoEnergy <- function(){
  #Do rbind on the results of creating a row in the table for every country abbreviation that we know.
  dataCD <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasCountryRow))
  colnames(dataCD) <- c(" ", "$\\lambda$", " ", 
                        " ", "$\\alpha$",  " ",
                        " ", "$\\beta$",   " ")
  rownames(dataCD) <- countryAbbrevs
  tableCD <- xtable(dataCD, 
                    caption="Cobb-Douglas (without energy) for 1980-2011 (US, UK, JP), 1991-2010 (CN and ZA), and 1991-2011 (SA, IR, TZ, and ZM). (Parameter estimates beneath symbol. 95\\% confidence interval bounds to left and right.)", 
                    label="tab:CD_Parameters_No_Energy",
                    digits = c(1, 4,4,4, 2,2,2, 2,2,2),
                    align = "r|ccc|ccc|ccc") #Sets alignment of the numbers in the columns
  return(tableCD)
}

############################
# Aggregates the Cobb-Douglas results into a big data table for the given energyType.
##
cobbDouglasParamsTableWithEnergy <- function(energyType){
  #Do rbind on the results of creating a row in the table for every country abbreviation that we know.
  dataCD <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasCountryRow, energyType=energyType))
  colnames(dataCD) <- c(" ", "$\\lambda$", " ", 
                        " ", "$\\alpha$",  " ",
                        " ", "$\\beta$",   " ",
                        " ", "$\\gamma$",  " ")
  rownames(dataCD) <- countryAbbrevs
  tableCD <- xtable(dataCD, 
                    caption=paste("Cobb-Douglas (with $", tolower(energyType), "$) for 1980-2011 (US, UK, JP), 1991-2010 (CN and ZA), and 1991-2011 (SA, IR, TZ, and ZM). (Parameter estimates beneath symbol. 95\\% confidence interval bounds to left and right.)", sep=""), 
                    label=paste("tab:CD_Parameters_With_", energyType, sep=""),
                    digits = c(1, 4,4,4, 2,2,2, 2,2,2, 2,2,2),
                    align = "r|ccc|ccc|ccc|ccc") #Sets alignment of the numbers in the columns
  return(tableCD)
}

#############################
# Creates a graph with confidene intervals for the Cobb-Douglas model for the given energyType
##
createCDParamsGraph <- function(energyType){
  
  if (missing(energyType)){
    # Create a data table with the following columns:
    # country abbrev, parameter (lambda, alpha, or beta), -95% CI, value, +95% CI
    dataTable <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasCountryRowsForParamsGraph))
    graph <- segplot(country ~ upperCI + lowerCI | parameter, 
                     data = dataTable, 
                     centers = value, #identifies where the dots should be placed
                     draw.bands = FALSE, #provides nicer error bars
                     horizontal = FALSE, #makes error bars vertical and puts the countries in the x axis
                     layout = c(2,2), #2 column, 2 row
                     index.cond = list(c(2,3,1)), #orders the panels as alpha, beta, lambda, gamma
                     strip = strip.custom(factor.levels=c("$\\lambda$", "$\\alpha$", "$\\beta$"), #sets labels in strip 
                                          bg="white"), #sets background color in strip
                     col = "black", #Sets line color to black
                     lwd = 1, #Sets line width to 1.0
                     ylim = list(c(-0.05, 0.1), c(-0.5, 1.5), c(-0.5, 1.5)), #y axis limits
                     scales = list(cex=scaleTextSize, #controls text size on scales.
                                   tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                                   x=list(cex=0.75), #reduces text size so that country abbrevs are legible
                                   y=list(relation="free", #allow each axis to be different
                                          at=list(c(0.0, 0.05, 0.1),   #y tick mark for lambda
                                                  c(0.0, 0.5, 1.0), 
                                                  c(0.0, 0.5, 1.0)
                                                  )
                                          )
                                   )
                     )
   } else {
    # Create a data table with the following columns:
    # country abbrev, parameter (lambda, alpha, or beta), -95% CI, value, +95% CI
    dataTable <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasCountryRowsForParamsGraph, energyType=energyType))
    graph <- segplot(country ~ upperCI + lowerCI | parameter, 
                     data = dataTable, 
                     centers = value, #identifies where the dots should be placed
                     draw.bands = FALSE, #provides nicer error bars
                     horizontal = FALSE, #makes error bars vertical and puts the countries in the x axis
                     layout = c(2,2), #2 column, 2 row
                     index.cond = list(c(2,3,1,4)), #orders the panels as alpha, beta, lambda, gamma
                     #set labels and bg color in strip
                     strip = strip.custom(factor.levels=c("$\\lambda$", "$\\alpha$", "$\\beta$", "$\\gamma$"),  
                                          bg="white"),
                     col = "black", #Sets line color to black
                     lwd = 1, #Sets line width to 1.0
                     ylim = list(c(-0.05, 0.1), c(-0.5, 1.5), c(-0.5, 1.5), c(-0.5, 1.5)), #y axis limits
                     scales = list(cex=scaleTextSize, #controls text size on scales.
                                   tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                                   x=list(cex=0.75), #reduces text size so that country abbrevs are legible
                                   y=list(relation="free", #allow each axis to be different
                                          at=list(c(0.0, 0.05, 0.1),   #y tick mark for lambda
                                                  c(0.0, 0.5, 1.0), 
                                                  c(0.0, 0.5, 1.0),
                                                  c(0.0, 0.5, 1.0)
                                                  )
                                          )
                                   )
                     )
   }
   return(graph)
}

##############################
# Creates a graph that plots predicted GDP as lines and GDP data as open circles.
##
createCDLatticeGraph <- function(){
  dataTable <- loadData("All") #Grab the raw data
  predictions <- cobbDouglasPredictionsColumn()     #Predictions from CD without energy
  predictionsQ <- cobbDouglasPredictionsColumn("Q") #Predictions from CD with Q
  predictionsX <- cobbDouglasPredictionsColumn("X") #Predictions from CD with X
  predictionsU <- cobbDouglasPredictionsColumn("U") #Predictions from CD with U
  #Now add the predictions columns to the data.
  dataTable <- cbind(dataTable, predictions, predictionsQ, predictionsX, predictionsU) 
  graphType <- "b" #b is for both line and symbol
  lineTypes <- c(0, 1, 2, 4, 1) #line types. See http://en.wikibooks.org/wiki/R_Programming/Graphics
  lineWidths <- c(0, 2, 1, 1, 1) #line widths. 0 means no line.
  colors <- c("black", "black", "red", "blue", "darkorange") #line and symbol colors
  symbols <- c(1, NA, NA, NA, NA)  #NA gives no symbol.
  graph <- xyplot(iGDP+predGDP+predGDPQ+predGDPX+predGDPU ~ Year | Country, data=dataTable,
                  type=graphType,
                  index.cond=list(countryOrderForGraphs), #orders the panels.
                  layout=layoutSpec, #indicates a 3x3 arrangement of panels.
                  strip = strip.custom(factor.levels=countryNamesAlph, bg="white"), #Sets strip parameters
                  as.table=TRUE, #indexing of panels starts in upper left and goes across rows.
                  lty = lineTypes, lwd = lineWidths, col = colors, #Controls line parameters
                  pch = symbols, col.symbol = colors, #Controls symbol parameters
                  key=list(text=list(c("Actual", "No energy", "With $q$", "With $x$", "With $u$")),
                           type=graphType,
                           cex=keyTextSize, #controls size of text in the key
                           lines=list(lty=lineTypes, lwd=lineWidths), #controls line types
                           pch=symbols, col=colors, #controls symbol (plot characters) types
                           columns=keyColumns, x=keyXLoc, y=keyYLoc), #controls columns and position of the key
                  scales=list(cex=scaleTextSize, #controls text size on scales.
                              tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                              y=list(relation="free", #allows each axis to be different
                                     at=c(1,2,3,4,5,6,7,8,9,10) #tick mark locations
                                     )
                              ), 
                  ylim=list(c(1,8), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3)),
                  xlab="", ylab="Indexed GDP (1980=1 or 1991=1)") #axis labels
  return(graph)
}
@

The Cobb-Douglas model without energy is given by

\begin{equation} \label{eq:CD_No_Energy}
  y = a^{\lambda (t-t_0)}k^{\alpha}l^{\beta}.
\end{equation}

Table \ref{tab:CD_Parameters_No_Energy} gives the parameters for the Cobb-Douglas model without energy.

<<CD_Params_Table, results='asis'>>=
print(cobbDouglasParamsTableNoEnergy(), caption.placement="top", sanitize.colnames.function = identity, size="\\tiny")
@

Figure \ref{fig:CD_Params_Graph} shows values and 95\% confidence intervals for the parameters for the Cobb-Douglas model (without energy).

<<CD_Params_Graph, fig.width=figWidth, fig.height=5, fig.cap="Cobb-Douglas (without energy) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createCDParamsGraph()
@

\section{Cobb-Douglas With Energy}

We can force $\alpha$, $\beta$, and $\gamma$ to be in $[0,1]$ by a reparameterization:

$a \in[0,1], b \in [0,1], \alpha=\min(a,b), \beta=|b-a|, \gamma = 1-\max(a,b)$

The Cobb-Douglas model with energy is given by

\begin{equation} \label{eq:CD_With_Energy}
  y = a^{\lambda (t-t_0)}k^{\alpha}l^{\beta}e^{\gamma},
\end{equation}

\noindent where $e$ can be any of thermal energy ($q$), exergy ($x$), or useful work ($u$).

\subsection{Cobb-Douglas with $q$}

The Cobb-Douglas (with thermal energy, $q$) parameters are given in Table \ref{tab:CD_Parameters_With_Q}.

<<CDq_Params_Table, results='asis'>>=
print(cobbDouglasParamsTableWithEnergy("Q"), 
      caption.placement="top", 
      sanitize.colnames.function = identity, 
      size="\\tiny")
@

Figure \ref{fig:CDq_Params_Graph} shows values and 95\% confidence intervals for the parameters for the Cobb-Douglas model (with $q$).

<<CDq_Params_Graph, fig.width=figWidth, fig.height=5, fig.cap="Cobb-Douglas (with $q$) model parameters. Vertical bars indicate 95\\% confidence intervals.", eval=TRUE>>=
createCDParamsGraph("Q")
@

The Cobb-Douglas (with exergy) parameters are given in Table \ref{tab:CD_Parameters_With_X}.

<<CDx_Params_Graph, fig.width=figWidth, fig.height=5, fig.cap="Cobb-Douglas (with $x$) model parameters. Vertical bars indicate 95\\% confidence intervals.", eval=TRUE>>=
createCDParamsGraph("X")
@

Figure \ref{fig:CDx_Params_Graph} shows values and 95\% confidence intervals for the parameters for the Cobb-Douglas model (with $x$).

<<CDx_Params_Table, results='asis'>>=
print(cobbDouglasParamsTableWithEnergy("X"), 
      caption.placement="top", 
      sanitize.colnames.function = identity, 
      size="\\tiny")
@

\subsection{Cobb-Douglas Comparisons}

Figure \ref{fig:CD_GDP_Lattice_Graph} compares predictions from the Cobb-Douglas models (without energy, with $Q$, and with $x$) to historical data.

<<CD_GDP_Lattice_Graph, fig.width=figWidth, fig.height=figHeight, fig.cap="Cobb-Douglas results.">>=
createCDLatticeGraph()
@

\section{CES}

<<CES function, eval=FALSE>>=
cesData <- function(countryName, energyType){
  energyColumnName <- paste("i", energyType, sep="")
  # Load the data that we need.
  dataTable <- loadData(countryName)
    
  # Establish guess values for phi beta, zeta, lambda_L and lambda_E.
  phiGuess <- -20
  betaGuess <- 0.5 # a typical value for beta (exponent on labor)
  zetaGuess <- 0.0004 # a small value
  lambda_LGuess <- 0.007 #assuming no technical progress on the labor-capital portion of the function
  lambda_EGuess <- 0.008 #assuming no technical progress on the energy portion of the function
  
  # Runs a non-linear least squares fit to the data with constraints
  modelCES <- nls(iGDP ~ ((1-zeta) * (exp(lambda_L*iYear) * iCapStk^(1-beta) * iLabor^beta)^phi 
                           + zeta*(exp(lambda_E*iYear) * iQ)^phi)^(1/phi), 
                   algorithm = "port",
                   control = nls.control(maxiter = 500, tol = 1e-06, minFactor = 1/1024, 
                                         printEval = FALSE, warnOnly = FALSE),
                   start = list(phi=phiGuess, beta=betaGuess, zeta=zetaGuess, lambda_L=lambda_LGuess, 
                                lambda_E=lambda_EGuess),
                   lower = list(phi=-Inf, beta=0, zeta=0, lambda_L=-Inf, lambda_E=-Inf),
                   upper = list(phi=0, beta=1, zeta=1, lambda_L=Inf, lambda_E=Inf),
                   data=dataTable)

  aicCES <- AIC(modelCES, k=2) # Checks validity of the model. AIC stands for Akaike's Information Criterion
  print(aicCES)

  # Gives the nls summary table
  summaryCES <- summary(modelCES) # Gives the nls summary table
  print(summaryCES)
  
  # Provides confidence intervals on phi, beta, zeta, lambda_L, and lambda_E. But, we need the CI on alpha.
  ciCES <- confint(modelCES, level = ciLevel)
  print(ciCES)
  
  # Get the estimate for alpha
  beta <- as.numeric(coef(modelCES)["beta"])
  alpha <- 1.0 - beta
  alpha.est <- deltaMethod(modelCES, "1 - beta") # Estimates alpha and its standard error (SE).
  print(alpha.est) 
  
  # Now calculate a confidence interval on alpha
  dofCES <- summaryCES$df[2]
  print(dofCES) # Gives the degrees of freedom for the model.
  tvalCES <- qt(ciHalfLevel, df = dofCES); tvalCES
  # Get confidence intervals for each parameter in the model
  alphaCICES <- with(alpha.est, Estimate + c(-1.0, 1.0) * tvalCES * SE) # CI on alpha.
  print(alphaCICES) 

  # Assemble the data into data frames for the table.
  estCES <- data.frame(phi = coef(modelCES)["phi"], alpha = alpha, 
                       beta = coef(modelCES)["beta"], zeta = coef(modelCES)["zeta"], 
                       lambda_L = coef(modelCES)["lambda_L"], lambda_E = coef(modelCES)["lambda_E"])
  row.names(estCES) <- paste("CES with ", energyType, sep="")
  #print(estCES)  
  # The [1] subscripts pick off the lower confidence interval
  lowerCES <- data.frame(phi = ciCES["phi","2.5%"], alpha = alphaCICES[1], 
                         beta = ciCES["beta", "2.5%"], zeta = ciCES["zeta", "2.5%"],
                         lambda_L = ciCES["lambda_L", "2.5%"], lambda_E = ciCES["lambda_E", "2.5%"])
  row.names(lowerCES) <- "- 95% CI"
  # The [2] subscripts pick off the lower confidence interval
  upperCES <- data.frame(phi = ciCES["phi","97.5%"], alpha = alphaCICES[2], 
                         beta = ciCES["beta", "97.5%"], zeta = ciCES["zeta", "97.5%"],
                         lambda_L = ciCES["lambda_L", "97.5%"], lambda_E = ciCES["lambda_E", "97.5%"])
  row.names(upperCES) <- "+ 95% CI"
  
  # Now create the data for a table.
  dataCES <- rbind(upperCES, estCES, lowerCES)
  print(dataCES)
  return(dataCES)
}

####################################
# Creates a LaTeX printable table from the CES data. This function first calls cesData.
#
# countryName is a string containint the 2-letter abbreviation for the country, e.g. "US" or "CN"
# energyType is a string to be used in table captions reprsenting the type of energy. Typically, "Q", "X", or "U"
#
# returns a printable LaTeX table from xtable.
##
cesTable <- function(countryName, energyType){
  dataCESe <- cesData(countryName, energyType)
  tableCESq <- xtable(dataCESe, caption=paste(countryName, ", 1980-2011.", sep=""), digit = c(4, 1, 2, 2, 6, 5, 5))
}
@

\subsection{CES with $Q$}
<<CESq analysisQ, eval=FALSE>>=
countryName <- "US"
energyType <- "Q"
tableCESq <- cesTable(countryName, energyType)

#CESqTables <- lapply(countryAbbrevs, cesTable, energyType="Q")
@

<<CESq Results, results='asis', eval=FALSE>>=
print(tableCESq, caption.placement="top")

#print(CESqTables[["US"]], caption.placement="top")
#print(CESqTables[["ZA"]], caption.placement="top")
@

\subsection{CES with $X$}

\subsection{CES with $U$}

\section{LINEX}

\subsection{LINEX with $Q$}

\subsection{LINEX with $X$}

\subsection{LINEX with $U$}

\section{Goodness of Fit}

<<AIC_Analysis>>=
###############################
# Creates an xtable object that holds the AIC values for each parameter estimation that we include.
##
createAICTable <- function(){
  # Cobb-Douglas
  models <- lapply(countryAbbrevs, cobbDouglasModel)
  aicCD <- data.frame(lapply(models, AIC))
  rownames(aicCD) <- "CD"
  # Cobb-Douglas with Q
  models <- lapply(countryAbbrevs, cobbDouglasModel, energyType="Q")
  aicCDq <- data.frame(lapply(models, AIC))
  rownames(aicCDq) <- "CD$q$"
  # Cobb-Douglas with X
  models <- lapply(countryAbbrevs, cobbDouglasModel, energyType="X")
  aicCDx <- data.frame(lapply(models, AIC))
  rownames(aicCDx) <- "CD$x$"
  # Cobb-Douglas with U
  models <- c(cobbDouglasModel("US", "U"), cobbDouglasModel("UK", "U"), cobbDouglasModel("JP", "U"))
  aicCDu <- cbind(US=AIC(cobbDouglasModel("US", "U")), 
                  UK=AIC(cobbDouglasModel("UK", "U")), 
                  JP=AIC(cobbDouglasModel("JP", "U")),
                  CN=NA, ZA=NA, SA=NA, IR=NA, TZ=NA, ZM=NA) #No U data for these countries.
  rownames(aicCDu) <- "CD$u$"
  # Create the data.frame table
  out <- rbind(aicCD, aicCDq, aicCDx, aicCDu) 
  # Create the xtable with caption and label
  out <- xtable(out, caption="AIC values for all models.", label="tab:AICTable", digits=1)
  return(out)
}
@

We assess goodness of fit via the Akaike Information Criterion (AIC). AIC values for all models and all countries are shown in Table \ref{tab:AICTable}. Increasing goodness of fit is indicated by smaller (i.e., more negative) AIC values. AIC values can be compared per data set (i.e., per country) but not across data sets (i.e., not across countries). 

<<AIC_Table, results='asis', label="AIC_Table">>=
print(createAICTable(), 
      caption.placement="top", 
      sanitize.rownames.function = identity)
      
@

The AIC results show *****************.

%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}

%% References
%%
%% Following citation commands can be used in the body text:
%%
%%  \citet{key}  ==>>  Jones et al. (1990)
%%  \citep{key}  ==>>  (Jones et al., 1990)
%%
%% Multiple citations as normal:
%% \citep{key1,key2}         ==>> (Jones et al., 1990; Smith, 1989)
%%                            or  (Jones et al., 1990, 1991)
%%                            or  (Jones et al., 1990a,b)
%% \cite{key} is the equivalent of \citet{key} in author-year mode
%%
%% Full author lists may be forced with \citet* or \citep*, e.g.
%%   \citep*{key}            ==>> (Jones, Baker, and Williams, 1990)
%%
%% Optional notes as:
%%   \citep[chap. 2]{key}    ==>> (Jones et al., 1990, chap. 2)
%%   \citep[e.g.,][]{key}    ==>> (e.g., Jones et al., 1990)
%%   \citep[see][pg. 34]{key}==>> (see Jones et al., 1990, pg. 34)
%%  (Note: in standard LaTeX, only one note is allowed, after the ref.
%%   Here, one note is like the standard, two make pre- and post-notes.)
%%
%%   \citealt{key}          ==>> Jones et al. 1990
%%   \citealt*{key}         ==>> Jones, Baker, and Williams 1990
%%   \citealp{key}          ==>> Jones et al., 1990
%%   \citealp*{key}         ==>> Jones, Baker, and Williams, 1990
%%
%% Additional citation possibilities
%%   \citeauthor{key}       ==>> Jones et al.
%%   \citeauthor*{key}      ==>> Jones, Baker, and Williams
%%   \citeyear{key}         ==>> 1990
%%   \citeyearpar{key}      ==>> (1990)
%%   \citetext{priv. comm.} ==>> (priv. comm.)
%%   \citenum{key}          ==>> 11 [non-superscripted]
%% Note: full author lists depends on whether the bib style supports them;
%%       if not, the abbreviated list is printed even when full requested.
%%
%% For names like della Robbia at the start of a sentence, use
%%   \Citet{dRob98}         ==>> Della Robbia (1998)
%%   \Citep{dRob98}         ==>> (Della Robbia, 1998)
%%   \Citeauthor{dRob98}    ==>> Della Robbia


%% References with bibTeX database:

\bibliographystyle{model2-names}
\bibliography{<your-bib-database>}

%% Authors are advised to submit their bibtex database files. They are
%% requested to list a bibtex style file in the manuscript if they do
%% not want to use model2-names.bst.

%% References without bibTeX database:

% \begin{thebibliography}{00}

%% \bibitem must have one of the following forms:
%%   \bibitem[Jones et al.(1990)]{key}...
%%   \bibitem[Jones et al.(1990)Jones, Baker, and Williams]{key}...
%%   \bibitem[Jones et al., 1990]{key}...
%%   \bibitem[\protect\citeauthoryear{Jones, Baker, and Williams}{Jones
%%       et al.}{1990}]{key}...
%%   \bibitem[\protect\citeauthoryear{Jones et al.}{1990}]{key}...
%%   \bibitem[\protect\astroncite{Jones et al.}{1990}]{key}...
%%   \bibitem[\protect\citename{Jones et al., }1990]{key}...
%%   \harvarditem[Jones et al.]{Jones, Baker, and Williams}{1990}{key}...
%%

% \bibitem[ ()]{}

% \end{thebibliography}

\end{document}

%%
%% End of file `elsarticle-template-2-harv.tex'.