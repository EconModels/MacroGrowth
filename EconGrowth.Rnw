% This article has been prepared for publication in Energy Economics in RStudio with knitr.
% According to http://www.elsevier.com/author-schemas/the-elsarticle-latex-document-class, we should be using the
% elsarticle.cls file.
% According to http://cdn.elsevier.com/assets/pdf_file/0006/109392/journal_refstyles.pdf, we should be using
% elsarticle-template-2-harv.tex as the template for the text.
% Furthermore, we should be using model2-names.bst for the bibliographic references.
% The approach here is to load the frontmatter and backmatter from elsarticle-template-2-harv.tex
% both ahead of and behind the text for our paper.
% -- Matthew Kuperus Heun, 2013-01-18

%% This is file `elsarticle-template-2-harv.tex',
%%
%% Copyright 2009 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle  Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for Elsevier's document class `elsarticle'
%% with harvard style bibliographic references
%%
%% $Id: elsarticle-template-2-harv.tex 155 2009-10-08 05:35:05Z rishi $
%% $URL: http://lenova.river-valley.com/svn/elsbst/trunk/elsarticle-template-2-harv.tex $
%%
\documentclass[preprint,authoryear,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[authoryear,preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,authoryear,1p,times]{elsarticle}
%% \documentclass[final,authoryear,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,authoryear,3p,times]{elsarticle}
%% \documentclass[final,authoryear,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,authoryear,5p,times]{elsarticle}
%% \documentclass[final,authoryear,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
%% \usepackage{graphics}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

\usepackage{soul} %Provides strikethrough text
\usepackage{float} %Allows precise positioning of tables and figures within the text
\usepackage{amsmath} %Allows \begin{equation*} \end{equation*} for unnumbered equations

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
%% \usepackage{lineno}

%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon (default)
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   authoryear - selects author-year citations (default)
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%   longnamesfirst  -  makes first citation full author list
%%
%% \biboptions{longnamesfirst,comma}

% \biboptions{}

\journal{Energy Economics}

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{An Empirical Analysis of the Role of Energy in Economic Growth}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{<author name>}
%% \address[label1]{<address>}
%% \address[label2]{<address>}

\author[Calvin]{Caleb Reese}
\author[Calvin]{Lucas Timmer}
\author[Stellenbosch]{Martin de Wit}
\author[Calvin]{Matthew Kuperus Heun\corref{cor1}}
\ead{mkh2@calvin.edu, tel: +1 (616) 526-6663, fax: +1 (616) 526-6501}

\cortext[cor1]{Corresponding author}
\address[Calvin]{Engineering Department, Calvin College, Grand Rapids, MI 49546, USA}
\address[Stellenbosch]{Stellenbosch University, Faculty of Economics and Management Sciences, School of Public Leadership, P.O. Box 610, Bellville 7535, South Africa}

\begin{abstract}
%% Text of abstract
*********** Add abstract ***********
\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
economic growth \sep energy \sep cobb-douglas \sep CES \sep LINEX
%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)
\end{keyword}

\end{frontmatter}

% \linenumbers
%% main text

\section*{To-do List}
\begin{itemize}
\item Reese: Add text from Word verson of paper to the LaTeX version.
\item Heun: Add CES production function fits
      \begin{itemize}
      \item GDP comparison graph
      \item parameter graphs for each country
      \item parameter tables for each country in the appendix
      \item AIC rows in the AIC table
      \end{itemize}
\item Heun: Deal with missing covariance numbers when columns have unequal length.
\item Heun: Eliminate blanks in the coefficient tables for the 95\% CIs in the Cobb-Douglas with energy rows. Asked Pruim about this via email on 4 Feb 2013 but have not heard a response.
      \begin{itemize}
      \item ZA: lower bound on $\lambda$ and upper bound on $\alpha$
      \item ZM: lower bound on $\lambda$
      \end{itemize}
\item Heun: Eliminate blanks in the coefficient tables for the 95\% CIs in the LINEX model
      \begin{itemize}
      \item Zambia, upper bound on $c_t$
      \end{itemize}
\item Heun: Fix warnings of the form ``Warning:  step factor 0.000488281 reduced below ’minFactor’ of 0.000976562'' in the code that generates the Cobb-Douglas with energy fits.
\item Heun: x-axis labels only on bottom for 9-panel lattice graphs
\item Heun: adjust y axis limits on $a_0$ and $c_t$ parameter graphs for the LINEX model AFTER we finish debugging the LINEX models.
\item \st{Heun: Ask Martin if he can supply an ``Economics'' affiliation. Will probably make a stronger paper.}
\item \st{Heun: Create a table of AIC values for each fit.}
\item \st{Heun: Add $u$ predictions for Cobb-Douglas}
\item \st{Heun: move tables to an appendix at the end.}
\item \st{Heun: Add acknowledgements (Dad, Pruim)}
\item \st{Heun: Add $u$ parameter table and graph}
\item \st{Heun: Add covariance metrics.}
\item \st{Heun: Add single factor fits}
      \begin{itemize}
      \item \st{correct sizes for parameter graphs for each country}
      \item \st{parameter graphs ($\lambda$ and $m$) for each country}
      \item \st{parameter tables for each country in the appendix}
      \item \st{GDP comparison graph}
      \item \st{AIC rows in the AIC table}
      \end{itemize}
\item \st{Heun: Add setup variables for figure height and width where not already included.}
\item \st{Heun: Add LINEX production function fits}
      \begin{itemize}
      \item \st{parameter graphs for each country}
      \item \st{parameter tables for each country in the appendix}
      \item \st{AIC rows in the AIC table}
      \item \st{GDP comparison graph}
      \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

*********** Caleb, put your LaTeX code here. *************

<<setup, echo=FALSE, message=FALSE>>=
require(knitr)
require(lattice)
require(latticeExtra)
require(ggplot2)
require(car)
require(mosaic)
require(xtable)
require(nlmrt)
require(micEconCES)
# tikz allows use of LaTeX formatting and font in graphs. Allows for a consistent look across the paper.
# See http://r-forge.r-project.org/R/?group_id=440 for instructions on installing tikzDevice.
require(tikzDevice) 
trellis.par.set(theme=theme.mosaic())
options(width=75)
options(show.signif.stars=TRUE)
opts_chunk$set(
  # ********************************************************************************************************
  eval=FALSE,
  # ********************************************************************************************************
  warning=TRUE, #Tells whether to show warnings in the output.
  dev='tikz',    #Allows LaTeX code in graphical output. E.g., "$y$" for a variable name in the legend for a graph.
  tidy=FALSE,
  comment=NA,
  #Tells whether to cache output from chunks are saved. Cacheing saves time. 
  #However, references to LaTeX tables DO NOT WORK if cacheing is turned on (cache=TRUE).
  cache=FALSE,
  echo=FALSE,    #Tells whether to echo code for all chunks. Set TRUE on an individual chunk to see its code.
  message=FALSE) #Turns off messages for all chunks. Set TRUE on an individual chunk to see it.

# Statistical significance levels. We'll work with 95% CIs
ciLevel <- 0.95
ciHalfLevel <- ciLevel + (1.0-ciLevel)/2.0
# List of countries
countryAbbrevs <- c(US="US", UK="UK", JP="JP", CN="CN", ZA="ZA", SA="SA", IR="IR", TZ="TZ", ZM="ZM")
countryAbbrevsU <- c(US="US", UK="UK", JP="JP") #Only these countries have useful work data
countryNamesAlph <- c(CN="China", IR="Iran", JP="Japan", SA="Saudi Arabia", TZ="Tanzania", UK="United Kingdom", US="USA", ZA="South Africa", ZM="Zambia") #In alphabetical order.
energyTypes <- c(Q="Q", X="X", U="U") # List of energy types
factors <- c(K="K", L="L", Q="Q", X="X", U="U") # List of factors of production
########### Several global parameters for graphs. Set here and use below to ensure consistent appearance of graphs.
# Set the order for presenting countries in 3x3 lattice graphs. Default is alphabetical. 
# "1" means first alphabetically.
countryOrderForGraphs <- c(7,6,3,1,8,5,4,2,9) # Sets the order as US, UK, JP, CN, ZA, TZ, SA, IR, ZM.
maxWidth <- 6.5 #Inches
# Full page lattice plot sizes
ninePanelLayoutSpec <- c(3,3) #indicates a 3x3 arrangement of panels.
ninePanelGraphWidth <- maxWidth     
ninePanelGraphHeight <- 7.5  #Inches
keyTextSize <- 0.85 #85% of normal size
keyColumns <- 1 #Want only 1 column in the key for lattice graphs
keyXLoc <- 0.01 #x position of the key
keyYLoc <- 0.95 #y position of the key
# Parameter graphs are tricky to ensure same size. I've found that with height set to 5 in for the 
# cd graphs and 2.93 in for the sf graphs, I get a nearly-exact match with graph size. From these settings I 
# can set up 2 equations:
#    5 in = 2*hgraph + haxis
#    2.93 in = hgraph + haxis
# to estimate that h_axis = 0.86 in and hgraph = 2.05 in.
h_param_graph <- 2.07 # Inches for a single panel
h_param_axis <- 0.86 # Inches (also includes whatever margin is applied)
sfParameterGraphHeight <- h_param_graph + h_param_axis
cdParameterGraphHeight <- 2*h_param_graph + h_param_axis
linexParameterGraphHeight <- h_param_graph + h_param_axis
sfParameterGraphWidth <- maxWidth
cdParameterGraphWidth <- maxWidth
cesParameterGraphWidth <- maxWidth
linexParameterGraphWidth <- maxWidth
# Other graph parameters that apply to all graphs
scaleTextSize <- 1.0  #Multiple of normal size
scaleTickSize <- -0.5 #50% of normal size and pointing INWARD!
@

<<Data Functions, eval=TRUE>>=
#################################
# This function loads data given a country abbreviation.
# The file name from which data will be loaded is assumed to be of the form 
# "<countryAbbrev>Data.txt". The file is assumed to exist in a subfolder of this project called "data".
#
# countryAbbrev is a string containing the 2-letter abbreviation for the country, e.g. "US" or "CN"
#
# returns a data.frame with the data that has been loaded
##
loadData <- function(countryAbbrev){
  # Read the data file as a table with a header.  
  fileName <- paste("data/", countryAbbrev, "Data.txt", sep="")
  dataTable <- read.table(fileName, header = TRUE)
  return(dataTable)
}

###############################
# Tells whether we have data for this combination of country and energy type for a single-factor curve fit.
#
# returns logical value (TRUE or FALSE)
##
haveDataSF <- function(countryAbbrev, factor){
  # The design here is to go through several cases where data is unavailable and
  # return FALSE. If we make it through all of those cases, we'll return TRUE.
  if (!(countryAbbrev %in% countryAbbrevs)){
    # If we don't know the country, we don't have data
    return(FALSE)
  }
  if (missing(factor) || is.na(factor)){
    # If we don't have a factor, we don't have data.
    return(FALSE)
  }
  if (!(factor %in% factors)){
    # If we don't know the factor, we don't have data
    return(FALSE)
  }
  if (factor == "U" && (!(countryAbbrev %in% countryAbbrevsU))){
    # We have U data for only a few countries.
    return(FALSE)
  }
  return(TRUE)
}

###############################
# Tells whether we have data for this combination of country and energy type for a Cobb-Douglas curve fit.
# a missing energyType or energyType == NA means that we want to develop a model without energy, if possible.
#
# returns logical value (TRUE or FALSE)
##
haveDataCD <- function(countryAbbrev, energyType){
  # The design here is to go through several cases where data is unavailable and
  # return FALSE. If we make it through all of those cases, we'll return TRUE.
  if (!(countryAbbrev %in% countryAbbrevs)){
    # If we don't know the country, we don't have data
    return(FALSE)
  }
  if (missing(energyType) || is.na(energyType)){
    # If we don't want energy included, we have data for all known countries. We need to check this case
    # first, BEFORE doing various checks on the energyType.
    return(TRUE)
  }
  if (!(energyType %in% energyTypes)){
    # If we want to include energy, we know only a few types. So, return false if we don't know the energy type.
    return(FALSE)
  }
  if (energyType == "U" && (!(countryAbbrev %in% countryAbbrevsU))){
    # We have U data for only a few countries.
    return(FALSE)
  }
  return(TRUE)
}

#####################
# This function adds NA rows to the end of a data.frame to ensure that the df is 
# the same length as the country data set
# returns a modified version of df that includes the padded rows filled with "NA".
##
padRows <- function(countryAbbrev, df){
  nRowsData <- nrow(loadData(countryAbbrev)) #Gets number of rows in data set
  nRowsDF <- nrow(df)
  nRowsToAdd <- nRowsData - nRowsDF
  nCol <- ncol(df)
  dfToAppend <- as.data.frame(matrix(NA, ncol=nCol, nrow=nRowsToAdd))
  colnames(dfToAppend) <- colnames(df)
  return(rbind(df, dfToAppend))
}

##############################
# Returns an integer representing the column index for some data
# dataTable the data.frame in which you want to change column names
# factor should be a string and one of Year, Y, K, L, Q, X, or U
##
columnIndex <- function(dataTable, factor){
  if (factor == "Year"){
    colName <- "iYear"
  } else if (factor == "Y"){
    colName <- "iGDP"
  } else if (factor == "K"){
    colName <- "iCapStk"
  } else if (factor == "L"){
    colName <- "iLabor"
  } else if (factor == "Q"){
    colName <- "iQ"
  } else if (factor == "X"){
    colName <- "iX"
  } else if (factor == "U"){
    colName <- "iU"
  } else {
    print(paste("Unknown factor:", factor, "in colIndex. Terminating execution."))
    quit()
  }
  # Get the desired column index.
  colIndex <- which(names(dataTable) %in% colName) #Find index of desired column
  return(colIndex)  
}

##############################
# Replaces a column name with the given string
# dataTable the data.frame that you're working with
# factor should be a string and one of Year, Y, K, L, Q, X, or U
# newName should be a string and the desired new name of the column
# returns dataTable with a new name for one of its factor column.
##
replaceColName <- function(dataTable, factor, newName){
  colIndex <- columnIndex(dataTable, factor)
  colnames(dataTable)[colIndex] <- newName #Change desired column name to newName
  return(dataTable)
}

##############################
# Returns an xtable of covariance information for the specified country.
##
covarianceTable <- function(countryAbbrev){
  data <- loadData(countryAbbrev)
  # Grab only the data we want.
  dataForCovar <- cbind(data$iGDP, data$iCapStk, data$iLabor, data$iQ, data$iX)
  names <- c("$y$", "$k$", "$l$", "$q$", "$x$")
  if (countryAbbrev %in% countryAbbrevsU){
    # Add U data only if we have it.
    dataForCovar <- cbind(dataForCovar, data$iU)
    names <- c("$y$", "$k$", "$l$", "$q$", "$x$", "$u$")
  }
  covarResults <- cor(dataForCovar)
  colnames(covarResults) <- names
  rownames(covarResults) <- names
  covarXtable <- xtable(covarResults, 
                      caption=paste(countryAbbrev, "covariance table."), 
                      label=paste("tab:Covariance_", countryAbbrev, sep=""))
  return(covarXtable)
}

###############################
# Prints a covariance table for countryAbbrev
##
printCovarTable <- function(countryAbbrev){
  print(covarianceTable(countryAbbrev), 
                      caption.placement="top", 
                      sanitize.rownames.function = identity,
                      sanitize.colnames.function = identity,
                      size="\\tiny",
                      table.placement="H")
}

####################################
# Creates a graph that displays all of the factors of production for all countries.
##
createHistoricalLatticeGraph <- function(){
  dataTable <- loadData("All")
  graphType <- "b" #b is for both line and symbol
  lineTypes <- c(0, 1, 5, 2, 4, 1) #line types. See http://en.wikibooks.org/wiki/R_Programming/Graphics
  lineWidths <- c(0, 2, 2, 1, 1, 1) #line widths. 0 means no line.
  colors <- c("black", "black", "black", "red", "blue", "darkorange") #line and symbol colors
  symbols <- c(1, NA, NA, NA, NA, NA)  #NA gives no symbol.
  graph <- xyplot(iGDP+iCapStk+iLabor+iQ+iX+iU ~ Year | Country, data=dataTable,
                  type = graphType,
                  index.cond = list(countryOrderForGraphs), #orders the panels.
                  layout = ninePanelLayoutSpec, 
                  strip = strip.custom(factor.levels=countryNamesAlph, bg="white"), #Sets strip parameters
                  as.table = TRUE, #indexing of panels starts in upper left and goes across rows.
                  lty = lineTypes, lwd = lineWidths, col = colors, #Controls line parameters
                  pch = symbols, col.symbol = colors, #Controls symbol parameters
                  key=list(text=list(c("$y$", "$k$", "$l$", "$q$", "$x$", "$u$")),
                           type=graphType,
                           cex=keyTextSize, #controls size of text in the key
                           lines=list(lty=lineTypes, lwd=lineWidths), #controls line types
                           pch=symbols, col=colors, #controls symbol (plot characters) types
                           columns=keyColumns, x=keyXLoc, y=keyYLoc), #controls columns and position of the key
                  scales=list(cex=scaleTextSize, #controls text size on scales.
                              tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                              y=list(relation="free", #allows each axis to be different
                                     at=c(1,2,3,4,5,6,7,8,9,10) #tick mark locations
                                     )
                              ),
                  ylim=list(c(1,10), c(1,4), c(1,4), c(1,4), c(1,4), c(1,4), c(1,4), c(1,4), c(1,4)), #y axis limits
                  xlab="", ylab="Indexed (1980=1 or 1991=1)") #axis labels
  return(graph)
}
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Historical Data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Figure \ref{fig:Historical_Lattice_Graph} shows historical data, including GDP ($y$), capital stock ($k$), labor ($l$), and the various energy types ($q$, $x$, and $u$). Factors of production track each other closely, and large covariances among these variables can be seen in Tables \ref{tab:Covariance_US} through \ref{tab:Covariance_ZM}.

<<Historical_Lattice_Graph, fig.width=ninePanelGraphWidth, fig.height=ninePanelGraphHeight, fig.pos="H", fig.cap="Historical data. Indexed GDP ($y$), capital stock ($k$), labor ($l$), thermal energy ($q$), exergy ($x$), and useful work ($u$).">>=
createHistoricalLatticeGraph()
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Single-factor Models (SF)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<single-factor functions, eval=TRUE>>=
####################
# Returns an nls single-factor model for the country and factor specified.
# factor should be one of "K", "L", "Q", "X", or "U".
##
singleFactorModel <- function(countryAbbrev, factor){
  dataTable <- loadData(countryAbbrev) #Load the data that we need.
  # We'll change the name of the desired column to "f"
  dataTable <- replaceColName(dataTable, factor, "f")
  # Now do the fit.
  lambdaGuess <- 0.0 #guessing lambda = 0 means there is no technological progress.
  # Some economies need different guesses
  if (countryAbbrev == "IR" && factor == "X"){
    mGuess <- 0.7
  } else {
    # This works for every other combination of country and factor.
    mGuess <- 0.5
  }
  start <- list(lambda=lambdaGuess, m=mGuess)
  # Runs a non-linear least squares fit to the data. We've replaced beta with 1-alpha for simplicity.
  model <- iGDP ~ exp(lambda*iYear) * f^m
  modelSF <- nls(formula=model, data=dataTable, start = start)
#   model <- iGDP ~ exp(lambda*iYear) * f^m
#   modelSF <- wrapnls(formula=model, data=dataTable, start=list(lambda=lambdaGuess, m=mGuess))
  return(modelSF)
}

#########################
# Takes the single-factor fitted models and creates per-country predictions for them.
# Returns a data.frame with the predictions.
##
singleFactorPredictions <- function(countryAbbrev, factor){
  # Can't make predictions for any of CN, ZA, SA, IR, TZ, or ZM if we're interested in U
  if (!(haveDataSF(countryAbbrev, factor))){
    #If we don't have data for this combination of countryAbbrev and energyType, 
    # return a column of NAs if the above conditions have been met.
    nRows <- 21 # All of these countries need 21 rows.
    df <- as.data.frame(matrix(NA, ncol = 1, nrow = nRows))
    colnames(df) <- "pred"
    return(df)
  }
  model <- singleFactorModel(countryAbbrev, factor)
  pred <- predict(model) #See http://stackoverflow.com/questions/9918807/how-get-plot-from-nls-in-r
  df <- data.frame(pred)
  # Pad with rows as necessary
  df <- padRows(countryAbbrev, df)
  return(df)
}

#########################
# Takes the single-factor fitted models and creates a single column of predicted GDP values
# that corresponds, row for row, with the AllData.txt file.
##
singleFactorPredictionsColumn <- function(factor){
  out <- do.call("rbind", lapply(countryAbbrevs, singleFactorPredictions, factor=factor))
  colnames(out) <- c(paste("predGDP", factor, sep=""))
  return(out)
}

##############################
# Creates a graph that plots predicted GDP as lines, one for each single factor, and historical GDP 
# data as open circles.
##
createSFLatticeGraph <- function(){
  dataTable <- loadData("All") #Grab the raw data
  predictionsK <- singleFactorPredictionsColumn("K") #Predictions from SF with K
  predictionsL <- singleFactorPredictionsColumn("L") #Predictions from SF with L
  predictionsQ <- singleFactorPredictionsColumn("Q") #Predictions from SF with Q
  predictionsX <- singleFactorPredictionsColumn("X") #Predictions from SF with X
  predictionsU <- singleFactorPredictionsColumn("U") #Predictions from SF with U
  #Now add the predictions columns to the data.
  dataTable <- cbind(dataTable, predictionsK, predictionsL, predictionsQ, predictionsX, predictionsU) 
  graphType <- "b" #b is for both line and symbol
  lineTypes <- c(0, 1, 5, 2, 4, 1) #line types. See http://en.wikibooks.org/wiki/R_Programming/Graphics
  lineWidths <- c(0, 2, 2, 1, 1, 1) #line widths. 0 means no line.
  colors <- c("black", "black", "black", "red", "blue", "darkorange") #line and symbol colors
  symbols <- c(1, NA, NA, NA, NA, NA)  #NA gives no symbol.
  graph <- xyplot(iGDP+predGDPK+predGDPL+predGDPQ+predGDPX+predGDPU ~ Year | Country, data=dataTable,
                  type=graphType,
                  index.cond=list(countryOrderForGraphs), #orders the panels.
                  layout=ninePanelLayoutSpec, #indicates a 3x3 arrangement of panels.
                  strip = strip.custom(factor.levels=countryNamesAlph, bg="white"), #Sets strip parameters
                  as.table=TRUE, #indexing of panels starts in upper left and goes across rows.
                  lty = lineTypes, lwd = lineWidths, col = colors, #Controls line parameters
                  pch = symbols, col.symbol = colors, #Controls symbol parameters
                  key=list(text=list(c("Actual", "With $k$", "With $l$", "With $q$", "With $x$", "With $u$")),
                           type=graphType,
                           cex=keyTextSize, #controls size of text in the key
                           lines=list(lty=lineTypes, lwd=lineWidths), #controls line types
                           pch=symbols, col=colors, #controls symbol (plot characters) types
                           columns=keyColumns, x=keyXLoc, y=keyYLoc), #controls columns and position of the key
                  scales=list(cex=scaleTextSize, #controls text size on scales.
                              tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                              y=list(relation="free", #allows each axis to be different
                                     at=c(1,2,3,4,5,6,7,8,9,10) #tick mark locations
                                     )
                              ), 
                  ylim=list(c(1,8), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3)),
                  xlab="", ylab="Indexed GDP (1980=1 or 1991=1)") #axis labels
  return(graph)
}

#################################################
# Calculates parameter estimates and confidence intervals
# for the single factor production function for a given a country.
#
# countryAbbrev is a string containing the 2-letter abbreviation for the country, e.g. "US" or "CN"
# factor is a string, one of "K", "L", "Q", "X", or "U"
#
# returns a data.frame of data for the Cobb-Douglas model. 
# First row is the +95% CI on all parameters
# Second row contains the parameter estimates
# Third row is the -95% CI on all parameters
# Each column has names: lambda and m corresponding to the parameters in the model.
##
singleFactorData <- function(countryAbbrev, factor){
  #First, check to see if we want useful work (U) AND one of the countries for which we don't have data.
  if (!haveDataSF(countryAbbrev, factor)){
    #Return a column of NAs if we don't have data for this factor
    nRows <- 3 # +95% CI, SF, and -95% CI.
    nCols <- 2 # lambda, m
    df <- as.data.frame(matrix(NA, ncol = nCols, nrow = nRows))
    colnames(df) <- c("lambda", "m")
    rownames(df) <- c("+95% CI", "SF", "-95% CI")
    return(df)
  }
  # We have a combination of country and factor for which we have data.
  modelSF <- singleFactorModel(countryAbbrev, factor)
  summarySF <- summary(modelSF) # Gives the nls summary table.
  ciSF <- confint(modelSF, level = ciLevel)  # Calculates confidence intervals for the SF model.
  dofSF <- summarySF$df[2] # Gives the degrees of freedom for the model.
  tvalSF <- qt(ciHalfLevel, df = dofSF)
  #Single factor model
  lambda <- as.numeric(coef(modelSF)["lambda"])
  m <- as.numeric(coef(modelSF)["m"])
  # Combine all estimates and their confidence intervals into data frames with intelligent row names
  estSF <- data.frame(lambda = lambda, m = m)
  row.names(estSF) <- "SF"
  # The [1] subscripts pick off the lower confidence interval
  lowerSF <- data.frame(lambda=ciSF["lambda","2.5%"], 
                        m=ciSF["m", "2.5%"])
  row.names(lowerSF) <- "-95% CI"
  # The [2] subscripts pick off the upper confidence interval
  upperSF <- data.frame(lambda=ciSF["lambda","97.5%"], 
                        m=ciSF["m", "97.5%"])
  row.names(upperSF) <- "+95% CI"
  # Now create the data for a table and return it
  dataSF <- rbind(upperSF, estSF, lowerSF)
  return(dataSF)
}

############
# Creates a row for the single factor parameters table for the given country (2-letter code) and factor.
##
singleFactorCountryRow <- function(countryAbbrev, factor){
 dataSF <- singleFactorData(countryAbbrev, factor)
 out <- cbind(dataSF["-95% CI", "lambda"], dataSF["SF", "lambda"], dataSF["+95% CI", "lambda"],
              dataSF["-95% CI", "m"],  dataSF["SF", "m"],  dataSF["+95% CI", "m"])
 return(out)
}

############################
# Aggregates the single-factor results into a big data table for the given factor.
##
singleFactorParamsTable <- function(factor){
  #Do rbind on the results of creating a row in the table for every country abbreviation that we know.
  dataSF <- do.call("rbind", lapply(countryAbbrevs, singleFactorCountryRow, factor=factor))
  if (factor == "K"){
    factorString <- "$\\alpha$"
  } else if (factor == "L"){
    factorString <- "$\\beta$"
  } else {
    factorString <- "$\\gamma$"
  }
  colnames(dataSF) <- c(" ", "$\\lambda$", " ", 
                        " ", factorString,  " ")
  rownames(dataSF) <- countryAbbrevs
  tableSF <- xtable(dataSF, 
                    caption=paste("Single-factor model (with $", tolower(factor), "$) parameters for 1980-2011 (US, UK, JP), 1991-2010 (CN and ZA), and 1991-2011 (SA, IR, TZ, and ZM). (Parameter estimates beneath symbol. 95\\% confidence interval bounds to left and right.)", sep=""), 
                    label=paste("tab:SF_Parameters_With_", factor, sep=""),
                    digits = c(1, 4,4,4, 2,2,2),
                    align = "r|ccc|ccc") #Sets alignment of the numbers in the columns
  return(tableSF)
}

###########################################
# Creates a number of rows in a data.frame that contain information 
# about the coefficients of a single factor model for countryAbbrev.
# Each parameter has its own row with confidence intervals.
# The country name is in a column. Which parameter is involved is
# also in a column.
# 
# The return type is a data.frame.
##
singleFactorCountryRowsForParamsGraph <- function(countryAbbrev, factor){
  #Create three rows, one for each parameter. Each row is a data.frame so that it is plottable!
  dataSF <- singleFactorData(countryAbbrev, factor)
  valueRow <- "SF"
  # Create rows for each parameter
  lambdaRow <- data.frame(country = countryAbbrev, 
                          parameter = "lambda", 
                          lowerCI = dataSF["-95% CI", "lambda"], 
                          value = dataSF[valueRow, "lambda"], 
                          upperCI = dataSF["+95% CI", "lambda"])
  mRow <- data.frame(country = countryAbbrev, 
                     parameter = "m",
                     lowerCI = dataSF["-95% CI", "m"],
                     value = dataSF[valueRow, "m"],  
                     upperCI = dataSF["+95% CI", "m"])
  table <- rbind(lambdaRow, mRow)
  return(table)
}

###############################
# Prints a covariance table for the given factor of production
##
printSFParamsTable <- function(factor){
  print(singleFactorParamsTable(factor),
      caption.placement="top", 
      sanitize.colnames.function = identity, 
      size="\\tiny", 
      table.placement="H")
}

#############################
# Creates a graph with confidene intervals for the single-factor model for the given factor
##
createSFParamsGraph <- function(factor){
  # Set the name of the 2nd graph (m)
  factorLabel <- paste("$", tolower(factor), "$", sep="")
  # Create a data table with the following columns:
  # country abbrev, parameter (lambda or m), -95% CI, value, +95% CI
  dataTable <- do.call("rbind", lapply(countryAbbrevs, singleFactorCountryRowsForParamsGraph, factor=factor))
  graph <- segplot(country ~ upperCI + lowerCI | parameter, 
                   data = dataTable,
                   centers = value, #identifies where the dots should be placed
                   draw.bands = FALSE, #provides nicer error bars
                   horizontal = FALSE, #makes error bars vertical and puts the countries in the x axis
                   layout = c(2,1), #2 column, 1 row
                   col = "black", #Sets line color to black
                   lwd = 1, #Sets line width to 1.0
                   strip = strip.custom(bg="white", factor.levels=c("$\\lambda$", factorLabel)),
                   ylim = list(c(-0.05, 0.1), c(-0.5, 1.5)), #y axis limits
                   scales = list(cex=scaleTextSize, #controls text size on scales.
                                 tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                                 x=list(cex=0.75), #reduces text size so that country abbrevs are legible
                                 y=list(relation="free", #allow each axis to be different
                                        at=list(c(0.0, 0.05, 0.1),   #y tick mark for lambda
                                                c(0.0, 0.5, 1.0)
                                                )
                                        )
                                 )
                   )
  
  return(graph)
}
@

We begin by fitting single-factor economic models of the form

\begin{equation} \label{eq:Single_Factor_Generic}
  y = \mathrm{e}^{\lambda (t-t_0)}f^{m}
\end{equation}

\noindent to historical data where the factor of production ($f$) is any of $k$, $l$, $q$, $x$, or $u$, and the exponent ($m$) is $\alpha$ for $k$, $\beta$ for $l$, or $\gamma$ for $q$, $x$, and $u$.

<<SFk_Params_Graph, fig.width=sfParameterGraphWidth, fig.height=sfParameterGraphHeight, fig.pos="H", fig.cap="Single-factor (with $k$) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createSFParamsGraph("K")
@

<<SFl_Params_Graph, fig.width=sfParameterGraphWidth, fig.height=sfParameterGraphHeight, fig.pos="H", fig.cap="Single-factor (with $l$) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createSFParamsGraph("L")
@

<<SFq_Params_Graph, fig.width=sfParameterGraphWidth, fig.height=sfParameterGraphHeight, fig.pos="H", fig.cap="Single-factor (with $q$) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createSFParamsGraph("Q")
@

<<SFx_Params_Graph, fig.width=sfParameterGraphWidth, fig.height=sfParameterGraphHeight, fig.pos="H", fig.cap="Single-factor (with $x$) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createSFParamsGraph("X")
@

<<SFu_Params_Graph, fig.width=sfParameterGraphWidth, fig.height=sfParameterGraphHeight, fig.pos="H", fig.cap="Single-factor (with $u$) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createSFParamsGraph("U")
@

Figure \ref{fig:SF_GDP_Lattice_Graph} compares single-factor model predictions with historica data.

<<SF_GDP_Lattice_Graph, fig.width=ninePanelGraphWidth, fig.height=ninePanelGraphHeight, fig.pos="H", fig.cap="Single-factor results.">>=
createSFLatticeGraph()
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cobb-Douglas Models Without Energy (CD)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<cobb-douglas functions, eval=TRUE>>=
####################
# Returns an nls Cobb-Douglas model for the country specified
# Give an energyType ("Q", "X", or "U") if you want to include an energy term
##
cobbDouglasModel <- function(countryAbbrev, energyType){
  dataTable <- loadData(countryAbbrev) #Load the data that we need.
  #Run the non-linear least squares fit to the data based on whether we have an energy type or not.
  if (missing(energyType)){
    # No energy term desired in the Cobb-Douglas equation.
    # Establish guess values for alpha and lambda.
    lambdaGuess <- 0.0 #guessing lambda = 0 means there is no technological progress.
    alphaGuess <- 0.7 #0.7 gives good results for all countries.  
    start <- list(lambda=lambdaGuess, alpha=alphaGuess)
    # Runs a non-linear least squares fit to the data. We've replaced beta with 1-alpha for simplicity.
    model <- iGDP ~ exp(lambda*iYear) * iCapStk^alpha * iLabor^(1 - alpha)
    modelCD <- nls(formula=model, data=dataTable, start = start,
                   #Include the next 3 lines to fit with constraints.
                   #algorithm = "port",
                   #lower = list(lambda=-Inf, alpha=0), #constraints on lambda and alpha
                   #upper = list(lambda=Inf, alpha=1)
                   )
    return(modelCD)
  } else {
    # We need to do the Cobb-Douglas fit with the desired energy data.
    # To achieve the correct fit, we'll change the name of the desired column
    # to "iEToFit" and use "iEToFit" in the nls function. 
    dataTable <- replaceColName(dataTable, energyType, "iEToFit")
    # Reparameterize to ensure that we meet the constraints:
    # * alpha + beta + gamma = 1.0.
    # * alpha, beta, and gamma are all between 0.0 and 1.0.
    # To do this, we reparameterize as
    # * 0 < a < 1
    # * 0 < b < 1
    # * alpha = min(a, b)
    # * beta = b - a
    # * gamma = 1 - max(a, b)
    # Establish guess values for lambda, alpha, and beta.
    lambdaGuess <- 0.0 #guessing lambda = 0 means there is no technological progress.
    alphaGuess <- 0.9
    betaGuess <- 1.0 - alphaGuess
    aGuess <- alphaGuess
    bGuess <- alphaGuess + betaGuess
    start <- list(lambda=lambdaGuess, a=aGuess, b=bGuess)
    # Now actually do the fit, using the column name "iEToFit".
    model <- iGDP ~ exp(lambda*iYear) * iCapStk^min(a,b) * iLabor^abs(b-a) * iEToFit^(1.0 - max(a,b))
    modelCDe <- nls(formula=model, data = dataTable, start = start,
                    control = nls.control(maxiter = 200, 
                                          tol = 1e-05, 
                                          minFactor = 1/1024, 
                                          printEval=FALSE, #Tells whether to print details of curve fit process.
                                          warnOnly=TRUE),
                    #Include the next 3 lines to fit with constraints.
                    #algorithm = "port",
                    #lower = list(lambda=-Inf, a=0, b=0),
                    #upper = list(lambda= Inf, a=1, b=1)
                    )
    return(modelCDe)
  }
}

#########################
# Takes the Cobb-Douglas fitted models and creates per-country predictions for them.
# Returns a data.frame with the predictions.
##
cobbDouglasPredictions <- function(countryAbbrev, energyType){
  # Can't make predictions for any of CN, ZA, SA, IR, TZ, or ZM if we're interested in U
  if (!missing(energyType)){
    # Consider this replacement only if energyType has been specified.
    if (!(haveDataCD(countryAbbrev, energyType))){
      #If we don't have data for this combination of countryAbbrev and energyType, 
      # return a column of NAs if the above conditions have been met.
      nRows <- 21 # All of these countries need 21 rows.
      df <- as.data.frame(matrix(NA, ncol = 1, nrow = nRows))
      colnames(df) <- "pred"
      return(df)
    }
  }
  model <- cobbDouglasModel(countryAbbrev, energyType)
  pred <- predict(model) #See http://stackoverflow.com/questions/9918807/how-get-plot-from-nls-in-r
  df <- data.frame(pred)
  # Pad with rows as necessary
  df <- padRows(countryAbbrev, df)
  return(df)
}
  
#########################
# Takes the Cobb-Douglas fitted models and creates a single column of predicted GDP values
# that corresponds, row for row, with the AllData.txt file.
##
cobbDouglasPredictionsColumn <- function(energyType){
  if (missing(energyType)){
    out <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasPredictions)) #rbinds all the predictions together
    colnames(out) <- c("predGDP")
  } else {
    out <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasPredictions, energyType=energyType))
    colnames(out) <- c(paste("predGDP", energyType, sep=""))
  }
  return(out)
}

#################################################
# Calculates parameter estimates and confidence intervals
# for the Cobb-Douglas production function given a country.
#
# countryAbbrev is a string containing the 2-letter abbreviation for the country, e.g. "US" or "CN"
# energyType is a string, one of "Q", "X", or "U"
#
# returns a data.frame of data for the Cobb-Douglas model. 
# First row is the +95% CI on all parameters
# Second row contains the parameter estimates
# Third row is the -95% CI on all parameters
# Each column has names: lambda, alpha, beta, gamma, corresponding to the parameters in the model.
##
cobbDouglasData <- function(countryAbbrev, energyType){
  #First, check to see if we want useful work (U) AND one of the countries for which we don't have data.
  if (!haveDataCD(countryAbbrev, energyType)){
    #Return a column of NAs if the above conditions have been met.
    nRows <- 3 # +95% CI, CDe, and -95% CI.
    nCols <- 4 # lambda, alpha, beta, and gamma
    df <- as.data.frame(matrix(NA, ncol = nCols, nrow = nRows))
    colnames(df) <- c("lambda", "alpha", "beta", "gamma")
    rownames(df) <- c("+95% CI", "CDe", "-95% CI")
    return(df)
  }
  # We have a combination of country and energy type for which we have data.
  modelCD <- cobbDouglasModel(countryAbbrev, energyType)
  summaryCD <- summary(modelCD) # Gives the nls summary table.
  ciCD <- confint(modelCD, level = ciLevel)  # Calculates confidence intervals for the CD model.
  dofCD <- summaryCD$df[2] # Gives the degrees of freedom for the model.
  tvalCD <- qt(ciHalfLevel, df = dofCD)
  if (missing(energyType)){
    #Cobb-Douglas without energy
    alpha <- as.numeric(coef(modelCD)["alpha"])
    beta <- 1.0 - alpha
    beta.est <- deltaMethod(modelCD, "1 - alpha") # Estimates beta and its standard error (SE).
    # Calculate beta and its confidence interval and report it.
    # Now calculate a confidence interval on beta
    betaCICD <- with(beta.est, Estimate + c(-1.0, 1.0) * tvalCD * SE); betaCICD # Gives the confidence interval on beta.  
    # Combine all estimates and their confidence intervals into data frames with intelligent row names
    estCD <- data.frame(lambda=coef(modelCD)["lambda"], alpha=coef(modelCD)["alpha"], beta=beta, gamma=0)
    row.names(estCD) <- "CD"
    # The [1] subscripts pick off the lower confidence interval
    lowerCD <- data.frame(lambda=ciCD["lambda","2.5%"], alpha=ciCD["alpha", "2.5%"], beta=betaCICD[1], gamma=NA) 
    row.names(lowerCD) <- "-95% CI"
    # The [2] subscripts pick off the lower confidence interval
    upperCD <- data.frame(lambda=ciCD["lambda","97.5%"], alpha=ciCD["alpha", "97.5%"], beta=betaCICD[2], gamma=NA)
    row.names(upperCD) <- "+95% CI"
  } else {
#     print("")
#     print(paste("In cobbDouglasData:", countryAbbrev, energyType))
#     print("summaryCD:")
#     print(paste("    df:", summaryCD$df))
#     print(paste("    sigma:", summaryCD$sigma))
#     print("    coeffs: ")
#     print(summaryCD$coefficients)
#     print("ciCD:")
#     print(ciCD)
    #Cobb-Douglas with energy
    a <- as.numeric(coef(modelCD)["a"])
    b <- as.numeric(coef(modelCD)["b"])
#     print(paste("a =", a))
#     print(paste("b =", b))
    lambda <- as.numeric(coef(modelCD)["lambda"])
    alpha <- a
    beta <- b - a
    gamma <- 1.0 - b
    # Report results with SE
    beta.est <- deltaMethod(modelCD, "b-a") # Reports results for beta, because beta = b - a.
#     print("beta.est = b-a")
#     print(beta.est)
    gamma.est <- deltaMethod(modelCD, "1-b") # Reports results for gamma, because gamma = 1 - b.
#     print("gamma.est = 1 - b")
#     print(gamma.est)
    # Now calculate confidence intervals.
#     print(paste("dofCD =", dofCD))
#     print(paste("tvalCD =", tvalCD))
    betaCICD <- with(beta.est, Estimate + c(-1.0, 1.0) * tvalCD * SE) # Gives the confidence interval on beta.
#     print("betaCICD:")
#     print(betaCICD)
    gammaCICD <- with(gamma.est, Estimate + c(-1.0, 1.0) * tvalCD * SE) # Gives the confidence interval on gamma.
#     print("gammaCICD:")
#     print(gammaCICD)
    # Combine all estimates and their confidence intervals into data frames with intelligent row names
    estCD <- data.frame(lambda = lambda, alpha = alpha, beta = beta, gamma = gamma)
    row.names(estCD) <- "CDe"
    # The [1] subscripts pick off the lower confidence interval
    lowerCD <- data.frame(lambda=ciCD["lambda","2.5%"], 
                          alpha=ciCD["a", "2.5%"], 
                          beta=betaCICD[1], 
                          gamma=gammaCICD[1])
    row.names(lowerCD) <- "-95% CI"
    # The [2] subscripts pick off the upper confidence interval
    upperCD <- data.frame(lambda=ciCD["lambda","97.5%"], 
                          alpha=ciCD["a", "97.5%"], 
                          beta=betaCICD[2], 
                          gamma=gammaCICD[2])
    row.names(upperCD) <- "+95% CI"
  }
  # Now create the data for a table and return it
  dataCD <- rbind(upperCD, estCD, lowerCD)
  return(dataCD)
}

############
# Creates a row for the Cobb Douglas parameters table for the given country (2-letter code) and energyType (Q, X, or U)
##
cobbDouglasCountryRow <- function(countryAbbrev, energyType){
  dataCD <- cobbDouglasData(countryAbbrev, energyType)
  if (missing(energyType)){
    out <- cbind(dataCD["-95% CI", "lambda"], dataCD["CD", "lambda"], dataCD["+95% CI", "lambda"],
                 dataCD["-95% CI", "alpha"],  dataCD["CD", "alpha"],  dataCD["+95% CI", "alpha"],
                 dataCD["-95% CI", "beta"],   dataCD["CD", "beta"],   dataCD["+95% CI", "beta"])
  } else {
    out <- cbind(dataCD["-95% CI", "lambda"], dataCD["CDe", "lambda"], dataCD["+95% CI", "lambda"],
                 dataCD["-95% CI", "alpha"],  dataCD["CDe", "alpha"],  dataCD["+95% CI", "alpha"],
                 dataCD["-95% CI", "beta"],   dataCD["CDe", "beta"],   dataCD["+95% CI", "beta"],
                 dataCD["-95% CI", "gamma"],  dataCD["CDe", "gamma"],  dataCD["+95% CI", "gamma"])
  }
  return(out)
}

###########################################
# Creates a number of rows in a data.frame that contain information 
# about the coefficients of a Cobb-Douglas model for countryName.
# Each parameter has its own row with confidence intervals.
# The country name is in a column. Which parameter is involved is
# also in a column.
# 
# The return type is a data.frame.
##
cobbDouglasCountryRowsForParamsGraph <- function(countryName, energyType){
  #Create three rows, one for each parameter. Each row is a data.frame so that it is plottable!
  if (missing(energyType)){
    valueRow <- "CD"
    dataCD <- cobbDouglasData(countryName)
  } else {
    valueRow <- "CDe"
    dataCD <- cobbDouglasData(countryName, energyType)
  }
  # These rows are common to the "with" and "without" energy cases.
  lambdaRow <- data.frame(country = countryName, 
                          parameter = "lambda", 
                          lowerCI = dataCD["-95% CI", "lambda"], 
                          value = dataCD[valueRow, "lambda"], 
                          upperCI = dataCD["+95% CI", "lambda"])
  alphaRow <- data.frame(country = countryName, 
                         parameter = "alpha",
                         lowerCI = dataCD["-95% CI", "alpha"],
                         value = dataCD[valueRow, "alpha"],  
                         upperCI = dataCD["+95% CI", "alpha"])
  betaRow <- data.frame(country = countryName, 
                        parameter = "beta",
                        lowerCI = dataCD["-95% CI", "beta"],
                        value = dataCD[valueRow, "beta"], 
                        upperCI = dataCD["+95% CI", "beta"])
  if (missing(energyType)){
    table <- rbind(lambdaRow, alphaRow, betaRow)
  } else {
#     print("In not missing energyType")
#     print(dataCD)
    gammaRow <- data.frame(country = countryName, 
                           parameter = "gamma",
                           lowerCI = dataCD["-95% CI", "gamma"],
                           value = dataCD[valueRow, "gamma"], 
                           upperCI = dataCD["+95% CI", "gamma"])
#     print(gammaRow)
    table <- rbind(lambdaRow, alphaRow, betaRow, gammaRow)
  }
  return(table)
}

############################
# Aggregates the Cobb-Douglas results into a big data table. No energy.
##
cobbDouglasParamsTableNoEnergy <- function(){
  #Do rbind on the results of creating a row in the table for every country abbreviation that we know.
  dataCD <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasCountryRow))
  colnames(dataCD) <- c(" ", "$\\lambda$", " ", 
                        " ", "$\\alpha$",  " ",
                        " ", "$\\beta$",   " ")
  rownames(dataCD) <- countryAbbrevs
  tableCD <- xtable(dataCD, 
                    caption="Cobb-Douglas model (without energy) parameters for 1980-2011 (US, UK, JP), 1991-2010 (CN and ZA), and 1991-2011 (SA, IR, TZ, and ZM). (Parameter estimates beneath symbol. 95\\% confidence interval bounds to left and right.)", 
                    label="tab:CD_Parameters_No_Energy",
                    digits = c(1, 4,4,4, 2,2,2, 2,2,2),
                    align = "r|ccc|ccc|ccc") #Sets alignment of the numbers in the columns
  return(tableCD)
}

############################
# Aggregates the Cobb-Douglas results into a big data table for the given energyType.
##
cobbDouglasParamsTableWithEnergy <- function(energyType){
  #Do rbind on the results of creating a row in the table for every country abbreviation that we know.
  dataCD <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasCountryRow, energyType=energyType))
  colnames(dataCD) <- c(" ", "$\\lambda$", " ", 
                        " ", "$\\alpha$",  " ",
                        " ", "$\\beta$",   " ",
                        " ", "$\\gamma$",  " ")
  rownames(dataCD) <- countryAbbrevs
  tableCD <- xtable(dataCD, 
                    caption=paste("Cobb-Douglas model (with $", tolower(energyType), "$) parameters for 1980-2011 (US, UK, JP), 1991-2010 (CN and ZA), and 1991-2011 (SA, IR, TZ, and ZM). (Parameter estimates beneath symbol. 95\\% confidence interval bounds to left and right.)", sep=""), 
                    label=paste("tab:CD_Parameters_With_", energyType, sep=""),
                    digits = c(1, 4,4,4, 2,2,2, 2,2,2, 2,2,2),
                    align = "r|ccc|ccc|ccc|ccc") #Sets alignment of the numbers in the columns
  return(tableCD)
}

############################
# Prints a table with parameters from a Cobb-Douglas model for the given energyType. 
# Leave energyType blank to print a table for Cobb-Douglas without energy.
##
printCDParamsTable <- function(energyType){
  if (missing(energyType)){
    print(cobbDouglasParamsTableNoEnergy(), 
        caption.placement="top", 
        sanitize.colnames.function = identity, 
        size="\\tiny", 
        table.placement="H")
  } else {
    print(cobbDouglasParamsTableWithEnergy(energyType), 
      caption.placement="top", 
      sanitize.colnames.function = identity, 
      size="\\tiny",
      table.placement="H")
  }
}

#############################
# Creates a graph with confidence intervals for the Cobb-Douglas model for the given energyType
##
createCDParamsGraph <- function(energyType){
  
  if (missing(energyType)){
    # Create a data table with the following columns:
    # country abbrev, parameter (lambda, alpha, or beta), -95% CI, value, +95% CI
    dataTable <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasCountryRowsForParamsGraph))
    graph <- segplot(country ~ upperCI + lowerCI | parameter, 
                     data = dataTable, 
                     centers = value, #identifies where the dots should be placed
                     draw.bands = FALSE, #provides nicer error bars
                     horizontal = FALSE, #makes error bars vertical and puts the countries in the x axis
                     layout = c(2,2), #2 column, 2 row
                     index.cond = list(c(2,3,1)), #orders the panels as alpha, beta, lambda, gamma
                     strip = strip.custom(factor.levels=c("$\\lambda$", "$\\alpha$", "$\\beta$"), #sets labels in strip 
                                          bg="white"), #sets background color in strip
                     col = "black", #Sets line color to black
                     lwd = 1, #Sets line width to 1.0
                     ylim = list(c(-0.05, 0.1), c(-0.5, 1.5), c(-0.5, 1.5)), #y axis limits
                     scales = list(cex=scaleTextSize, #controls text size on scales.
                                   tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                                   x=list(cex=0.75), #reduces text size so that country abbrevs are legible
                                   y=list(relation="free", #allow each axis to be different
                                          at=list(c(0.0, 0.05, 0.1),   #y tick mark for lambda
                                                  c(0.0, 0.5, 1.0), 
                                                  c(0.0, 0.5, 1.0)
                                                  )
                                          )
                                   )
                     )
   } else {
    # Create a data table with the following columns:
    # country abbrev, parameter (lambda, alpha, or beta), -95% CI, value, +95% CI
    dataTable <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasCountryRowsForParamsGraph, energyType=energyType))
    graph <- segplot(country ~ upperCI + lowerCI | parameter, 
                     data = dataTable, 
                     centers = value, #identifies where the dots should be placed
                     draw.bands = FALSE, #provides nicer error bars
                     horizontal = FALSE, #makes error bars vertical and puts the countries in the x axis
                     layout = c(2,2), #2 column, 2 row
                     index.cond = list(c(2,3,1,4)), #orders the panels as alpha, beta, lambda, gamma
                     #set labels and bg color in strip
                     strip = strip.custom(factor.levels=c("$\\lambda$", "$\\alpha$", "$\\beta$", "$\\gamma$"),  
                                          bg="white"),
                     col = "black", #Sets line color to black
                     lwd = 1, #Sets line width to 1.0
                     ylim = list(c(-0.05, 0.1), c(-0.5, 1.5), c(-0.5, 1.5), c(-0.5, 1.5)), #y axis limits
                     scales = list(cex=scaleTextSize, #controls text size on scales.
                                   tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                                   x=list(cex=0.75), #reduces text size so that country abbrevs are legible
                                   y=list(relation="free", #allow each axis to be different
                                          at=list(c(0.0, 0.05, 0.1),   #y tick mark for lambda
                                                  c(0.0, 0.5, 1.0), 
                                                  c(0.0, 0.5, 1.0),
                                                  c(0.0, 0.5, 1.0)
                                                  )
                                          )
                                   )
                     )
   }
   return(graph)
}

##############################
# Creates a graph that plots predicted GDP as lines and GDP data as open circles.
##
createCDLatticeGraph <- function(){
  dataTable <- loadData("All") #Grab the raw data
  predictions <- cobbDouglasPredictionsColumn()     #Predictions from CD without energy
  predictionsQ <- cobbDouglasPredictionsColumn("Q") #Predictions from CD with Q
  predictionsX <- cobbDouglasPredictionsColumn("X") #Predictions from CD with X
  predictionsU <- cobbDouglasPredictionsColumn("U") #Predictions from CD with U
  #Now add the predictions columns to the data.
  dataTable <- cbind(dataTable, predictions, predictionsQ, predictionsX, predictionsU) 
  graphType <- "b" #b is for both line and symbol
  lineTypes <- c(0, 1, 2, 4, 1) #line types. See http://en.wikibooks.org/wiki/R_Programming/Graphics
  lineWidths <- c(0, 2, 1, 1, 1) #line widths. 0 means no line.
  colors <- c("black", "black", "red", "blue", "darkorange") #line and symbol colors
  symbols <- c(1, NA, NA, NA, NA)  #NA gives no symbol.
  graph <- xyplot(iGDP+predGDP+predGDPQ+predGDPX+predGDPU ~ Year | Country, data=dataTable,
                  type=graphType,
                  index.cond=list(countryOrderForGraphs), #orders the panels.
                  layout=ninePanelLayoutSpec, #indicates a 3x3 arrangement of panels.
                  strip = strip.custom(factor.levels=countryNamesAlph, bg="white"), #Sets strip parameters
                  as.table=TRUE, #indexing of panels starts in upper left and goes across rows.
                  lty = lineTypes, lwd = lineWidths, col = colors, #Controls line parameters
                  pch = symbols, col.symbol = colors, #Controls symbol parameters
                  key=list(text=list(c("Actual", "No energy", "With $q$", "With $x$", "With $u$")),
                           type=graphType,
                           cex=keyTextSize, #controls size of text in the key
                           lines=list(lty=lineTypes, lwd=lineWidths), #controls line types
                           pch=symbols, col=colors, #controls symbol (plot characters) types
                           columns=keyColumns, x=keyXLoc, y=keyYLoc), #controls columns and position of the key
                  scales=list(cex=scaleTextSize, #controls text size on scales.
                              tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                              y=list(relation="free", #allows each axis to be different
                                     at=c(1,2,3,4,5,6,7,8,9,10) #tick mark locations
                                     )
                              ), 
                  ylim=list(c(1,8), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3)),
                  xlab="", ylab="Indexed GDP (1980=1 or 1991=1)") #axis labels
  return(graph)
}

@

The Cobb-Douglas model without energy is given by

\begin{equation} \label{eq:CD_No_Energy}
  y = \mathrm{e}^{\lambda (t-t_0)}k^{\alpha}l^{\beta}.
\end{equation}

Figure \ref{fig:CD_Params_Graph} shows values and 95\% confidence intervals for the parameters for the Cobb-Douglas model (without energy).

<<CD_Params_Graph, fig.width=cdParameterGraphWidth, fig.height=cdParameterGraphHeight, fig.pos="H", fig.cap="Cobb-Douglas (without energy) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createCDParamsGraph()
@

\section{Cobb-Douglas Models With Energy (CDe)}

We can force $\alpha$, $\beta$, and $\gamma$ to be in $[0,1]$ by a reparameterization:

$a \in[0,1], b \in [0,1], \alpha=\min(a,b), \beta=|b-a|, \gamma = 1-\max(a,b)$

The Cobb-Douglas model with energy is given by

\begin{equation} \label{eq:CD_With_Energy}
  y = \mathrm{e}^{\lambda (t-t_0)}k^{\alpha}l^{\beta}e^{\gamma},
\end{equation}

\noindent where $e$ can be any of thermal energy ($q$), exergy ($x$), or useful work ($u$).

\subsection{Cobb-Douglas with thermal energy ($q$)}

Figure \ref{fig:CDq_Params_Graph} shows values and 95\% confidence intervals for the parameters for the Cobb-Douglas model (with $q$).

<<CDq_Params_Graph, fig.width=cdParameterGraphWidth, fig.height=cdParameterGraphHeight, fig.pos="H", fig.cap="Cobb-Douglas (with $q$) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createCDParamsGraph("Q")
@

\subsection{Cobb-Douglas with exergy ($x$)}

The Cobb-Douglas (with exergy) parameters are given in Table \ref{tab:CD_Parameters_With_X}.

Figure \ref{fig:CDx_Params_Graph} shows values and 95\% confidence intervals for the parameters for the Cobb-Douglas model (with $x$).

<<CDx_Params_Graph, fig.width=cdParameterGraphWidth, fig.height=cdParameterGraphHeight, fig.pos="H", fig.cap="Cobb-Douglas (with $x$) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createCDParamsGraph("X")
@

\subsection{Cobb-Douglas with useful work ($u$)}

Figure \ref{fig:CDu_Params_Graph} shows values and 95\% confidence intervals for the parameters for the Cobb-Douglas model (with $u$).

<<CDu_Params_Graph, fig.width=cdParameterGraphWidth, fig.height=cdParameterGraphHeight, fig.pos="H", fig.cap="Cobb-Douglas (with $u$) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createCDParamsGraph("U")
@

\subsection{Cobb-Douglas Comparisons}

Figure \ref{fig:CD_GDP_Lattice_Graph} compares predictions from the Cobb-Douglas models (without energy, with $q$, with $x$, and with $u$) to historical data.

<<CD_GDP_Lattice_Graph, fig.width=cdParameterGraphWidth, fig.height=ninePanelGraphHeight, fig.pos="H", fig.cap="Cobb-Douglas results.">>=
createCDLatticeGraph()
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{CES Models}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<ces functions, eval=TRUE>>=
# Set some common names for CES variables.
xNames = c("iCapStk", "iLabor", "iEToFit")
tName = "iYear"
yName = "iGDP"

######################################
# Loads data and trims rows where necessary.
# Also, replaces the name of the desired energy column with "iEToFit".
# Returns a data.frame with the loaded data.
##
loadAndPrepDataForCES <- function(countryAbbrev, energyType){
  dataTable <- loadData(countryAbbrev)
  if (energyType == "U"){
    # Trim the dataset to include only those years for which U is available.
    dataTable <- subset(dataTable, !is.na(iU))
  }
  # Trim data from China and South Africa that is missing labor information for 2011.
  dataTable <- subset(dataTable, !is.na(iLabor))
  # We need to do the CES fit with the desired energyType.
  # To achieve the correct fit, we'll change the name of the desired column
  # to "iEToFit" and use "iEToFit" in the nls function.
  dataTable <- replaceColName(dataTable, energyType, "iEToFit")
  return(dataTable)
}

####################
# Returns an nls ces model for the country and energyType specified.
# energyType should be one of Q", "X", or "U".
##
cesModel <- function(countryAbbrev, energyType){
  # Load the data that we need.
  dataTable <- loadAndPrepDataForCES(countryAbbrev, energyType)
  control=nls.lm.control(maxiter=1000, maxfev=2000)
  if (countryAbbrev == "US") {
    # With Q, The unconstrained optimization leads to rho1 = -0.72 and sigma1 = 3.57, which is not 
    # economically meaningful.  So, a grid search was performed, and it confirmed that low values of 
    # rho1 yield a better fit. In fact, the lower the value of rho1, the better. So, we'll set it 
    # here at rho1=0.0, which makes the elasticity of substitution between k and l sigma1 = 1.0, 
    # giving the Cobb-Douglas form for the k l portion of the CES function. Similar results are found
    # for X and U.
    rho1 = 0.0
    # Unconstrained optimization leads to rho = 25.7 and sigma = 0.0374, indicating that (kl) and (e) are 
    # complimentary.  We'll let the estCES function solve for the best value.
    modelCES <- cesEst(data=dataTable, yName=yName, xNames=xNames, tName=tName, control=control,
                       method="LM",
                       rho1=rho1
                       )
  } else if (countryAbbrev == "UK") {
    # The unconstrained optimization leads to rho1 = -2.4 and sigma1 = -0.71, which is not economically meaningful.
    # So, a grid search was performed, and it confirmed that low values of rho1 yield a better fit. In fact, the 
    # lower the value of rho1, the better. So, we'll set it here at rho1=0.0, which makes the elasticity of 
    # substitution between k and l sigma1 = 1.0, giving the Cobb-Douglas form for the k l portion of the CES function.
    # rho1 = c(0.00, 0.01, 0.02)
    rho1 = 0.0
    modelCES <- cesEst(data=dataTable, yName=yName, xNames=xNames, tName=tName, control=control,
                       method="LM",
                       rho1=rho1
                       )
  } else if (countryAbbrev == "JP") {
    # The unconstrained optimization leads to rho1 = 7.99 and sigma1 = 0.11, indicating complementarity between k & l,
    # but different from the results for the US and UK (where k & l were found to be substitutes).  However, the
    # p value for rho1 is very high (0.3), indicating that rho1 is not making a significant contribution to the model. 
    # The unconstrained fit gives R^ = 0.996 and sigma = 0.103, indicating complementarity between (kl) and (e).
    # 
    # In fact, we could force rho1 = 0.0 and achieve rho = 280 and sigma = 0.00356 with R^2 = 0.988, a very small
    # decrease, indeed.  Note that both the constrained and unconstrained fits give small sigma, indicating
    # that (kl) and (e) are complimentary.
    modelCES <- cesEst(data=dataTable, yName=yName, xNames=xNames, tName=tName, control=control,
                       method="LM"
                       )
  } else if (countryAbbrev == "CN"){
    # Unconstrained optimization: rho1 < -0.2290, rho = 14.1651, R^2 = 0.9984. This corresponds to sigma1 = 1.297
    # and sigma = 0.0659, indicating that (kl) and (e) are complements and k & l are substitutes.  However, none of the
    # rho or sigma values are statistically significant.
    # Now, sigma1 > 1 is not economically meaningful, so we'll set rho1 = 0 to force sigma1 = 1.0. When we do that, 
    # we obtain sigma1 = 1.0 (so perfect substitution between k and l) and sigma = 7.19 (again, not economically
    # meaningful) with R^2 = 0.9983.  Again, none of the rho or sigma values are statistically significant.
    # Furthermore, the only significant varluable is gamma = 1.0731.
    # So, for the final fit, I'll put rho1 = 0.0 and rho = 0.0. The final R^2 = 0.9983.
    rho1 = 0.0
    rho = 0.0
    modelCES <- cesEst(data=dataTable, yName=yName, xNames=xNames, tName=tName, control=control,
                       method="LM",
                       rho1=rho1,
                       rho=rho                     
                       )
  } else if (countryAbbrev == "ZA"){
    # An unconstrained fit works for South Africa.  Results are sigma1 = 0.05, signalling complementarity
    # between k and l.  sigma = 0.03, indicating complementatity between (kl) and (e).
    modelCES <- cesEst(data=dataTable, yName=yName, xNames=xNames, tName=tName, control=control,
                       method="LM",
                       )
  } else if (countryAbbrev == "SA"){
    # An unconstrained fit gives rho = -6.33, rho1 = 9.36 (sigma1 = 0.0965) and R^2 = 0.9892.  
    # This result is not economically meaningful.
    # Constraining rho = 0 gives rho1 = -582, again not economically meaningful.
    # So, do a grid search over meaningful regions to see what is best.
    # The result (to with +/- 0.1) is rho = 0.0 and rho1 = 5.7, with R^2 = 0.9885.
    # However, neither the the rho or nor the sigma values are statistically significant.
    rho1 = 5.7
    rho = 0.0
    modelCES <- cesEst(data=dataTable, yName=yName, xNames=xNames, tName=tName, control=control,
                       method="LM",
                       rho1 = rho1,
                       rho = rho
                       )
  } else if (countryAbbrev == "IR"){
    # Iran works with an unconstrained fit.
    modelCES <- cesEst(data=dataTable, yName=yName, xNames=xNames, tName=tName, control=control,
                       method="LM",
                       )
  } else if (countryAbbrev == "TZ"){
    # Using the PORT algorithm yields convergence and R^2 = 0.9974 with economically menaingful results.
    # However, none of the rho or sigma values are statistically significant.
    modelCES <- cesEst(data=dataTable, yName=yName, xNames=xNames, tName=tName, control=control,
                       method="PORT",
                       )
  } else if (countryAbbrev == "ZM"){
    # ZM works with the PORT algorithm, but not the LM algorithm.
    modelCES <- cesEst(data=dataTable, yName=yName, xNames=xNames, tName=tName, control=control,
                       method="PORT",
                       rho=0.0
                       )
  }
  return(modelCES)
}

#########################
# Takes the CES fitted models and creates per-country predictions for them.
# Returns a data.frame with the predictions.
##
cesPredictions <- function(countryAbbrev, energyType){
  dataTable <- loadAndPrepDataForCES(countryAbbrev, energyType)
  # Can't make predictions for any of CN, ZA, SA, IR, TZ, or ZM if we're interested in U
  if (!(haveDataSF(countryAbbrev, energyType))){
    # If we don't have data for this combination of countryAbbrev and energyType, 
    # return a column of NAs if the above conditions have been met.
    nRows <- 21 # All of these countries need 21 rows.
    df <- as.data.frame(matrix(NA, ncol = 1, nrow = nRows))
    colnames(df) <- "pred"
    return(df)
  }
  model <- cesModel(countryAbbrev, energyType)
  pred <- cesCalc(xNames=xNames, data=dataTable, coef=coef(model), tName="iYear", nested=TRUE)
  df <- data.frame(pred)
  # Pad with rows as necessary
  df <- padRows(countryAbbrev, df)
  return(df)
}

#########################
# Takes the CES fitted models and creates a single column of predicted GDP values
# that corresponds, row for row, with the AllData.txt file.
##
cesPredictionsColumn <- function(energyType){
  out <- do.call("rbind", lapply(countryAbbrevs, cesPredictions, energyType=energyType))
  colnames(out) <- c(paste("predGDP", energyType, sep=""))
  return(out)
}

##############################
# Creates a graph that plots predicted GDP as lines, one for each single factor, and historical GDP 
# data as open circles.
##
createCESLatticeGraph <- function(){
  dataTable <- loadData("All") #Grab the raw data
  predictionsQ <- cesPredictionsColumn("Q") #Predictions from CES with Q
  predictionsX <- cesPredictionsColumn("X") #Predictions from CES with X
  predictionsU <- cesPredictionsColumn("U") #Predictions from CES with U
  #Now add the predictions columns to the data.
  dataTable <- cbind(dataTable, predictionsQ, predictionsX, predictionsU) 
  graphType <- "b" #b is for both line and symbol
  lineTypes <- c(0, 2, 4, 1) #line types. See http://en.wikibooks.org/wiki/R_Programming/Graphics
  lineWidths <- c(0, 1, 1, 1) #line widths. 0 means no line.
  colors <- c("black", "red", "blue", "darkorange") #line and symbol colors
  symbols <- c(1, NA, NA, NA)  #NA gives no symbol.
  graph <- xyplot(iGDP+predGDPQ+predGDPX+predGDPU ~ Year | Country, data=dataTable,
                  type=graphType,
                  index.cond=list(countryOrderForGraphs), #orders the panels.
                  layout=ninePanelLayoutSpec, #indicates a 3x3 arrangement of panels.
                  strip = strip.custom(factor.levels=countryNamesAlph, bg="white"), #Sets strip parameters
                  as.table=TRUE, #indexing of panels starts in upper left and goes across rows.
                  lty = lineTypes, lwd = lineWidths, col = colors, #Controls line parameters
                  pch = symbols, col.symbol = colors, #Controls symbol parameters
                  key=list(text=list(c("Actual", "With $q$", "With $x$", "With $u$")),
                           type=graphType,
                           cex=keyTextSize, #controls size of text in the key
                           lines=list(lty=lineTypes, lwd=lineWidths), #controls line types
                           pch=symbols, col=colors, #controls symbol (plot characters) types
                           columns=keyColumns, x=keyXLoc, y=keyYLoc), #controls columns and position of the key
                  scales=list(cex=scaleTextSize, #controls text size on scales.
                              tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                              y=list(relation="free", #allows each axis to be different
                                     at=c(1,2,3,4,5,6,7,8,9,10) #tick mark locations
                                     )
                              ), 
                  ylim=list(c(1,8), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3)),
                  xlab="", ylab="Indexed GDP (1980=1 or 1991=1)") #axis labels
  return(graph)
}


cesData <- function(countryName, energyType){
  energyColumnName <- paste("i", energyType, sep="")
  # Load the data that we need.
  dataTable <- loadData(countryName)
    
  # Establish guess values for phi beta, zeta, lambda_L and lambda_E.
  phiGuess <- -20
  betaGuess <- 0.5 # a typical value for beta (exponent on labor)
  zetaGuess <- 0.0004 # a small value
  lambda_LGuess <- 0.007 #assuming no technical progress on the labor-capital portion of the function
  lambda_EGuess <- 0.008 #assuming no technical progress on the energy portion of the function
  
  # Runs a non-linear least squares fit to the data with constraints
  modelCES <- nls(iGDP ~ ((1-zeta) * (exp(lambda_L*iYear) * iCapStk^(1-beta) * iLabor^beta)^phi 
                           + zeta*(exp(lambda_E*iYear) * iQ)^phi)^(1/phi), 
                   algorithm = "port",
                   control = nls.control(maxiter = 500, tol = 1e-06, minFactor = 1/1024, 
                                         printEval = FALSE, warnOnly = FALSE),
                   start = list(phi=phiGuess, beta=betaGuess, zeta=zetaGuess, lambda_L=lambda_LGuess, 
                                lambda_E=lambda_EGuess),
                   lower = list(phi=-Inf, beta=0, zeta=0, lambda_L=-Inf, lambda_E=-Inf),
                   upper = list(phi=0, beta=1, zeta=1, lambda_L=Inf, lambda_E=Inf),
                   data=dataTable)

  aicCES <- AIC(modelCES, k=2) # Checks validity of the model. AIC stands for Akaike's Information Criterion
  print(aicCES)

  # Gives the nls summary table
  summaryCES <- summary(modelCES) # Gives the nls summary table
  print(summaryCES)
  
  # Provides confidence intervals on phi, beta, zeta, lambda_L, and lambda_E. But, we need the CI on alpha.
  ciCES <- confint(modelCES, level = ciLevel)
  print(ciCES)
  
  # Get the estimate for alpha
  beta <- as.numeric(coef(modelCES)["beta"])
  alpha <- 1.0 - beta
  alpha.est <- deltaMethod(modelCES, "1 - beta") # Estimates alpha and its standard error (SE).
  print(alpha.est) 
  
  # Now calculate a confidence interval on alpha
  dofCES <- summaryCES$df[2]
  print(dofCES) # Gives the degrees of freedom for the model.
  tvalCES <- qt(ciHalfLevel, df = dofCES); tvalCES
  # Get confidence intervals for each parameter in the model
  alphaCICES <- with(alpha.est, Estimate + c(-1.0, 1.0) * tvalCES * SE) # CI on alpha.
  print(alphaCICES) 

  # Assemble the data into data frames for the table.
  estCES <- data.frame(phi = coef(modelCES)["phi"], alpha = alpha, 
                       beta = coef(modelCES)["beta"], zeta = coef(modelCES)["zeta"], 
                       lambda_L = coef(modelCES)["lambda_L"], lambda_E = coef(modelCES)["lambda_E"])
  row.names(estCES) <- paste("CES with ", energyType, sep="")
  #print(estCES)  
  # The [1] subscripts pick off the lower confidence interval
  lowerCES <- data.frame(phi = ciCES["phi","2.5%"], alpha = alphaCICES[1], 
                         beta = ciCES["beta", "2.5%"], zeta = ciCES["zeta", "2.5%"],
                         lambda_L = ciCES["lambda_L", "2.5%"], lambda_E = ciCES["lambda_E", "2.5%"])
  row.names(lowerCES) <- "- 95% CI"
  # The [2] subscripts pick off the lower confidence interval
  upperCES <- data.frame(phi = ciCES["phi","97.5%"], alpha = alphaCICES[2], 
                         beta = ciCES["beta", "97.5%"], zeta = ciCES["zeta", "97.5%"],
                         lambda_L = ciCES["lambda_L", "97.5%"], lambda_E = ciCES["lambda_E", "97.5%"])
  row.names(upperCES) <- "+ 95% CI"
  
  # Now create the data for a table.
  dataCES <- rbind(upperCES, estCES, lowerCES)
  return(dataCES)
}

####################################
# Creates a LaTeX printable table from the CES data. This function first calls cesData.
#
# countryName is a string containint the 2-letter abbreviation for the country, e.g. "US" or "CN"
# energyType is a string to be used in table captions reprsenting the type of energy. Typically, "Q", "X", or "U"
#
# returns a printable LaTeX table from xtable.
##
cesTable <- function(countryName, energyType){
  dataCESe <- cesData(countryName, energyType)
  tableCESq <- xtable(dataCESe, caption=paste(countryName, ", 1980-2011.", sep=""), digit = c(4, 1, 2, 2, 6, 5, 5))
}
@

\citet{Stern:2012ey} developed a CES model of the form\footnote{The CES equation in \citet{Stern:2012ey} appears as

\begin{equation*} \label{eq:Stern_CES_model}
  y = \left\{ (1-\gamma_E)^{1/\sigma} \left[ k^{\alpha} \left( \mathrm{e}^{\lambda_L(t-t_0)} l \right)^{\beta} \right]^{\frac{\sigma-1}{\sigma}}   
      + (\gamma_E)^{1/\sigma} \left[ \mathrm{e}^{\lambda_E(t-t_0)} e \right]^{\frac{\sigma - 1}{\sigma}}   \right\}
      ^{\frac{\sigma}{\sigma - 1}},
\end{equation*}

but the $1/\sigma$ exponent on the $(1-\gamma_E)$ and $\gamma_E$ terms is erroneous due to $y_{\mathrm{t_0}} \neq 1$.} 


\begin{equation} \label{eq:Stern_CES_model_in_print}
  y = \left\{ (1-\gamma_E) \left[ k^{\alpha} \left( \mathrm{e}^{\lambda_L(t-t_0)} l \right)^{\beta} \right]^{\frac{\sigma-1}{\sigma}}   
      + (\gamma_E) \left[ \mathrm{e}^{\lambda_E(t-t_0)} e \right]^{\frac{\sigma - 1}{\sigma}}   \right\}
      ^{\frac{\sigma}{\sigma - 1}},
\end{equation}

\noindent where $e$ is any of $q$, $x$, or $u$; $\sigma$, $\gamma_E$, $\beta$, $\lambda_L$, and $\lambda_E$ are fitting parameters; $\mathrm{e}$ is the base of the natural logarithm; and the sum $\alpha + \beta$ is constrained to unity.

The R package micEconCES (***** Need reference here *****) estimates CES production functions of the form

\begin{equation} \label{eq:micEconCES_model}
  y = something.
\end{equation}


\citet{Henningsen:2011td}, in their detailed analysis of \citet{Kemfert:1998vd}, found that 

\begin{quote}
\ldots the Levenberg-Marquardt and the PORT algorithms are--at least in this study--most likely to find the coefficients that give the best fit to the model, where the PORT algorithm can be used to restrict the estimates to the economically meaningful region.
\end{quote}

\subsection{CES with $Q$}

\subsection{CES with $X$}

\subsection{CES with $U$}

\subsection{CES comparisons}

Figure \ref{fig:CES_GDP_Lattice_Graph} compares CES model predictions to historical data.

<<CES_GDP_Lattice_Graph, fig.width=ninePanelGraphWidth, fig.height=ninePanelGraphHeight, fig.pos="H", fig.cap="CES results.", eval=TRUE>>=
createCESLatticeGraph()
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{LINEX Models}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<LINEX functions, eval=TRUE>>=
####################
# Returns an nls linex model for the country and energyType specified.
# energyType should be one of Q", "X", or "U".
##
linexModel <- function(countryAbbrev, energyType){
  # Load the data that we need.
  dataTable <- loadData(countryAbbrev)
  # We need to do the CES fit with the desired energyType.
  # To achieve the correct fit, we'll change the name of the desired column
  # to "iEToFit" and use "iEToFit" in the nls function.
  dataTable <- replaceColName(dataTable, energyType, "iEToFit")
  a_0Guess <- 0.5
  c_tGuess <- 1.0
  if (countryAbbrev == "SA"){
    # Need adjusted guess values, becasue k and l are above GDP for SA.
    a_0Guess <- -1
    c_tGuess <- -6

  }
  # Runs a non-linear least squares fit to the data with constraints
  modelLINEX <- nls(iGDP ~ iEToFit * exp(a_0*(2.0 - (iLabor+iEToFit)/iCapStk) + a_0 * c_t *(iLabor/iEToFit - 1.0)), 
                  data=dataTable,
                  start=list(a_0=a_0Guess, c_t=c_tGuess),
                  control=nls.control(maxiter=50, tol=1e-06, minFactor=1/1024, printEval=FALSE, warnOnly=TRUE),
#                   algorithm = "port",
#                   lower = list(a_0=-INF, c_t=-INF),
#                   upper = list(a_0= INF, c_t= INF)
                  )
  return(modelLINEX)
}

#########################
# Takes the LINEX fitted models and creates per-country predictions for them.
# Returns a data.frame with the predictions.
##
linexPredictions <- function(countryAbbrev, energyType){
  # Can't make predictions for any of CN, ZA, SA, IR, TZ, or ZM if we're interested in U
  if (!(haveDataSF(countryAbbrev, energyType))){
    # If we don't have data for this combination of countryAbbrev and energyType, 
    # return a column of NAs if the above conditions have been met.
    nRows <- 21 # All of these countries need 21 rows.
    df <- as.data.frame(matrix(NA, ncol = 1, nrow = nRows))
    colnames(df) <- "pred"
    return(df)
  }
  model <- linexModel(countryAbbrev, energyType)
  pred <- predict(model) #See http://stackoverflow.com/questions/9918807/how-get-plot-from-nls-in-r
  df <- data.frame(pred)
  # Pad with rows as necessary
  df <- padRows(countryAbbrev, df)
  return(df)
}

#########################
# Takes the LINEX fitted models and creates a single column of predicted GDP values
# that corresponds, row for row, with the AllData.txt file.
##
linexPredictionsColumn <- function(energyType){
  out <- do.call("rbind", lapply(countryAbbrevs, linexPredictions, energyType=energyType))
  colnames(out) <- c(paste("predGDP", energyType, sep=""))
  return(out)
}

##############################
# Creates a graph that plots predicted GDP as lines, one for each single factor, and historical GDP 
# data as open circles.
##
createLinexLatticeGraph <- function(){
  dataTable <- loadData("All") #Grab the raw data
  predictionsQ <- linexPredictionsColumn("Q") #Predictions from LINEX with Q
  predictionsX <- linexPredictionsColumn("X") #Predictions from LINEX with X
  predictionsU <- linexPredictionsColumn("U") #Predictions from LINEX with U
  #Now add the predictions columns to the data.
  dataTable <- cbind(dataTable, predictionsQ, predictionsX, predictionsU) 
  graphType <- "b" #b is for both line and symbol
  lineTypes <- c(0, 2, 4, 1) #line types. See http://en.wikibooks.org/wiki/R_Programming/Graphics
  lineWidths <- c(0, 1, 1, 1) #line widths. 0 means no line.
  colors <- c("black", "red", "blue", "darkorange") #line and symbol colors
  symbols <- c(1, NA, NA, NA)  #NA gives no symbol.
  graph <- xyplot(iGDP+predGDPQ+predGDPX+predGDPU ~ Year | Country, data=dataTable,
                  type=graphType,
                  index.cond=list(countryOrderForGraphs), #orders the panels.
                  layout=ninePanelLayoutSpec, #indicates a 3x3 arrangement of panels.
                  strip = strip.custom(factor.levels=countryNamesAlph, bg="white"), #Sets strip parameters
                  as.table=TRUE, #indexing of panels starts in upper left and goes across rows.
                  lty = lineTypes, lwd = lineWidths, col = colors, #Controls line parameters
                  pch = symbols, col.symbol = colors, #Controls symbol parameters
                  key=list(text=list(c("Actual", "With $q$", "With $x$", "With $u$")),
                           type=graphType,
                           cex=keyTextSize, #controls size of text in the key
                           lines=list(lty=lineTypes, lwd=lineWidths), #controls line types
                           pch=symbols, col=colors, #controls symbol (plot characters) types
                           columns=keyColumns, x=keyXLoc, y=keyYLoc), #controls columns and position of the key
                  scales=list(cex=scaleTextSize, #controls text size on scales.
                              tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                              y=list(relation="free", #allows each axis to be different
                                     at=c(1,2,3,4,5,6,7,8,9,10) #tick mark locations
                                     )
                              ), 
                  ylim=list(c(1,8), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3), c(1,3)),
                  xlab="", ylab="Indexed GDP (1980=1 or 1991=1)") #axis labels
  return(graph)
}

#################################################
# Calculates parameter estimates and confidence intervals
# for the LINEX production function given a country and an energyType.
#
# countryAbbrev is a string containing the 2-letter abbreviation for the country, e.g. "US" or "CN"
# energyType is a string, one of "Q", "X", or "U"
#
# returns a data.frame of data for the LINEX model.
# First row is the +95% CI on all parameters
# Second row contains the parameter estimates
# Third row is the -95% CI on all parameters
# Each column has names: a_0 and c_t, corresponding to the parameters in the model.
##
linexData <- function(countryAbbrev, energyType){
  #First, check to see if we want useful work (U) AND one of the countries for which we don't have data.
  if (!haveDataCD(countryAbbrev, energyType)){
    #Return a column of NAs if the above conditions have been met.
    nRows <- 3 # +95% CI, CDe, and -95% CI.
    nCols <- 2 # a_0 and c_t
    df <- as.data.frame(matrix(NA, ncol = nCols, nrow = nRows))
    colnames(df) <- c("a_0", "c_t")
    rownames(df) <- c("+95% CI", "CDe", "-95% CI")
    return(df)
  }
  # We have a combination of country and energy type for which we have data.
  modelLINEX <- linexModel(countryAbbrev, energyType)
  summaryLINEX <- summary(modelLINEX) # Gives the nls summary table.
  dofLINEX <- summaryLINEX$df[2] # Gives the degrees of freedom for the model.
  tvalLINEX <- qt(ciHalfLevel, df = dofLINEX)
  ciLINEX <- confint(modelLINEX, level = ciLevel)  # Calculates confidence intervals for the LINEX model.
  # Report results with SE
  a_0 <- as.numeric(coef(modelLINEX)["a_0"])
  c_t <- as.numeric(coef(modelLINEX)["c_t"])
  # Combine all estimates and their confidence intervals into data frames with intelligent row names
  estLINEX <- data.frame(a_0 = a_0, c_t = c_t)
  row.names(estLINEX) <- "LINEX"
  # The [1] subscripts pick off the lower confidence interval
  lowerLINEX <- data.frame(a_0=ciLINEX["a_0","2.5%"], c_t=ciLINEX["c_t", "2.5%"])
  row.names(lowerLINEX) <- "-95% CI"
  # The [2] subscripts pick off the upper confidence interval
  upperLINEX <- data.frame(a_0=ciLINEX["a_0","97.5%"], c_t=ciLINEX["c_t", "97.5%"])
  row.names(upperLINEX) <- "+95% CI"
  # Now create the data for a table and return it
  dataLINEX <- rbind(upperLINEX, estLINEX, lowerLINEX)
  return(dataLINEX)
}

############
# Creates a row for the LINEX parameters table for the given country (2-letter code) and energyType (Q, X, or U)
##
linexCountryRow <- function(countryAbbrev, energyType){
  dataLINEX <- linexData(countryAbbrev, energyType)
  out <- cbind(dataLINEX["-95% CI", "a_0"], dataLINEX["LINEX", "a_0"], dataLINEX["+95% CI", "a_0"],
               dataLINEX["-95% CI", "c_t"], dataLINEX["LINEX", "c_t"], dataLINEX["+95% CI", "c_t"])
  return(out)
}

###########################################
# Creates a number of rows in a data.frame that contain information 
# about the coefficients of a LINEX model for countryName and energyType
# Each parameter has its own row with confidence intervals.
# The country name is in a column. Which parameter is involved is
# also in a column.
# 
# The return type is a data.frame.
##
linexCountryRowsForParamsGraph <- function(countryName, energyType){
  #Create three rows, one for each parameter. Each row is a data.frame so that it is plottable!
  dataLINEX <- linexData(countryName, energyType)
  a_0Row <- data.frame(country = countryName, 
                          parameter = "a_0", 
                          lowerCI = dataLINEX["-95% CI", "a_0"], 
                          value = dataLINEX["LINEX", "a_0"], 
                          upperCI = dataLINEX["+95% CI", "a_0"])
  c_tRow <- data.frame(country = countryName, 
                         parameter = "c_t",
                         lowerCI = dataLINEX["-95% CI", "c_t"],
                         value = dataLINEX["LINEX", "c_t"],  
                         upperCI = dataLINEX["+95% CI", "c_t"])
  table <- rbind(a_0Row, c_tRow)
  return(table)
}

#############################
# Creates a graph with confidence intervals for the LINEX model for the given energyType
##
createLINEXParamsGraph <- function(energyType){
  # Create a data table with the following columns:
  # country abbrev, parameter (a_0, c_t), -95% CI, value, +95% CI
  dataTable <- do.call("rbind", lapply(countryAbbrevs, linexCountryRowsForParamsGraph, energyType=energyType))
  graph <- segplot(country ~ upperCI + lowerCI | parameter, 
                   data = dataTable, 
                   centers = value, #identifies where the dots should be placed
                   draw.bands = FALSE, #provides nicer error bars
                   horizontal = FALSE, #makes error bars vertical and puts the countries in the x axis
                   layout = c(2,1), #2 column, 2 row
                   index.cond = list(c(1,2)), #orders the panels as alpha, beta, lambda, gamma
                   #set labels and bg color in strip
                   strip = strip.custom(factor.levels=c("$a_0$", "$c_t$"), bg="white"),
                   col = "black", #Sets line color to black
                   lwd = 1, #Sets line width to 1.0
                   ylim = list(c(-0.05, 1.0), c(-0.5, 5)), #y axis limits
                   scales = list(cex=scaleTextSize, #controls text size on scales.
                                 tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                                 x=list(cex=0.75), #reduces text size so that country abbrevs are legible
                                 y=list(relation="free", #allow each axis to be different
                                        at=list(c(0.0, 0.5, 1.0), c(0, 1, 2, 3, 4, 5))   #y tick marks
                                 )
                   )
  )
  return(graph)
}

############################
# Aggregates the LINEX results into a big data table for the given energyType.
##
linexParamsTable <- function(energyType){
  #Do rbind on the results of creating a row in the table for every country abbreviation that we know.
  dataLINEX <- do.call("rbind", lapply(countryAbbrevs, linexCountryRow, energyType=energyType))
  colnames(dataLINEX) <- c(" ", "$a_0$", " ", " ", "$c_t$",  " ")
  rownames(dataLINEX) <- countryAbbrevs
  tableLINEX <- xtable(dataLINEX, 
                    caption=paste("LINEX model (with $", tolower(energyType), "$) parameters for 1980-2011 (US, UK, JP), 1991-2010 (CN and ZA), and 1991-2011 (SA, IR, TZ, and ZM). (Parameter estimates beneath symbol. 95\\% confidence interval bounds to left and right.)", sep=""), 
                    label=paste("tab:LINEX_Parameters_With_", energyType, sep=""),
                    digits = c(1, 2,2,2, 2,2,2),
                    align = "r|ccc|ccc") #Sets alignment of the numbers in the columns
  return(tableLINEX)
}

############################
# Prints a table with parameters from a LINEX model for the given energyType. 
##
printLINEXParamsTable <- function(energyType){
  print(linexParamsTable(energyType), 
    caption.placement="top", 
    sanitize.colnames.function = identity, 
    size="\\tiny",
    table.placement="H")
}
@

The LINEX model has the form

\begin{equation} \label{eq:LINEX_model}
  y = e \: \mathrm{e}^{\left[a_0 \left(2 - \frac{l + e}{k} \right) + a_0 c_t \left(\frac{l}{e} - 1 \right)\right]} ,
\end{equation}

\noindent where $e$ is any of $q$, $x$, or $u$; $a_0$ and $c_t$ are fitting parameters; and $\mathrm{e}$ is the base of the natural logarithm.

\subsection{LINEX with $Q$}

Figure \ref{fig:LINEXq_Params_Graph} shows values and 95\% confidence intervals for the parameters for the LINEX model (with $q$).

<<LINEXq_Params_Graph, fig.width=linexParameterGraphWidth, fig.height=linexParameterGraphHeight, fig.pos="H", fig.cap="LINEX (with $q$) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createLINEXParamsGraph("Q")
@

\subsection{LINEX with $X$}

Figure \ref{fig:LINEXx_Params_Graph} shows values and 95\% confidence intervals for the parameters for the LINEX model (with $x$).

<<LINEXx_Params_Graph, fig.width=linexParameterGraphWidth, fig.height=linexParameterGraphHeight, fig.pos="H", fig.cap="LINEX (with $x$) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createLINEXParamsGraph("X")
@

\subsection{LINEX with $U$}

Figure \ref{fig:LINEXu_Params_Graph} shows values and 95\% confidence intervals for the parameters for the LINEX model (with $u$).

<<LINEXu_Params_Graph, fig.width=linexParameterGraphWidth, fig.height=linexParameterGraphHeight, fig.pos="H", fig.cap="LINEX (with $u$) model parameters. Vertical bars indicate 95\\% confidence intervals.">>=
createLINEXParamsGraph("U")
@

\subsection{LINEX comparisons}

Figure \ref{fig:LINEX_GDP_Lattice_Graph} compares LINEX model predictions to historical data.

<<LINEX_GDP_Lattice_Graph, fig.width=ninePanelGraphWidth, fig.height=ninePanelGraphHeight, fig.pos="H", fig.cap="LINEX results.">>=
createLinexLatticeGraph()
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

****************** Add conclusion here. *********************

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Funding for Caleb Reese and Lucas Timmer was graciously supplied by the Jack and Lois Kuipers Applied Mathematics Endowment and the Calvin College Alumni Association. The authors thank Randall Pruim (Calvin College) and Loren L. Heun (Western Michigan University) for their insightful comments on and invaluable assistance with the statistical analyses presented herein.

%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix
%% \section{}
%% \label{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Covariance Tables}
\setcounter{table}{0} % Restarts table number counter at 0 in this section.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following tables show covariances among GDP ($y$) and factors of production ($k$, $l$, $q$, $x$, and $u$).

<<Print_Covariance_Tables, results='asis'>>=
#I wish I could say this, but I get bogus "$US" strings appearing in the LaTeX output.
#lapply(countryAbbrevs, printCovarTable)
printCovarTable("US"); printCovarTable("UK"); printCovarTable("JP")
printCovarTable("CN"); printCovarTable("ZA")
printCovarTable("SA"); printCovarTable("IR")
printCovarTable("TZ"); printCovarTable("ZM")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Model Parameters}
\setcounter{table}{0} % Restarts table number counter at 0 in this section.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Single-factor Models}

The following tables provide results for parameters in single-factor models.

<<SF_Params_Tables, results='asis'>>=
#I wish I could say this, but I get bogus K [1]” strings appearing in the LaTeX output.
#lapply(factors, printSingleFactorParamsTable)
printSFParamsTable("K"); printSFParamsTable("L")
printSFParamsTable("Q"); printSFParamsTable("X"); printSFParamsTable("U")
@

\subsection{Cobb-Douglas Models}

The following tables provide results for parameters in Cobb-Douglas models with and without energy terms.

<<CD_Params_Table, results='asis'>>=
printCDParamsTable()    #Without energy
printCDParamsTable("Q"); printCDParamsTable("X"); printCDParamsTable("U") #With energy
@

\subsection{CES Models}

The following tables provide results for parameters in CES models.

\subsection{LINEX Models}

The following tables provide results for parameters in LINEX models.

<<LINEX_Params_Table, results='asis'>>=
printLINEXParamsTable("Q"); printLINEXParamsTable("X"); printLINEXParamsTable("U")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Goodness of fit}
\setcounter{table}{0} % Restarts table number counter at 0 in this section.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<AIC_Table_Functions, eval=TRUE>>=
###############################
# Creates an xtable object that holds the AIC values for each parameter estimation that we include.
##
createAICTable <- function(){
  ######################
  # Single-factor models
  ######################
  # Single-factor with K
  sfKModels <- lapply(countryAbbrevs, singleFactorModel, factor="K")
  aicSFk <- data.frame(lapply(sfKModels, AIC))
  rownames(aicSFk) <- "SF$k$"
  # Single-factor with L
  sfLModels <- lapply(countryAbbrevs, singleFactorModel, factor="L")
  aicSFl <- data.frame(lapply(sfLModels, AIC))
  rownames(aicSFl) <- "SF$l$"
  # Single-factor with Q
  sfQModels <- lapply(countryAbbrevs, singleFactorModel, factor="Q")
  aicSFq <- data.frame(lapply(sfQModels, AIC))
  rownames(aicSFq) <- "SF$q$"
  # Single-factor with X
  sfXModels <- lapply(countryAbbrevs, singleFactorModel, factor="X")
  aicSFx <- data.frame(lapply(sfXModels, AIC))
  rownames(aicSFx) <- "SF$x$"
  # Single-factor with U
  aicSFu <- cbind(US=AIC(singleFactorModel("US", "U")), 
                  UK=AIC(singleFactorModel("UK", "U")), 
                  JP=AIC(singleFactorModel("JP", "U")),
                  CN=NA, ZA=NA, SA=NA, IR=NA, TZ=NA, ZM=NA) #No U data for these countries.
  rownames(aicSFu) <- "SF$u$"
  ######################
  # Cobb-Douglas models
  ######################
  # Cobb-Douglas without energy
  cdModels <- lapply(countryAbbrevs, cobbDouglasModel)
  aicCD <- data.frame(lapply(cdModels, AIC))
  rownames(aicCD) <- "CD"
  # Cobb-Douglas with Q
  cdQModels <- lapply(countryAbbrevs, cobbDouglasModel, energyType="Q")
  aicCDq <- data.frame(lapply(cdQModels, AIC))
  rownames(aicCDq) <- "CD$q$"
  # Cobb-Douglas with X
  cdXModels <- lapply(countryAbbrevs, cobbDouglasModel, energyType="X")
  aicCDx <- data.frame(lapply(cdXModels, AIC))
  rownames(aicCDx) <- "CD$x$"
  # Cobb-Douglas with U
  aicCDu <- cbind(US=AIC(cobbDouglasModel("US", "U")), 
                  UK=AIC(cobbDouglasModel("UK", "U")), 
                  JP=AIC(cobbDouglasModel("JP", "U")),
                  CN=NA, ZA=NA, SA=NA, IR=NA, TZ=NA, ZM=NA) #No U data for these countries.
  rownames(aicCDu) <- "CD$u$"
  ######################
  # CES models
  ######################


  ######################
  # LINEX models
  ######################
  # LINEX with Q
  linexQModels <- lapply(countryAbbrevs, linexModel, energyType="Q")
  aicLINEXq <- data.frame(lapply(linexQModels, AIC))
  rownames(aicLINEXq) <- "LINEX$q$"
  # LINEX with X
  linexXModels <- lapply(countryAbbrevs, linexModel, energyType="X")
  aicLINEXx <- data.frame(lapply(linexXModels, AIC))
  rownames(aicLINEXx) <- "LINEX$x$"  
  # LINEX with U
  aicLINEXu <- cbind(US=AIC(linexModel("US", "U")), 
                  UK=AIC(linexModel("UK", "U")), 
                  JP=AIC(linexModel("JP", "U")),
                  CN=NA, ZA=NA, SA=NA, IR=NA, TZ=NA, ZM=NA) #No U data for these countries.
  rownames(aicLINEXu) <- "LINEX$u$"
  
  # Create the data.frame table
  out <- rbind(aicSFk, aicSFl, aicSFq, aicSFx, aicSFu, aicCD, aicCDq, aicCDx, aicCDu, aicLINEXq, aicLINEXx, aicLINEXu) 
  # Create the xtable with caption and label
  out <- xtable(out, caption="AIC values for all models.", label="tab:AICTable", digits=1)
  return(out)
}
@

We assess goodness of fit via the Akaike Information Criterion (AIC). AIC values for all models and all countries are shown in Table \ref{tab:AICTable}. Increasing goodness of fit is indicated by smaller (i.e., more negative) AIC values. AIC values can be compared per data set (i.e., per country) but not across data sets (i.e., not across countries). 

<<AIC_Table, results='asis', label="AIC_Table">>=
print(createAICTable(), 
      caption.placement="top", 
      sanitize.rownames.function = identity,
      size="\\tiny",
      table.placement="H")
@


%% References
%%
%% Following citation commands can be used in the body text:
%%
%%  \citet{key}  ==>>  Jones et al. (1990)
%%  \citep{key}  ==>>  (Jones et al., 1990)
%%
%% Multiple citations as normal:
%% \citep{key1,key2}         ==>> (Jones et al., 1990; Smith, 1989)
%%                            or  (Jones et al., 1990, 1991)
%%                            or  (Jones et al., 1990a,b)
%% \cite{key} is the equivalent of \citet{key} in author-year mode
%%
%% Full author lists may be forced with \citet* or \citep*, e.g.
%%   \citep*{key}            ==>> (Jones, Baker, and Williams, 1990)
%%
%% Optional notes as:
%%   \citep[chap. 2]{key}    ==>> (Jones et al., 1990, chap. 2)
%%   \citep[e.g.,][]{key}    ==>> (e.g., Jones et al., 1990)
%%   \citep[see][pg. 34]{key}==>> (see Jones et al., 1990, pg. 34)
%%  (Note: in standard LaTeX, only one note is allowed, after the ref.
%%   Here, one note is like the standard, two make pre- and post-notes.)
%%
%%   \citealt{key}          ==>> Jones et al. 1990
%%   \citealt*{key}         ==>> Jones, Baker, and Williams 1990
%%   \citealp{key}          ==>> Jones et al., 1990
%%   \citealp*{key}         ==>> Jones, Baker, and Williams, 1990
%%
%% Additional citation possibilities
%%   \citeauthor{key}       ==>> Jones et al.
%%   \citeauthor*{key}      ==>> Jones, Baker, and Williams
%%   \citeyear{key}         ==>> 1990
%%   \citeyearpar{key}      ==>> (1990)
%%   \citetext{priv. comm.} ==>> (priv. comm.)
%%   \citenum{key}          ==>> 11 [non-superscripted]
%% Note: full author lists depends on whether the bib style supports them;
%%       if not, the abbreviated list is printed even when full requested.
%%
%% For names like della Robbia at the start of a sentence, use
%%   \Citet{dRob98}         ==>> Della Robbia (1998)
%%   \Citep{dRob98}         ==>> (Della Robbia, 1998)
%%   \Citeauthor{dRob98}    ==>> Della Robbia


%% References with bibTeX database:

\bibliographystyle{model2-names}
%%\bibliography{<your-bib-database>}
\bibliography{EconGrowth.bib}

%% Authors are advised to submit their bibtex database files. They are
%% requested to list a bibtex style file in the manuscript if they do
%% not want to use model2-names.bst.

%% References without bibTeX database:

% \begin{thebibliography}{00}

%% \bibitem must have one of the following forms:
%%   \bibitem[Jones et al.(1990)]{key}...
%%   \bibitem[Jones et al.(1990)Jones, Baker, and Williams]{key}...
%%   \bibitem[Jones et al., 1990]{key}...
%%   \bibitem[\protect\citeauthoryear{Jones, Baker, and Williams}{Jones
%%       et al.}{1990}]{key}...
%%   \bibitem[\protect\citeauthoryear{Jones et al.}{1990}]{key}...
%%   \bibitem[\protect\astroncite{Jones et al.}{1990}]{key}...
%%   \bibitem[\protect\citename{Jones et al., }1990]{key}...
%%   \harvarditem[Jones et al.]{Jones, Baker, and Williams}{1990}{key}...
%%

% \bibitem[ ()]{}

% \end{thebibliography}

\end{document}

%%
%% End of file `elsarticle-template-2-harv.tex'.