% This article has been prepared for publication in Energy Economics in RStudio with knitr.
% According to http://www.elsevier.com/author-schemas/the-elsarticle-latex-document-class, we should be using the
% elsarticle.cls file.
% According to http://cdn.elsevier.com/assets/pdf_file/0006/109392/journal_refstyles.pdf, we should be using
% elsarticle-template-2-harv.tex as the template for the text.
% Furthermore, we should be using model2-names.bst for the bibliographic references.
% The approach here is to load the frontmatter and backmatter from elsarticle-template-2-harv.tex
% both ahead of and behind the text for our paper.
% -- Matthew Kuperus Heun, 2013-01-18

%% This is file `elsarticle-template-2-harv.tex',
%%
%% Copyright 2009 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle  Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for Elsevier's document class `elsarticle'
%% with harvard style bibliographic references
%%
%% $Id: elsarticle-template-2-harv.tex 155 2009-10-08 05:35:05Z rishi $
%% $URL: http://lenova.river-valley.com/svn/elsbst/trunk/elsarticle-template-2-harv.tex $
%%
\documentclass[preprint,authoryear,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[authoryear,preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,authoryear,1p,times]{elsarticle}
%% \documentclass[final,authoryear,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,authoryear,3p,times]{elsarticle}
%% \documentclass[final,authoryear,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,authoryear,5p,times]{elsarticle}
%% \documentclass[final,authoryear,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
%% \usepackage{graphics}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
%% \usepackage{lineno}

%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon (default)
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   authoryear - selects author-year citations (default)
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%   longnamesfirst  -  makes first citation full author list
%%
%% \biboptions{longnamesfirst,comma}

% \biboptions{}

\journal{Energy Economics}

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{Empirical Analysis of the Role of Energy in Economic Growth}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{<author name>}
%% \address[label1]{<address>}
%% \address[label2]{<address>}

\author[Calvin]{Caleb Reese}
\author[Calvin]{Lucas Timmer}
\author[Calvin]{Matthew Kuperus Heun\corref{cor1}}
\ead{mkh2@calvin.edu, tel: +1 (616) 526-6663, fax: +1 (616) 526-6501}

\cortext[cor1]{Corresponding author}
\address[Calvin]{Engineering Department, Calvin College, Grand Rapids, MI 49546, USA}

\begin{abstract}
%% Text of abstract
*********** Add abstract ***********
\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
economic growth \sep energy \sep cobb-douglas \sep CES \sep LINEX
%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)
\end{keyword}

\end{frontmatter}

% \linenumbers
%% main text

Caleb, put your LaTeX code here.


<<setup, include=FALSE>>=
require(knitr)
require(lattice)
require(latticeExtra)
require(ggplot2)
require(car)
require(mosaic)
require(xtable)
trellis.par.set(theme=theme.mosaic())
options(width=75)
options(show.signif.stars=FALSE)
opts_chunk$set(
  tidy=FALSE,
  fig.width=6,
  fig.height=4,
  comment=NA)

# Statistical significance levels. We'll work with 95% CIs
ciLevel <- 0.95
ciHalfLevel <- ciLevel + (1.0-ciLevel)/2.0
# List of countries
countryAbbrevs <- c(US="US", UK="UK", JP="JP", CN="CN", ZA="ZA", SA="SA", IR="IR", TZ="TZ", ZM="ZM")
countryNamesAlph <- c(CN="China", IR="Iran", JP="Japan", SA="Saudi Arabia", TZ="Tanzania", UK="United Kingdom", US="USA", ZA="South Africa", ZM="Zambia") #In alphabetical order.

# Set the order for presenting countries in 3x3 lattice graphs. Default is alphabetical. "1" means first alphabetically.
# So, this list sets the order as US, UK, JP, CN, ZA, TZ, SA, IR, ZM.
countryOrderForGraphs <- c(7,6,3,1,8,5,4,2,9)
# Full page lattice plot sizes and other parameters
layoutSpec <- c(3,3) #indicates a 3x3 arrangement of panels.
figWidth <- 6.5 #Inches
figHeight <- 7.5 #Inches
keyTextSize <- 0.85 #85% of normal size
keyColumns <- 1 #Want only 1 column in the key for lattice graphs
keyXLoc <- 0.01 #x position of the key
keyYLoc <- 0.95 #y position of the key
scaleTextSize <- 0.75 #75% of normal size
scaleTickSize <- -0.5 #50% of normal size and pointing INWARD!
# List of energy types
energyTypes <- c(Q="Q", X="X", U="U")
@


<<Load Data, include=FALSE>>=
#################################
# This function loads data given a country name.
# The file name from which data will be loaded is assumed to be of the form 
# "<countryName>Data.txt". The file is assumed to exist in a subfolder of this project called "data".
#
# countryName is a string containing the 2-letter abbreviation for the country, e.g. "US" or "CN"
#
# returns a matrix with the data that has been loaded
##
loadData <- function(countryName){
  # Read the data file as a table with a header.  
  fileName <- paste("data/", countryName, "Data.txt", sep="")
  dataTable <- read.table(fileName, header = TRUE)
  # Identifies the header names associated with dataTable
  #print(names(dataTable))
  return(dataTable)
}
@

<<Factors_Lattice_Graph, fig.width=figWidth, fig.height=figHeight, fig.cap="GDP ($y$), capital stock ($k$), labor ($l$), thermal energy ($q$), exergy ($x$), and useful work ($u$) for all economies. (China's indexed GDP and indexed capital stock rise to $y = 7.3$ and $k = 9.2$ in 2011.)", echo=FALSE, eval=FALSE>>=
createFactorsLatticeGraph <- function(){
  dataTable <- loadData("All")
  graphType <- "b" #b is for both line and symbol
  lineTypes <- c(0, 1, 5, 2, 4, 1) #line types. See http://en.wikibooks.org/wiki/R_Programming/Graphics
  lineWidths <- c(0, 2, 2, 1, 1, 1) #line widths. 0 means no line.
  colors <- c("black", "black", "black", "red", "blue", "darkorange") #line and symbol colors
  symbols <- c(1, NA, NA, NA, NA, NA)  #NA gives no symbol.
  graph <- xyplot(iGDP+iCapStk+iLabor+iQ+iX+iU ~ Year | Country, data=dataTable,
                  type = graphType,
                  index.cond = list(countryOrderForGraphs), #orders the panels.
                  layout = layoutSpec, 
                  strip = strip.custom(factor.levels=countryNamesAlph, bg="white"), #Sets strip parameters
                  as.table = TRUE, #indexing of panels starts in upper left and goes across rows.
                  lty = lineTypes, lwd = lineWidths, col = colors, #Controls line parameters
                  pch = symbols, col.symbol = colors, #Controls symbol parameters
                  key=list(text=list(c("y", "k", "l", "q", "x", "u")),
                           type=graphType,
                           cex=keyTextSize, #controls size of text in the key
                           lines=list(lty=lineTypes, lwd=lineWidths), #controls line types
                           pch=symbols, col=colors, #controls symbol (plot characters) types
                           columns=keyColumns, x=keyXLoc, y=keyYLoc), #controls columns and position of the key
                  scales=list(cex=scaleTextSize, #controls text size on scales.
                              tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                              y=list(at=c(1,2,3,4,5,6,7,8,9,10))), #tick mark locations
                  ylim=c(0.5,4.5), #y axis limits
                  xlab="", ylab="Indexed (1980=1 or 1991=1)") #axis labels
  return(graph)
}
createFactorsLatticeGraph()
@

\section{Cobb-Douglas Without Energy}

<<cobb-douglas, echo=FALSE>>=
####################
# Returns an nls Cobb-Douglas model for the country specified
##
cobbDouglasModel <- function(countryName){
  # Load the data that we need.
  dataTable <- loadData(countryName)
  
  # Establish guess values for alpha and lambda.
  lambdaGuess <- 0.0 # guessing lambda = 0 means there is no technological progress.
  alphaGuess <- 0.3 # a typical value for alpha, the coefficient on capital stock
  
  # Runs a non-linear least squares fit to the data. We've replaced beta with 1-alpha for simplicity.
  modelCD <- nls(iGDP ~ exp(lambda*iYear) * iCapStk^alpha * iLabor^(1 - alpha), 
#                 algorithm = "port",
                 start = list(lambda=lambdaGuess, alpha=alphaGuess),
#                 lower = list(lambda=-Inf, alpha=0),
#                 upper = list(lambda=Inf, alpha=1),
                 data=dataTable)
  return(modelCD)
}

#########################
# Takes the Cobb-Douglas fitted models and creates per-country predictions for them.
# Returns a data.frame with the predictions.
##
cobbDouglasPredictions <- function(countryName){
  model <- cobbDouglasModel(countryName)
  pred <- predict(model) #See http://stackoverflow.com/questions/9918807/how-get-plot-from-nls-in-r
  df <- data.frame(pred)
  # There are two countries which do not have labor data for 2011. Need to add a "NA" for 2011 for those countries.
  if (countryName == "CN" || countryName == "ZA"){
    dfNA <- data.frame(NA)
    colnames(dfNA) <- "pred" #Need to give it the same name so that we can apply rbind
    df <- rbind(df, dfNA)
  }
  return(df)
}

#########################
# Takes the Cobb-Douglas fitted models and creates a single column of predicted GDP values
# that corresponds, row for row, with the AllData.txt file.
##
cobbDouglasPredictionsColumn <- function(){
  preds <- lapply(countryAbbrevs, cobbDouglasPredictions)
  out <- rbind(preds[["US"]], preds[["UK"]], preds[["JP"]], preds[["CN"]], preds[["ZA"]], preds[["SA"]], preds[["IR"]], preds[["TZ"]], preds[["ZM"]])
  colnames(out) <- c("predGDP")
  return(out)
}

#################################################
# Calculates parameter estimates and confidence intervals
# for the Cobb-Douglas production function given a country.
#
# countryName is a string containing the 2-letter abbreviation for the country, e.g. "US" or "CN"
#
# returns a vector of data for the Cobb-Douglas model. 
# First item is the +95% CI on all parameters
# Second item contains the parameter estimates
# Third item is the -95% CI on all parameters
# Each row has names: lambda, alpha, beta, gamma, corresponding to the parameters in the model.
##
cobbDouglasData <- function(countryName){
  modelCD <- cobbDouglasModel(countryName)
  
  # Checks validity of the model. AIC stands for Akaike's Information Criterion.
  aicCD  <- AIC(modelCD, k=2)
  #print(aicCD)
  
  summaryCD <- summary(modelCD) # Gives the nls summary table.
  #print(summaryCD)
  ciCD <- confint(modelCD, level = ciLevel); ciCD # Displays confidence intervals for the CD model.
  
  # Calculate beta and its confidence interval and report it.
  alpha <- as.numeric(coef(modelCD)["alpha"])
  beta <- 1.0 - alpha
  beta.est <- deltaMethod(modelCD, "1 - alpha"); beta.est # Estimates beta and its standard error (SE).
  # Now calculate a confidence interval on beta
  dofCD <- summaryCD$df[2]; dofCD # Gives the degrees of freedom for the model.
  tvalCD <- qt(ciHalfLevel, df = dofCD); tvalCD
  betaCICD <- with(beta.est, Estimate + c(-1.0, 1.0) * tvalCD * SE); betaCICD # Gives the confidence interval on beta.
  
  #print(coef(modelCD))
  
  # Combine all estimates and their confidence intervals into data frames with intelligent row names
  estCD <- data.frame(lambda = coef(modelCD)["lambda"], alpha = coef(modelCD)["alpha"], beta = beta, gamma = 0)
  #print(estCD)
  row.names(estCD) <- "CD"
  #row.names(estCD) <- "Cobb-Douglas: $y = e^{\\lambda t}k^{\\alpha}l^{\\beta}$"
  # The [1] subscripts pick off the lower confidence interval
  lowerCD <- data.frame(lambda = ciCD["lambda","2.5%"], alpha = ciCD["alpha", "2.5%"], beta = betaCICD[1], gamma = NA) 
  row.names(lowerCD) <- "- 95% CI"
  # The [2] subscripts pick off the lower confidence interval
  upperCD <- data.frame(lambda = ciCD["lambda","97.5%"], alpha = ciCD["alpha", "97.5%"], beta = betaCICD[2], gamma = NA)
  row.names(upperCD) <- "+ 95% CI"
  
  # Now create the data for a table.
  dataCD <- rbind(upperCD, estCD, lowerCD)
  #print(dataCD)
  return(dataCD)
}

####################################
# Creates a LaTeX printable table from the Cobb Douglas data. This function first calls cobbDouglasData.
#
# countryName is a string containint the 2-letter abbreviation for the country, e.g. "US" or "CN"
#
# returns a printable LaTeX table from xtable.
##
cobbDouglasCountryTable <- function(countryName){
  dataCD <- cobbDouglasData(countryName) 
  colnames(dataCD) <- c("$\\lambda$", "$\\alpha$", "$\\beta$", "$\\gamma$")
  tableCD <- xtable(dataCD, caption=paste(countryName, " Cobb-Douglas, 1980-2011", sep=""), digit = c(4, 4, 2, 2, 1))
  #print(tableCD)
  return(tableCD)  
}

############
# Creates a row for the Cobb Douglas parameters table
##
cobbDouglasCountryRow <- function(countryName){
  dataCD <- cobbDouglasData(countryName)
  # Create CI ranges
  out <- cbind(dataCD["- 95% CI", "lambda"], dataCD["CD", "lambda"], dataCD["+ 95% CI", "lambda"],
               dataCD["- 95% CI", "alpha"],  dataCD["CD", "alpha"],  dataCD["+ 95% CI", "alpha"],
               dataCD["- 95% CI", "beta"],   dataCD["CD", "beta"],   dataCD["+ 95% CI", "beta"])
  return(out)
}

cobbDouglasCountryRowsForParamsGraph <- function(countryName){
  dataCD <- cobbDouglasData(countryName)
  #Create three rows, one for each parameter.
  lambdaRow <- cbind(dataCD["- 95% CI", "lambda"], 
                     dataCD["CD", "lambda"], 
                     dataCD["+ 95% CI", "lambda"], 
                     countryName, 
                     "lambda")
  alphaRow <- cbind(dataCD["- 95% CI", "alpha"],
                    dataCD["CD", "alpha"],  
                    dataCD["+ 95% CI", "alpha"],
                    countryName,
                    "alpha")
  betaRow <- cbind(dataCD["- 95% CI", "beta"],   
                   dataCD["CD", "beta"],   
                   dataCD["+ 95% CI", "beta"],
                   countryName,
                   "beta")
  #Now combine into a table
  table <- rbind(lambdaRow, alphaRow, betaRow)
  colnames(table) <- c("- 95% CI", "value", "+ 95% CI", "country", "parameter")
  return(table)
}

############################
# Aggregates the Cobb-Douglas results into a big data table
##
cobbDouglasParamsTable <- function(){
  dataCD <- rbind(cobbDouglasCountryRow("US"),
                cobbDouglasCountryRow("UK"),
                cobbDouglasCountryRow("JP"),
                cobbDouglasCountryRow("CN"),
                cobbDouglasCountryRow("ZA"),
                cobbDouglasCountryRow("SA"),
                cobbDouglasCountryRow("IR"),
                cobbDouglasCountryRow("TZ"),
                cobbDouglasCountryRow("ZM"))
  colnames(dataCD) <- c(" ", "$\\lambda$", " ", 
                        " ", "$\\alpha$",  " ",
                        " ", "$\\beta$",   " ")
  rownames(dataCD) <- countryAbbrevs
  tableCD <- xtable(dataCD, 
                    caption="Cobb-Douglas parameters for 1980-2011 (US, UK, JP) or 1991-2011 (others). (Parameter estimates beneath symbol. 95\\% confidence bounds to left and right.)", 
                    digit = c(1, 4,4,4, 2,2,2, 2,2,2),
                    align = "r|ccc|ccc|ccc")
  return(tableCD)
}
@

<<CD Params Table, results='asis', echo=FALSE, eval=FALSE>>=
print(cobbDouglasParamsTable(), caption.placement="top", sanitize.colnames.function = identity)
@

<<CD_Params_Graph, fig.width=figWidth, fig.height=figHeight, fig.cap="Cobb-Douglas (without energy) model parameters.">>=
createCDParamsGraph <- function(){
  # Create the data table that we want. This table has the following columns
  # -95% CI, value, +95% CI, country abbrev, parameter (lambda, alpha, or beta)
  dataTable <- do.call("rbind", lapply(countryAbbrevs, cobbDouglasCountryRowsForParamsGraph))
  
  print(dataTable)
  
  graph <- segplot(value ~ country | parameter, centers=value, data=dataTable)  
  return(graph)

  
    
}

createCDParamsGraph()


@

<<CD_Lattice_Graph, fig.width=figWidth, fig.height=figHeight, fig.cap="Cobb-Douglas (without energy) results.", echo=FALSE, eval=FALSE>>=
createCDLatticeGraph <- function(){
  dataTable <- loadData("All") #Grab the raw data
  predictions <- cobbDouglasPredictionsColumn() #Get the predictions from the models
  dataTable <- cbind(dataTable, predictions) #Now add the predictions column to the data. Column name = "predGDP".
  graphType <- "b" #b is for both line and symbol
  lineTypes <- c(0, 1) #line types. See http://en.wikibooks.org/wiki/R_Programming/Graphics
  lineWidths <- c(0, 1) #line widths. 0 means no line.
  colors <- c("black", "black") #line and symbol colors
  symbols <- c(1, NA)  #NA gives no symbol.
  graph <- xyplot(iGDP+predGDP ~ Year | Country, data=dataTable,
                  type=graphType,
                  index.cond=list(countryOrderForGraphs), #orders the panels.
                  layout=layoutSpec, #indicates a 3x3 arrangement of panels.
                  strip = strip.custom(factor.levels=countryNamesAlph, bg="white"), #Sets strip parameters
                  as.table=TRUE, #indexing of panels starts in upper left and goes across rows.
                  lty = lineTypes, lwd = lineWidths, col = colors, #Controls line parameters
                  pch = symbols, col.symbol = colors, #Controls symbol parameters
                  key=list(text=list(c("Actual", "Predicted")),
                           type=graphType,
                           cex=keyTextSize, #controls size of text in the key
                           lines=list(lty=lineTypes, lwd=lineWidths), #controls line types
                           pch=symbols, col=colors, #controls symbol (plot characters) types
                           columns=keyColumns, x=keyXLoc, y=keyYLoc), #controls columns and position of the key
                  scales=list(cex=scaleTextSize, #controls text size on scales.
                              tck=scaleTickSize, #controls tick mark length. < 0 for inside the graph.
                              y=list(at=c(1,2,3,4,5,6,7,8,9,10))), #tick mark locations
                  ylim=c(0.5,8), #y axis limits
                  xlab="", ylab="Indexed GDP (1980=1 or 1991=1)") #axis labels
  return(graph)
}
createCDLatticeGraph()
@

\section{Cobb-Douglas With Energy}

We can force $\alpha$, $\beta$, and $\gamma$ to be in $[0,1]$ by a reparameterization:

\[ a \in[0,1], b \in [0,1], \alpha=\min(a,b), \beta=|b-a|, \gamma = 1-\max(a,b) \]

<<cobbDouglasEnergy function, include=TRUE, echo=FALSE, eval=FALSE>>=
###############################
# This function fits the Cobb Douglas production function including energy to historical data
# The functional form is
#
# iGDP = exp(lambda * itime) * iCapStk^alpha * iLabor^beta * iEnergy^gamma
# 
# iYear: time indexed to 0.0 at the first year [years since beginning of data set]
# iGDP = time series GDP data indexed to 1.0 at the first year [-]
# iCapStk = time series capital stock data indexed to 1.0 at the first year [-]
# iLabor = time series labor data indexed to 1.0 at the first year [-]
# iEnergy = time series energy data indexed to 1.0 at the first year [-]. 
#      This may be any of heat (iQ), exergy (iX), or useful work (iU).
# 
# returns a data object containing three rows and 5 columns.
#   col 1: lambda
#   col 2: alpha
#   col 3: beta
#   col 4: gamma
#   row 1: -95% CI for each parameter
#   row 2: estimate for each parameter
#   row 3: +95% CI for each parameter
#
# countryName is a string containint the 2-letter abbreviation for the country, e.g. "US" or "CN"
# energyType is a string to be used in table captions reprsenting the type of energy. Typically, "Q", "X", or "U"
##
cobbDouglasEnergyData <- function(countryName, energyType){
  
  print(countryName)
  energyColumnName  <- paste("i", energyType, sep="")
  #print(energyColumnName)
  
  # Load the data that we need.
  dataTable <- loadData(countryName)
  
  # Reparameterize to ensure that we meet the constraints:
  # * alpha + beta + gamma = 1.0.
  # * alpha, beta, and gamma are all between 0.0 and 1.0.
  # To do this, we reparameterize as
  # * 0 < a < 1
  # * 0 < b < 1
  # * alpha = min(a, b)
  # * beta = b - a
  # * gamma = 1 - max(a, b)
  iEnergy <- dataTable[energyColumnName] #grabs the desired energy column
  lambdaGuess <- 0.0 # guessing lambda = 0 means there is no technological progress.
  alphaGuess <- 0.3 # a typical value for alpha
  betaGuess <- 0.7 # a typical value for beta
  modelCDe <- nls(iGDP ~ exp(lambda*iYear) * 
                    iCapStk^min(a,b) * iLabor^abs(b-a) * 
                    iEnergy^(1.0 - max(a,b)), 
                  algorithm = "port",
                  start = list(lambda=lambdaGuess, a=alphaGuess, b=alphaGuess+betaGuess),
                  lower = list(lambda=-Inf, a=0, b=0),
                  upper = list(lambda=Inf, a=1, b=1),
                  data = dataTable)
  aicCDe <- AIC(modelCDe, k=2) # Checks validity of the model. AIC stands for Akaike's Information Criterion
  #print(aicCDe)
  
  summaryCDe <- summary(modelCDe) # Gives the nls summary table
  print(summaryCDe)
  
  # Provides confidence intervals on lambda, a, and b. But, we need CIs on alpha and beta.
  ciCDe <- confint(modelCDe, level = ciLevel)
  #print(ciCDe)
  
  a <- as.numeric(coef(modelCDe)["a"])
  b <- as.numeric(coef(modelCDe)["b"])
  print(a)
  print(b)
  lambda <- as.numeric(coef(modelCDe)["lambda"])
  alpha <- a
  beta <- b - a
  gamma <- 1.0 - alpha - beta
  
  # Report results with SE
  beta.est <- deltaMethod(modelCDe, "b-a") # Reports results for beta, because beta = b - a.
  gamma.est <- deltaMethod(modelCDe, "1-b") # Reports results for gamma, because gamma = 1 - b.
  
  # Now calculate confidence intervals.
  dofCDe <- summaryCDe$df[2] # Gives the degrees of freedom for the model.
  #print(dofCDe)
  tvalCDe <- qt(ciHalfLevel, df = dofCDe)
  #print(tvalCDe)
  betaCICDe <- with(beta.est, Estimate + c(-1.0, 1.0) * tvalCDe * SE) # Gives the confidence interval on beta.
  #print(betaCICDe)
  gammaCICDe <- with(gamma.est, Estimate + c(-1.0, 1.0) * tvalCDe * SE) # Gives the confidence interval on alpha.
  #print(gammaCICDe)
  
  # Combine all estimates and their confidence intervals into data frames with intelligent row names
  estCDe <- data.frame(lambda = lambda, alpha = alpha, beta = beta, gamma = gamma)
  #print(estCDe);
  #row.names(estCDe) <- "Cobb-Douglas with e: $y = e^{\\lambda t}k^{\\alpha}l^{\\beta}e^{\\gamma}$"
  row.names(estCDe) <- paste("C-D with ", energyType, sep="")
  # The [1] subscripts pick off the lower confidence interval
  lowerCDe <- data.frame(lambda = ciCDe["lambda","2.5%"], alpha = ciCDe["a", "2.5%"], beta = betaCICDe[1], gamma = gammaCICDe[1])
  row.names(lowerCDe) <- "- 95% CI"
  # The [2] subscripts pick off the lower confidence interval
  upperCDe <- data.frame(lambda = ciCDe["lambda","97.5%"], alpha = ciCDe["a", "97.5%"], beta = betaCICDe[2], gamma = gammaCICDe[2])
  row.names(upperCDe) <- "+ 95% CI"
  
  # Now create the data for a table.
  dataCDe <- rbind(upperCDe, estCDe, lowerCDe)
  #print(dataCDe)
  return(dataCDe)
}

####################################
# Creates a LaTeX printable table from the CES data. This function first calls cobbDouglasEnergyData.
#
# countryName is a string containint the 2-letter abbreviation for the country, e.g. "US" or "CN"
# energyType is a string to be used in table captions reprsenting the type of energy. Typically, "Q", "X", or "U"
#
# returns a printable LaTeX table from xtable.
##
cobbDouglasEnergyTable <- function(countryName, energyType){
  dataCDe <- cobbDouglasEnergyData(countryName, energyType)
  tableCDe <- xtable(dataCDe, caption=paste(countryName, ", 1980-2011.", sep=""), digit = c(4, 4, 2, 2, 3))
  return(tableCDe)
}
@

\subsection{Cobb-Douglas with $Q$}

<<CDq analysis, eval=FALSE>>=
# Note that the anlaysis of ZA is taking a long time here. Need to figure out why.
CDqTables <- lapply(countryAbbrevs, cobbDouglasEnergyTable, energyType="Q")
@

<<CDq Results, results='asis', echo=TRUE, eval=FALSE>>=
print(CDqTables[["US"]], caption.placement="top")
print(CDqTables[["ZA"]], caption.placement="top")
# According to http://cran.r-project.org/web/packages/xtable/vignettes/xtableGallery.pdf, Section 3.1, I should 
# be able to use the "sanitize.text.function" parameter to allow markup in column headers. But this next
# line is not working at the present time. --MKH, 18 Jan 2012.
# print(tableCDe, sanitize.text.function = function(x){x})

#print(tableAll, caption.placement="top")
@

\subsection{Cobb-Douglas With $X$}

<<CDx analysis, eval=FALSE>>=
# Note that the anlaysis of ZA is taking a long time here. Need to figure out why.
CDxTables <- lapply(countryAbbrevs, cobbDouglasEnergyTable, energyType="X")
@

<<CDx Results, results='asis', eval=FALSE>>=
print(CDxTables[["US"]], caption.placement="top")
print(CDxTables[["ZA"]], caption.placement="top")
@

\subsection{Cobb-Douglas With $U$}

<<CDu analysis, eval=FALSE>>=
CDuTables <- lapply(countryAbbrevs, cobbDouglasEnergyTable, energyType="U")
@

<<CDu Results, results='asis', eval=FALSE>>=
print(CDuTables[["US"]], caption.placement="top")
print(CDuTables[["ZA"]], caption.placement="top")
@

\section{CES}

<<CES function>>=
cesData <- function(countryName, energyType){
  energyColumnName <- paste("i", energyType, sep="")
  # Load the data that we need.
  dataTable <- loadData(countryName)
    
  # Establish guess values for phi beta, zeta, lambda_L and lambda_E.
  phiGuess <- -20
  betaGuess <- 0.5 # a typical value for beta (exponent on labor)
  zetaGuess <- 0.0004 # a small value
  lambda_LGuess <- 0.007 #assuming no technical progress on the labor-capital portion of the function
  lambda_EGuess <- 0.008 #assuming no technical progress on the energy portion of the function
  
  # Runs a non-linear least squares fit to the data with constraints
  modelCES <- nls(iGDP ~ ((1-zeta) * (exp(lambda_L*iYear) * iCapStk^(1-beta) * iLabor^beta)^phi 
                           + zeta*(exp(lambda_E*iYear) * iQ)^phi)^(1/phi), 
                   algorithm = "port",
                   control = nls.control(maxiter = 500, tol = 1e-06, minFactor = 1/1024, 
                                         printEval = FALSE, warnOnly = FALSE),
                   start = list(phi=phiGuess, beta=betaGuess, zeta=zetaGuess, lambda_L=lambda_LGuess, 
                                lambda_E=lambda_EGuess),
                   lower = list(phi=-Inf, beta=0, zeta=0, lambda_L=-Inf, lambda_E=-Inf),
                   upper = list(phi=0, beta=1, zeta=1, lambda_L=Inf, lambda_E=Inf),
                   data=dataTable)

  aicCES <- AIC(modelCES, k=2) # Checks validity of the model. AIC stands for Akaike's Information Criterion
  print(aicCES)

  # Gives the nls summary table
  summaryCES <- summary(modelCES) # Gives the nls summary table
  print(summaryCES)
  
  # Provides confidence intervals on phi, beta, zeta, lambda_L, and lambda_E. But, we need the CI on alpha.
  ciCES <- confint(modelCES, level = ciLevel)
  print(ciCES)
  
  # Get the estimate for alpha
  beta <- as.numeric(coef(modelCES)["beta"])
  alpha <- 1.0 - beta
  alpha.est <- deltaMethod(modelCES, "1 - beta") # Estimates alpha and its standard error (SE).
  print(alpha.est) 
  
  # Now calculate a confidence interval on alpha
  dofCES <- summaryCES$df[2]
  print(dofCES) # Gives the degrees of freedom for the model.
  tvalCES <- qt(ciHalfLevel, df = dofCES); tvalCES
  # Get confidence intervals for each parameter in the model
  alphaCICES <- with(alpha.est, Estimate + c(-1.0, 1.0) * tvalCES * SE) # CI on alpha.
  print(alphaCICES) 

  # Assemble the data into data frames for the table.
  estCES <- data.frame(phi = coef(modelCES)["phi"], alpha = alpha, 
                       beta = coef(modelCES)["beta"], zeta = coef(modelCES)["zeta"], 
                       lambda_L = coef(modelCES)["lambda_L"], lambda_E = coef(modelCES)["lambda_E"])
  row.names(estCES) <- paste("CES with ", energyType, sep="")
  #print(estCES)  
  # The [1] subscripts pick off the lower confidence interval
  lowerCES <- data.frame(phi = ciCES["phi","2.5%"], alpha = alphaCICES[1], 
                         beta = ciCES["beta", "2.5%"], zeta = ciCES["zeta", "2.5%"],
                         lambda_L = ciCES["lambda_L", "2.5%"], lambda_E = ciCES["lambda_E", "2.5%"])
  row.names(lowerCES) <- "- 95% CI"
  # The [2] subscripts pick off the lower confidence interval
  upperCES <- data.frame(phi = ciCES["phi","97.5%"], alpha = alphaCICES[2], 
                         beta = ciCES["beta", "97.5%"], zeta = ciCES["zeta", "97.5%"],
                         lambda_L = ciCES["lambda_L", "97.5%"], lambda_E = ciCES["lambda_E", "97.5%"])
  row.names(upperCES) <- "+ 95% CI"
  
  # Now create the data for a table.
  dataCES <- rbind(upperCES, estCES, lowerCES)
  print(dataCES)
  return(dataCES)

  #xyplot( resid(modelCESQ) ~ fitted(modelCESQ) )
  #histogram( ~resid(modelCESQ) )
  #qqmath( ~resid(modelCESQ) )
}

####################################
# Creates a LaTeX printable table from the CES data. This function first calls cesData.
#
# countryName is a string containint the 2-letter abbreviation for the country, e.g. "US" or "CN"
# energyType is a string to be used in table captions reprsenting the type of energy. Typically, "Q", "X", or "U"
#
# returns a printable LaTeX table from xtable.
##
cesTable <- function(countryName, energyType){
  dataCESe <- cesData(countryName, energyType)
  tableCESq <- xtable(dataCESe, caption=paste(countryName, ", 1980-2011.", sep=""), digit = c(4, 1, 2, 2, 6, 5, 5))
}
@

\subsection{CES with $Q$}
<<CESq analysisQ, eval=FALSE>>=
countryName <- "US"
energyType <- "Q"
tableCESq <- cesTable(countryName, energyType)

#CESqTables <- lapply(countryAbbrevs, cesTable, energyType="Q")
@

<<CESq Results, results='asis', eval=FALSE>>=
print(tableCESq, caption.placement="top")

#print(CESqTables[["US"]], caption.placement="top")
#print(CESqTables[["ZA"]], caption.placement="top")
@

%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}

%% References
%%
%% Following citation commands can be used in the body text:
%%
%%  \citet{key}  ==>>  Jones et al. (1990)
%%  \citep{key}  ==>>  (Jones et al., 1990)
%%
%% Multiple citations as normal:
%% \citep{key1,key2}         ==>> (Jones et al., 1990; Smith, 1989)
%%                            or  (Jones et al., 1990, 1991)
%%                            or  (Jones et al., 1990a,b)
%% \cite{key} is the equivalent of \citet{key} in author-year mode
%%
%% Full author lists may be forced with \citet* or \citep*, e.g.
%%   \citep*{key}            ==>> (Jones, Baker, and Williams, 1990)
%%
%% Optional notes as:
%%   \citep[chap. 2]{key}    ==>> (Jones et al., 1990, chap. 2)
%%   \citep[e.g.,][]{key}    ==>> (e.g., Jones et al., 1990)
%%   \citep[see][pg. 34]{key}==>> (see Jones et al., 1990, pg. 34)
%%  (Note: in standard LaTeX, only one note is allowed, after the ref.
%%   Here, one note is like the standard, two make pre- and post-notes.)
%%
%%   \citealt{key}          ==>> Jones et al. 1990
%%   \citealt*{key}         ==>> Jones, Baker, and Williams 1990
%%   \citealp{key}          ==>> Jones et al., 1990
%%   \citealp*{key}         ==>> Jones, Baker, and Williams, 1990
%%
%% Additional citation possibilities
%%   \citeauthor{key}       ==>> Jones et al.
%%   \citeauthor*{key}      ==>> Jones, Baker, and Williams
%%   \citeyear{key}         ==>> 1990
%%   \citeyearpar{key}      ==>> (1990)
%%   \citetext{priv. comm.} ==>> (priv. comm.)
%%   \citenum{key}          ==>> 11 [non-superscripted]
%% Note: full author lists depends on whether the bib style supports them;
%%       if not, the abbreviated list is printed even when full requested.
%%
%% For names like della Robbia at the start of a sentence, use
%%   \Citet{dRob98}         ==>> Della Robbia (1998)
%%   \Citep{dRob98}         ==>> (Della Robbia, 1998)
%%   \Citeauthor{dRob98}    ==>> Della Robbia


%% References with bibTeX database:

\bibliographystyle{model2-names}
\bibliography{<your-bib-database>}

%% Authors are advised to submit their bibtex database files. They are
%% requested to list a bibtex style file in the manuscript if they do
%% not want to use model2-names.bst.

%% References without bibTeX database:

% \begin{thebibliography}{00}

%% \bibitem must have one of the following forms:
%%   \bibitem[Jones et al.(1990)]{key}...
%%   \bibitem[Jones et al.(1990)Jones, Baker, and Williams]{key}...
%%   \bibitem[Jones et al., 1990]{key}...
%%   \bibitem[\protect\citeauthoryear{Jones, Baker, and Williams}{Jones
%%       et al.}{1990}]{key}...
%%   \bibitem[\protect\citeauthoryear{Jones et al.}{1990}]{key}...
%%   \bibitem[\protect\astroncite{Jones et al.}{1990}]{key}...
%%   \bibitem[\protect\citename{Jones et al., }1990]{key}...
%%   \harvarditem[Jones et al.]{Jones, Baker, and Williams}{1990}{key}...
%%

% \bibitem[ ()]{}

% \end{thebibliography}

\end{document}

%%
%% End of file `elsarticle-template-2-harv.tex'.