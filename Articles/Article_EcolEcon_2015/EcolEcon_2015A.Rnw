
\Sexpr{set_parent('Paper0/Paper0-Resampling.Rnw')}

\section{Begin EcolEcon2015A}

<<setup, echo=FALSE, message=FALSE, eval=TRUE, warning=FALSE>>=
library(EconData)
library(EconModels)
library(dplyr)
library(reshape2)
library(ggplot2)
library(mosaic)
library(xtable)
library(knitr)
library(texreg)
library(tidyr)
library(scales)
library(tidyr)
library(nlme)


# Tell whether to re-run the analysis to create the models
# or the resampling on the (kl)e models.
# This file will use previously-saved models and resampling to generate
# the paper if set to FALSE, greatly reducing time.
# If something changes in the data or in the code that
# performs the analysis or resampling, set 
# rerunModels = TRUE
# rerunResampling = TRUE
# once to re-generate the information needed to 
# create the paper.
# ********************************************************
rerunCESModels=FALSE
rerunResampling=FALSE
nResamples <- 100 # Number of resamples
# ********************************************************
opts_chunk$set(
  # ********************************************************
  eval=TRUE,
  include = FALSE,
  # ********************************************************
  # tikz allows LaTeX code in graphical output. 
  # E.g., "$y$" for a variable name in the legend for a graph.  
  # dev='tikz',
  tidy=FALSE,
  comment=NA,
  # Tells whether to cache output from chunks are saved. Cacheing saves time. 
  # However, references to LaTeX tables DO NOT WORK if cacheing is turned on.
  cache=FALSE,
  warning=FALSE,  #Tells whether to show warnings in the output.
  # Turns off messages for all chunks. 
  # Set TRUE on an individual chunk to see it.
  message=FALSE, 
  # Tells whether to echo code for all chunks. 
  # Set TRUE on an individual chunk to see its code.
  echo=FALSE,
  # Sets all table captions to the top.
  xtable.caption.placement="top"
)
@

<<myXTable>>=
myXTable <- function(data, caption, label, digits=2){
  table <- xtable(data, caption=caption, label=label, digits=digits)
  print(table, 
        caption.placement="top", 
        size="\\tiny", 
        include.rownames=FALSE, 
        math.style.negative=TRUE, 
        sanitize.text.function=function(x){x},
        booktabs=TRUE)
}
@

<<model_points_style>>=
model_points_style <- function(p) {
  p + 
  scale_colour_manual(values = c("gray70", "black")) +
  scale_size_manual(values = c(5, 3,3,3,3,3,3)) +
  # scale_alpha_manual(values = c(.2, .6,.6,.6,.6, .6, .6)) +
  scale_fill_manual(values = c(scales::alpha("gray50", .2), rep("transparent", 6))) +
  scale_shape_manual(values = c(21, 21, 23:27)) +
  guides( 
    col = guide_legend(override.aes = aes(size = 5, shape = 21)) )
}

model_points_style_quad <- function(p) {
  p + 
  # scale_colour_manual(values = c("gray70", "black")) +
  scale_size_manual(values = c(5, 3,3,3,3,3,3)) +
  # scale_alpha_manual(values = c(.2, .6,.6,.6,.6, .6, .6)) +
  scale_fill_manual(values = c(scales::alpha("gray50", .2), rep("transparent", 6))) +
  scale_shape_manual(values = c(21, 21, 23:27)) +
  theme(legend.title=element_blank())
}
@


<<Formulas>>=
# Set up the formulas for each type of analysis.
# These formulas contain energy. 
# We can use keep_summands to drop the energy term (3rd summand on the rhs)
# later if needed.
formulas <- 
  list( 
    PT = c(unadjusted = build_formula("iGDP", list("iKstkS.L", "iL", "iXpMP", "iYear")),
             adjusted = build_formula("iGDP", list("iKservS.L", "ihLest", "iUMP", "iYear"))),
    UK = c(unadjusted = build_formula("iGDP", list("iKstkO.WwithRD", "iL", "iXp", "iYear")),
             adjusted = build_formula("iGDP", list("iKservO.WwithRD", "ihLest", "iU", "iYear")))
  )
countries <- names(formulas)
flavors <- names(formulas$PT)
@

<<Data>>=
# Create the HistoricalData data frames
commonVars <- c("Year", "Country", "Source")
HistoricalData <- list(
  PT =  IST %>% 
    filter(Country == "PT"), 
  UK = Leeds %>% 
    filter(Country == "UK") 
)

# Load historical cost shares
CostShares <- read.table(file.path("cost_shares", "Cost_Shares_PT_UK.txt"), header=TRUE)
@


<<Models_Exp>>=
#
# Models that are exponential only, y = A * exp(lambda*t)
#
modelsExp <- list()
alphaExp <- 0
betaExp <- 0
gammaExp <- 0
for (country in countries){
  # Replace with better code later. 
  # Would like to say cdModel(formula, data, factorShares=c(alpha_1 = 0, alpha_2 = 0, alpha_3 = 0))
  # or something like that.
  form <- keep_summands(formulas[[country]][["unadjusted"]], n = c(-1, -2, -3)) # Keep none of the factors of production
  yVar <- as.name(summands(form, n=1, right=FALSE))
  tVar <- as.name(summands(form, n=1))
  data <- HistoricalData[[country]]
  expMod <- lm(log(eval(yVar)) ~ eval(tVar), data=data)
  attr(expMod, "naturalCoeffs") <- data.frame(lambda=coef(expMod)[[2]],
                                              logscale=coef(expMod)[[1]], 
                                              scale=exp(coef(expMod)[[1]]),
                                              alpha_1=alphaExp,
                                              alpha_2=betaExp, 
                                              alpha_3=gammaExp)
  expMod$formula <- form
  sdata <- subset(data, select=all.vars(form))
  sdata <- data[complete.cases(sdata), unique(c(all.vars(form), names(data)))]
  expMod$data <- sdata
  expMod$response <- sdata$iGDP 
  modelsExp[[country]] <- expMod
}

@


<<Models_CSP>>=
#
# Models that adhere to the cost-share principle
# 
modelsCSP <- list()
# Output elasticities based on cost share principle
alphaCSP <- 0.3 # Fraction of national accounts spent on capital
betaCSP <- 0.7 # Fraction of national accounts spent on labor
gammaCSP <- 0.0
for (country in countries){
  for (adj in c("unadjusted", "adjusted")){
    
    # Cobb-Douglas 
    
    # Pull variables out of the formulas for use in fitting the model.
    form <- keep_summands(formulas[[country]][[adj]], n=-3) # Remove energy
    yVar <- as.name(summands(form, n=1, right=FALSE))
    kVar <- as.name(summands(form, n=1))
    lVar <- as.name(summands(form, n=2))
    tVar <- as.name(summands(form, n=3))
    data <- HistoricalData[[country]]
    formula <- substitute(
      log(Y) - (alpha_1 * log(K) + alpha_2 * log(L)) ~ T,
      list( Y = yVar, K = kVar, L = lVar, T = tVar)
    )
    # Cobb-Douglas
    cdModCSP <- 
      eval(substitute( 
        plm(formula, data = data, params = c(alpha_1 = alphaCSP, alpha_2 = betaCSP, alpha_3 = gammaCSP), 
            optimize = FALSE),
        list(formula = formula)))
    
    # convert hand-fit object into a CDEmodel object
    names(cdModCSP$coefficients)[1:2] <- c("logscale", "lambda")
    class(cdModCSP) <- c("CDEmodel", class(cdModCSP))
    cdModCSP$formula <- form
    sdata <- subset(data, select=all.vars(form))
    sdata <- data[complete.cases(sdata), unique(c(all.vars(form), names(data)))]
    cdModCSP$data <- sdata
    cdModCSP$response <- sdata$iGDP
    cdModCSP$handcrafted <- TRUE
    
    # store the result in our list
    modelsCSP[[country]][[adj]][["noE"]][["CD"]] <- cdModCSP
    
    # CES
    
    # The only CES models that can adhere to the CSP are models where
    # alpha values are constant with respect to time. 
    # I.e., models where energy is not included AND where rho_1 = 0.
    # CES models where rho_1 = 0 are the Cobb-Douglas model.
    # Convienently, we previously fit that model 
    # with the required output elasticities.
    cesModCSP <- cdModCSP
    
    cesModCSP$coefficients <- 
      c(cesModCSP$coefficients, 
        c(delta_1 = as.vector(cesModCSP$coefficients["alpha_1"]),
          delta = 1,
          rho_1 = 0,
          rho = NA)
      )
    cesModCSP$handcrafted <- TRUE
    class(cesModCSP) <- setdiff(c("cesModel", class(cesModCSP)), "CDEmodel")
    modelsCSP[[country]][[adj]][["noE"]][["CES"]][["kl"]] <- cesModCSP
  }
}

@


<<Models_CD>>=
#
# Cobb-Douglas models
#
models <- list()

for(country in countries){
  for (flavor in flavors){
    fnoE <- keep_summands(formulas[[country]][[flavor]], -3) # Drop the energy term (3rd term on RHS)
    fwithE <- formulas[[country]][[flavor]]
    models[[country]][[flavor]][["noE"]][["CD"]]   <- cdModel(fnoE, data = HistoricalData[[country]])
    models[[country]][[flavor]][["withE"]][["CD"]] <- cdModel(fwithE, data = HistoricalData[[country]])
  }
}
@

<<Models_CES>>=
#
# CES models
#
fileNameCES <- "EcolEcon2015ModelsCES.rds"
if (!rerunCESModels){
  # Load CES models from the file on disk
  models <- readRDS(fileNameCES)
} else {
  # Re-fit CES models
  for(country in countries){
    for (flavor in flavors){
      fnoE <- keep_summands(formulas[[country]][[flavor]], -3) # Drop the energy term (3rd term on RHS)
      fwithE <- formulas[[country]][[flavor]]
      models[[country]][[flavor]][["noE"]][["CES"]][["kl"]] <- cesModel(fnoE, 
                                                                        data = HistoricalData[[country]], 
                                                                        nest=c(1,2), digits = 10)
      nestsWithE <- list(kle=c(1,2,3), lek=c(2,3,1), ekl=c(3,1,2))
      models[[country]][[flavor]][["withE"]][["CES"]] <- lapply(nestsWithE, function(nest){
          cesModel(formula=fwithE, data=HistoricalData[[country]], nest=nest, digits = 10)
        })
    }      
  }
  # Save models to disk.
  saveRDS(models, file=fileNameCES)  
}
@


<<AllCoeffs>>=
model2df <- function(mod, id){
  # Parse the id to find out whether this is quality-adjusted data, etc.
  id_components <- strsplit(id, split = "[.]")[[1]]
  
  data_frame(
    Country = id_components[1], 
    flavor  = ifelse(id_components[2]=="unadjusted", "Unadjusted", "Quality-adjusted"),
    energy  = ifelse(id_components[3]=="noE", "Without energy", "With energy"),
    model   = id_components[4], 
    nest    = id_components[5]) %>%  
  cbind(naturalCoef(mod)) %>% 
  cbind(data.frame(sse = sum(resid(mod)^2)))
} 

# Put all exponential model coefficients into a data frame
AllCoeffsExp <- 
  leaf_apply(modelsExp, class = c("lm"), f = model2df) %>%
  bind_rows() %>%
  mutate(model = "exp", CSP = NA)  

# Put all the cost-share principle (CSP) model coefficients into a data frame
AllCoeffsCSP <- 
  leaf_apply(modelsCSP, class = c("lm"), f = model2df) %>% 
  bind_rows() %>%
  mutate(CSP = "w/ CSP")

# Put all CD and CES model coefficients into a data frame.  
AllCoeffsNoCSP <- 
  leaf_apply(models, class = c("CDEmodel", "cesModel", "LINEXmodel"), f = model2df) %>%
  bind_rows() %>%
  mutate(CSP="w/o CSP")

AllCoeffs <- bind_rows(AllCoeffsExp, AllCoeffsCSP, AllCoeffsNoCSP)

AllCoeffs <-
  AllCoeffs %>% 
  mutate( 
    nest = ifelse(is.na(nest), "", nest),
    CSP = ifelse( CSP == "w/ CSP", "w/ CSP", "w/o CSP")
    )

# Relevel factors and re-order data
AllCoeffs <- 
  AllCoeffs %>%
  mutate(
    Country = relevelFactor(factor(Country), c("PT", "UK")),
    flavor = relevelFactor(factor(flavor), c("Unadjusted", "Quality-adjusted")),
    energy = relevelFactor(factor(energy), c("Without energy", "With energy")),
    model = relevelFactor(factor(model), c("exp", "CD", "CES")),
    nest = relevelFactor(factor(nest), c("kl", "kle", "lek", "ekl")),
    CSP = relevelFactor(factor(CSP), c("w/ CSP", "w/o CSP"))
  ) %>% 
  arrange(Country, model, flavor, energy, nest, CSP)
@


<<output-elasticity>>=
mod2oedf <- function(mod, id){
  # Parse the id to find out whether this is quality-adjusted data, etc.
  id_components <- strsplit(id, split = "[.]")[[1]]
  
  if (! inherits(mod, "cesModel") ) return(NULL)
  
  fortify(mod) %>%
    mutate(
      Country = id_components[1], 
      flavor  = ifelse(id_components[2]=="unadjusted", "Unadjusted", "Quality-adjusted"),
      energy  = ifelse(id_components[3]=="noE", "Without energy", "With energy"),
      model   = id_components[4], 
      nest    = id_components[5]
    ) 
} 

AllOE <- 
  leaf_apply(models, class = "cesModel", mod2oedf) %>% 
  bind_rows() %>%
  # None of "models" adheres to the CSP.
  mutate (CSP = "w/o CSP")

# Now append to AllOE time-varying output elasticities from models that adhere to the CSP.
AllOE <- leaf_apply(modelsCSP, class="cesModel", f=mod2oedf) %>% 
  bind_rows() %>%
  mutate (CSP = "w/ CSP") %>%
  bind_rows(AllOE, .)

@


<<Resampling-CD>>=
resampleCoeffsCDFilename <- "EcolEcon2015ResampleCoeffsCD.rds"
resampleModelsCDFilename <- "EcolEcon2015ResampleModelsCD.rds"
if (rerunResampling){
  resamplesCD <- leaf_apply(models, class = "CDEmodel", f = function(model, id){
    id_components <- strsplit(id, split = "[.]")[[1]]
    print(id_components)
    resamples <- resampledFits(model, method = "wild", n = nResamples)
    resamples$coeffs <- mutate(
      resamples$coeffs, 
      Country = id_components[[1]],
      flavor = id_components[[2]],
      energy = id_components[[3]],
      model = id_components[[4]]
    )
    return(resamples)
  })
  # Resample coefficients
  resampleCoeffsCD <- lapply(resamplesCD, function(resample){
    resample$coeffs
  }) %>% plyr::rbind.fill()
  saveRDS(resampleCoeffsCD, resampleCoeffsCDFilename)
  # Resample models
  # At present these resample models are stored in a "flat" list.
  # We may want to change that later.
  resampleModelsCD <- lapply(resamplesCD, function(resample){
    resample$models
  })
  saveRDS(resampleModelsCD, resampleModelsCDFilename)
} else {
  resampleCoeffsCD <- readRDS(resampleCoeffsCDFilename)
  resampleModelsCD <- readRDS(resampleModelsCDFilename)
}
@


<<Resampling-CES-adjusted-kle>>=
print("Top of Resampling-CES-adjusted-kle")

resampleCoeffsCESFilename <- "EcolEcon2015kleResampleCoeffsCES.rds"
resampleModelsCESFilename <- "EcolEcon2015kleResampleModelsCES.rds"
if (rerunResampling){
  # Run some resampling on the PT and UK models that reject the cost-share theorem,
  # include energy, use quality-adjusted variables, and employ the (kl)e nesting.
  # This is u-g-l-y code. Just getting something running for now.
  modPT <- models$PT$adjusted$withE$CES$kle
  modUK <- models$UK$adjusted$withE$CES$kle
  resamplesCESPT <- resampledFits(modPT, method = "wild", n = nResamples)
  resamplesCESUK <- resampledFits(modUK, method = "wild", n = nResamples)
  # Resample coefficients
  resampleCoeffsCES <- rbind(cbind(resamplesCESPT$coeffs, Country="PT"), cbind(resamplesCESUK$coeffs, Country="UK"))
  resampleCoeffsCES$energy <- TRUE
  resampleCoeffsCES$nest <- "(kl)e"
  saveRDS(resampleCoeffsCES, file = resampleCoeffsCESFilename)
  # Resample models
  resampleModelsCES <- list(PT=resamplesCESPT$models, UK=resamplesCESUK$models)
  saveRDS(resampleModelsCES, file = resampleModelsCESFilename)
} else {
  resampleCoeffsCES <- readRDS(resampleCoeffsCESFilename)
  resampleModelsCES <- readRDS(resampleModelsCESFilename)
}
@


<<ReModels>>=
ReModels <-
  bind_rows(
  leaf_apply(resampleModelsCES, 
             function(x,id) {mod2oedf(x, id) %>% mutate(id = id)},
             strict.lists = TRUE)
)
@


<<FittedAndResiduals>>=
temp_data_exp <- 
  leaf_apply(
    modelsExp, class=c("lm"), 
    f = function(model, id){
      out <- model$dat %>% 
        select(Year, Country) %>%
        mutate(
          Country = as.character(Country),  # to avoid warning about unmatched levels of factors
          fitted = exp(fitted(model)), # exp accounts for the fact that the model was fitted in log space.
          residuals = resid(model), 
          model = "exp"
        )
        # Now add the response, using the original variable name.
      out[[summands(model$formula, right = FALSE)]] <- exp(response(model)[c(1:length(out$Year))])
      return(out)
    }
  ) %>% 
  bind_rows()

function_that_was_here_before <- function(model, id){
  id_list <- strsplit(id, split = "[.]")[[1]]
  out <- model$data %>% 
    select(Year) %>%
    mutate(
      # By including [c(1:length(df$Year))] on the end, we 
      # add NAs (as appropriate) to the end of these columns
      # if data do not exist.
      fitted = yhat(model)[c(1:length(Year))],
      residuals = resid(model)[c(1:length(Year))],
      Country = id_list[[1]],
      flavor = ifelse (id_list[[2]] ==  "unadjusted", "Unadjusted", "Quality-adjusted"),
      energy = ifelse(id_list[[3]] == "noE", "Without energy", "With energy"),
      model = id_list[[4]],
      nest = ifelse (length(id_list) > 4, id_list[[5]], NA)
    )
  # Now add the response, using the original variable name.
  out[[summands(model$formula, right = FALSE)]] <- response(model)[c(1:length(out$Year))]
  return(out)  
}

temp_data_CSP <- 
  leaf_apply(modelsCSP, class=c("plm", "lm"), function_that_was_here_before) %>% 
  bind_rows() %>%
  mutate(CSP = "w/ CSP")

temp_data_noCSP <- 
  leaf_apply(models, class=c("CDEmodel", "cesModel", "LINEXmodel"), function_that_was_here_before) %>% 
  bind_rows() %>%
  mutate(CSP = "w/o CSP")

FittedAndResid <- plyr::rbind.fill(temp_data_exp, temp_data_CSP, temp_data_noCSP)

@



<<TableData>>=
  TableData <- 
  AllCoeffs %>%
  plyr::rename(c(model = "Model", energy = "Energy", nest = "Nest")) %>%
  mutate(Nest = 
           plyr::mapvalues(
             Nest,
             from=c("kl", "kle", "lek", "ekl"),
             to=c("$kl$", "$(kl)e$", "$(le)k$", "$(ek)l$")),
         CSP =  
           plyr::mapvalues(
             CSP, 
             from=c("w/ CSP", "w/o CSP"), 
             to=c("Adhere", "Reject")),
         Energy =
           plyr::mapvalues(
             Energy, 
             from=c("Without energy", "With energy"), 
             to=c("Without", "With")),
         Model = 
           plyr::mapvalues(
             Model, 
             from=c("exp"), 
             to=c("Ref."))
  )
@


<<Historical_Plot>>=
leaf_apply(formulas, class = "formula", f=function(form, id){
  meta <- strsplit(id, split="[.]")[[1]]
  Country <- meta[1]
  flavor <- meta[2]
  measure.vars <- c(summands(form, right=FALSE), summands(form, 1:3))
  # Trim to avoid plotting data which are unused for one coutry but included for the other.
  trimmed_historical_data <- HistoricalData[[Country]][c("Year", measure.vars)]
  
  melt(
    trimmed_historical_data, 
    measure.vars = measure.vars, 
    value.name = "value",
    variable.name = "variable") %>%
    mutate(
      variable = as.character(variable), # eliminate factors, which cause warnings with bind_rows() below.
      Country = Country,
      flavor =  ifelse (flavor == "adjusted", "Quality-adjusted", "Unadjusted")
    )
}
) %>% bind_rows() %>%
  
  mutate( 
    # Change variable names to make a nicer-looking graph and relevel factors before plotting
    variable = plyr::mapvalues(variable,
                               from=c("iGDP", 
                                      "iKstkS.L", "iKservS.L", "iKstkO.WwithRD", "iKservO.WwithRD",
                                      "iL", "ihLest",
                                      "iXpMP", "iXp", "iUMP", "iU"),
                               to=c("y", 
                                    "k", "k", "k", "k",
                                    "l", "l",
                                    "e", "e", "e", "e")),
    Country = relevelFactor(factor(Country), c("PT", "UK")), # Adjusts facet order
    flavor = relevelFactor(factor(flavor), c("Unadjusted", "Quality-adjusted")), # Adjusts facet order
    variable = relevelFactor(factor(variable), c("y", "k", "l", "e"))
  ) %>%
  
  ggplot() + 
  geom_line(aes(x=Year, y=value, group=variable, linetype=variable, colour=variable, size=variable)) +
  facet_grid(flavor ~ Country) + 
  scale_color_manual(name = "", values=c("black", "black", "black", "gray70")) +
  scale_linetype_manual(name="", values=c(1,2,3,1)) + 
  scale_size_manual(name="", values = c(1, 0.9, 0.9, 0.6)) +
  scale_y_continuous(breaks=c(1, 2, 4, 6, 8, 10, 12), limits=c(0.5, 12)) +
  xlab("") + 
  ylab("Indexed (1960=1)") +
  xy_theme()
@


<<Other_Models, eval=FALSE>>=
# These models were estimated and the results sent to Paul Brockway.
# At this point, there is no reason to estimate the modesl every time.

# PT, unadjusted kl, quality-adjusted e
mod_PT_uakl_qae <- cesModel(iGDP ~ iKstkS.L + iL + iUMP + iYear, HistoricalData$PT, nest=c(1,2,3))
# PT, quality-adjusted kl, unadjusted e
mod_PT_qakl_uae <- cesModel(iGDP ~ iKservS.L + ihLest + iXpMP + iYear, HistoricalData$PT, nest=c(1,2,3))

# UK, unadjusted kl, quality-adjusted e
mod_UK_uakl_qae <- cesModel(iGDP ~ iKstkO.WwithRD + iL + iU + iYear, HistoricalData$UK, nest=c(1,2,3))
# UK, quality-adjusted kl, unadjusted e
mod_UK_qakl_uae <- cesModel(iGDP ~ iKservO.WwithRD + ihLest + iXp + iYear, HistoricalData$UK, nest=c(1,2,3))
@


\section{End EcolEcon2015A}
