
\Sexpr{set_parent('Paper0/Paper0-Resampling.Rnw')}

\section{Begin EcolEcon2015A}

<<setup, echo=FALSE, message=FALSE, eval=TRUE, warning=FALSE>>=
library(EconData)
library(EconModels)
library(dplyr)
library(reshape2)
library(ggplot2)
library(mosaic)
library(xtable)
library(knitr)
library(texreg)
library(tidyr)
library(scales)
library(tidyr)
library(nlme)


# Tell whether to re-run the analysis to create the models
# or the resampling on the (kl)e models.
# This file will use previously-saved models and resampling to generate
# the paper if set to FALSE, greatly reducing time.
# If something changes in the data or in the code that
# performs the analysis or resampling, set 
# rerunModels = TRUE
# rerunResampling = TRUE
# once to re-generate the information needed to 
# create the paper.
# ********************************************************
rerunModels=FALSE
rerunResampling=FALSE
nResamples <- 100 # Number of resamples
# ********************************************************
opts_chunk$set(
  # ********************************************************
  eval=TRUE,
  include = FALSE,
  # ********************************************************
  # tikz allows LaTeX code in graphical output. 
  # E.g., "$y$" for a variable name in the legend for a graph.  
  # dev='tikz',
  tidy=FALSE,
  comment=NA,
  # Tells whether to cache output from chunks are saved. Cacheing saves time. 
  # However, references to LaTeX tables DO NOT WORK if cacheing is turned on.
  cache=FALSE,
  warning=FALSE,  #Tells whether to show warnings in the output.
  # Turns off messages for all chunks. 
  # Set TRUE on an individual chunk to see it.
  message=FALSE, 
  # Tells whether to echo code for all chunks. 
  # Set TRUE on an individual chunk to see its code.
  echo=FALSE,
  # Sets all table captions to the top.
  xtable.caption.placement="top"
)

# This function is used in many places below.
### That's nice.  I assume that's why you wrote a function.  But what does it DO?
@

<<myXTable>>=
myXTable <- function(data, caption, label, digits=2){
  table <- xtable(data, caption=caption, label=label, digits=digits)
  print(table, 
        caption.placement="top", 
        size="\\tiny", 
        include.rownames=FALSE, 
        math.style.negative=TRUE, 
        sanitize.text.function=function(x){x},
        booktabs=TRUE)
}
@

<<model_points_style>>=
model_points_style <- function(p) {
  p + 
  scale_colour_manual(values = c("gray70", "black")) +
  scale_size_manual(values = c(5, 3,3,3,3,3,3)) +
  # scale_alpha_manual(values = c(.2, .6,.6,.6,.6, .6, .6)) +
  scale_fill_manual(values = c(scales::alpha("gray50", .2), rep("transparent", 6))) +
  scale_shape_manual(values = c(21, 21, 23:27)) +
  guides( 
    col = guide_legend(override.aes = aes(size = 5, shape = 21)) )
}

model_points_style_quad <- function(p) {
  p + 
  # scale_colour_manual(values = c("gray70", "black")) +
  scale_size_manual(values = c(5, 3,3,3,3,3,3)) +
  # scale_alpha_manual(values = c(.2, .6,.6,.6,.6, .6, .6)) +
  scale_fill_manual(values = c(scales::alpha("gray50", .2), rep("transparent", 6))) +
  scale_shape_manual(values = c(21, 21, 23:27)) +
  theme(legend.title=element_blank())
}
@


<<Formulas>>=
# Set up the formulas for each type of analysis.
# These formulas contain energy. 
# We can use keep_summands to drop the energy term (3rd summand on the rhs)
# later if needed.
formulas <- 
  list( 
    PT = c(unadjusted = build_formula("iGDP", list("iKstkS.L", "iL", "iXpMP", "iYear")),
             adjusted = build_formula("iGDP", list("iKservS.L", "ihLest", "iUMP", "iYear"))),
    UK = c(unadjusted = build_formula("iGDP", list("iKstkO.WwithRD", "iL", "iXp", "iYear")),
             adjusted = build_formula("iGDP", list("iKservO.WwithRD", "ihLest", "iU", "iYear")))
  )
countries <- names(formulas)
flavors <- names(formulas$PT)
@

<<Data>>=
# Create the historicalData data frames
### If we need to select variables, we can do that.  Unfortunately, select() and select_() don't do
### what we would like here (they don't accept a vector of character strings), so we'd have to use
### something else.  I've kept the fake select_() command here just to record what was done earlier.

commonVars <- c("Year", "Country", "Source")
historicalData <- list(
  PT =  IST %>% 
    filter(Country == "PT"), 
    #  %>% select_(unique(c(commonVars, all.vars(formulas$PT$unadjusted), all.vars(formulas$PT$adjusted)))),
  UK = Leeds %>% 
    filter(Country == "UK") 
    # %>% select_(unique(c(commonVars, all.vars(formulas$UK$unadjusted), all.vars(formulas$UK$adjusted))))
)

# Load historical cost shares
CostShares <- read.table(file.path("cost_shares", "Cost_Shares_PT_UK.txt"), header=TRUE)
@


<<Models_CSP>>=
fileNameCSP <- "EcolEcon2015ModelsCSP.rds"
if (!rerunModels){
  # load from the file on disk
  modelsCSP <- readRDS(fileNameCSP)
} else {
  #
  # Models that adhere to the cost-share theorem
  # 
  
  modelsCSP <- list()
  # Output elasticities based on cost share principle
  alphaCSP <- 0.3 # Fraction of national accounts spent on capital
  betaCSP <- 0.7 # Fraction of national accounts spent on labor
  for (country in countries){
    for (adj in c("unadjusted", "adjusted")){
      # Replace with better code later. 
      # Would like to say cdModel(formula, data, factorShares=c(alpha_1 = 0.3, alpha_2 = 0.7, alpha_3 = 0))
      # or something like that.
      form <- keep_summands(formulas[[country]][[adj]], n=-3) # Remove energy
      yVar <- as.name(summands(form, n=1, right=FALSE))
      kVar <- as.name(summands(form, n=1))
      lVar <- as.name(summands(form, n=2))
      tVar <- as.name(summands(form, n=3))
      data <- historicalData[[country]]
      formula <- substitute(
        log(Y) - (alpha_1 * log(K) + alpha_2 * log(L)) ~ T,
        list( Y = yVar, K = kVar, L = lVar, T = tVar, A = alphaCSP, B = betaCSP)
      )
      # Cobb-Douglas
      cdModCSP <- 
        eval(substitute( 
          plm(formula, data = data, params = c(alpha_1 = 0.3, alpha_2 = 0.7, alpha_3 = 0.0), 
              optimize = FALSE),
          list(formula = formula)))
      
      # convert hand-fit object into a CDEmodel object
      names(cdModCSP$coefficients)[1:2] <- c("logscale", "lambda")
      class(cdModCSP) <- c("CDEmodel", class(cdModCSP))
      cdModCSP$formula <- form
      sdata <- subset(data, select=all.vars(form))
      sdata <- data[complete.cases(sdata), unique(c(all.vars(form), names(data)))]
      cdModCSP$data <- sdata
      cdModCSP$response <- sdata$iGDP
      cdModCSP$handcrafted <- TRUE
      
      # store the result in our list
      modelsCSP[[country]][[adj]][["noE"]][["CD"]] <- cdModCSP
      # CES
      # The only CES models that can adhere to the CSP are models where
      # alpha values are constant with respect to time. 
      # I.e., models where energy is not included AND where rho_1 = 0.
      # CES models where rho_1 = 0 are the Cobb-Douglas model.
      # Convienently, we previously fit that model.
      cesModCSP <- cdModCSP
      
      cesModCSP$coefficients <- 
        c(cesModCSP$coefficients, 
          c(delta_1 = cesModCSP$coefficients["alpha_1"],
            delta = 0,
            rho_1 = 0,
            rho = NA)
        )
      cesModCSP$handcrafted <- TRUE
      class(cesModCSP) <- setdiff(c("cesModel", class(cesModCSP)), "CDEmodel")
      # # Again, we need a customized "naturalCoeffs" attribute so that 
      # # the "naturalCoef" function will do the right thing.
      # # "naturalCoeffs" can be based on the same "naturalCoeffs"
      # # from the Cobb-Douglas model, but a few additions are needed.
      # attr(cesModCSP, "naturalCoeffs") <- 
      #   naturalCoef(cdModCSP) %>%
      #   mutate(
      #     delta_1 = naturalCoef(cdModCSP)[["alpha_1"]],
      #     delta = 1,
      #     rho_1 = 0, 
      #     rho = NA,
      #     sigma_1 = 1,
      #     sigma_12 = 1,
      #     sigma = NA,
      #     sigma_12_3 = NA
      #   )
      # # Add output elasticities (as a function of time) to this model.
      # # This would have been done by a "fortify" function, 
      # # but this is not a typical CES model, so we can't "fortify" it.
      # # Add other metadata, too.
      # cesModCSP$data <- cesModCSP$data %>%
      #   mutate(
      #     oe1 = alphaCSP,
      #     oe2 = betaCSP,
      #     oe3 = 0,
      #     Country = country, 
      #     flavor  = ifelse(adj=="unadjusted", "Unadjusted", "Quality-adjusted"),
      #     energy  = "Without energy",
      #     model   = "CES", 
      #     nest    = "kl",
      #     CSP     = "w/ CSP"
      #   )
      modelsCSP[[country]][[adj]][["noE"]][["CES"]][["kl"]] <- cesModCSP
    }
  }
  # Save cost-share theorem models to disk.
  saveRDS(modelsCSP, file=fileNameCSP)
}

@


<<Models_Exp>>=
fileNameExp <- "EcolEcon2015ModelsExp.rds"
if (!rerunModels){
  # load from the file on disk
  modelsExp <- readRDS(fileNameExp)
} else {
  #
  # Models that are exponential only, y = A * exp(lambda*t)
  #
  modelsExp <- list()
  alphaExp <- 0
  betaExp <- 0
  gammaExp <- 0
  for (country in countries){
    # Replace with better code later. 
    # Would like to say cdModel(formula, data, factorShares=c(alpha_1 = 0, alpha_2 = 0, alpha_3 = 0))
    # or something like that.
    form <- keep_summands(formulas[[country]][["unadjusted"]], n = c(-1, -2, -3)) # Keep none of the factors of production
    yVar <- as.name(summands(form, n=1, right=FALSE))
    tVar <- as.name(summands(form, n=1))
    data <- historicalData[[country]]
    expMod <- lm(log(eval(yVar)) ~ eval(tVar), data=data)
    attr(expMod, "naturalCoeffs") <- data.frame(lambda=coef(expMod)[[2]],
                                                  logscale=coef(expMod)[[1]], 
                                                  scale=exp(coef(expMod)[[1]]),
                                                  alpha_1=alphaExp,
                                                  alpha_2=betaExp, 
                                                  alpha_3=gammaExp)
    expMod$formula <- form
    sdata <- subset(data, select=all.vars(form))
    sdata <- data[complete.cases(sdata), unique(c(all.vars(form), names(data)))]
    expMod$data <- sdata
    expMod$response <- sdata$iGDP 
    modelsExp[[country]] <- expMod
  }
  # Save exponential models to disk.
  saveRDS(modelsExp, file=fileNameExp)
}

@


<<Models_CDCES>>=
fileNameCDCES <- "EcolEcon2015ModelsCDCES.rds"
if (!rerunModels){
  # load from the file on disk
  models <- readRDS(fileNameCDCES)
} else {
  #
  # Models where all parameters are estimated (models don't adhere to the cost share theorem)
  #
  models <- list()
  for(country in countries){
    for (flavor in flavors){
      fnoE <- keep_summands(formulas[[country]][[flavor]], -3) # Drop the energy term (3rd term on RHS)
      fwithE <- formulas[[country]][[flavor]]
      # CD models
      models[[country]][[flavor]][["noE"]][["CD"]]   <- cdModel(fnoE, data = historicalData[[country]])
      models[[country]][[flavor]][["withE"]][["CD"]] <- cdModel(fwithE, data = historicalData[[country]])
      # CES models
      models[[country]][[flavor]][["noE"]][["CES"]][["kl"]] <- cesModel(fnoE, 
                                                                        data = historicalData[[country]], 
                                                                        nest=c(1,2), digits = 10)
      nestsWithE <- list(kle=c(1,2,3), lek=c(2,3,1), ekl=c(3,1,2))
      models[[country]][[flavor]][["withE"]][["CES"]] <- lapply(nestsWithE, function(nest){
          cesModel(formula=fwithE, data=historicalData[[country]], nest=nest, digits = 10)
        })
    }      
  }
  # Save models to disk.
  saveRDS(models, file=fileNameCDCES)  
}
@


<<AllCoeffs>>=
model2df <- function(mod, id){
  # Parse the id to find out whether this is quality-adjusted data, etc.
  ### Don't name non-lists with variables whose names sound like a list.
  ### I'm guessing you just didn't know what kind of data you were working with here. 
  ### Either way, it's a bad thing.
  id_components <- strsplit(id, split = "[.]")[[1]]
  
  # return this data frame 
  ### NOTE: ifelse() and [ ] handle NAs the way we want here
  ### The former use of [[ ]] was unnecessary and would break things in the new code
  ### I'm guessing you had [[ ]] because you thought you had a list when you did not.
  
  ### NOTE: data_frame does not auto-convert to factors.  It leaves things as strings.
  data_frame(
    Country = id_components[1], 
    flavor  = ifelse(id_components[2]=="unadjusted", "Unadjusted", "Quality-adjusted"),
    energy  = ifelse(id_components[3]=="noE", "Without energy", "With energy"),
    model   = id_components[4], 
    nest    = id_components[5]) %>%  
  cbind(naturalCoef(mod)) %>% 
  cbind(data.frame(sse = sum(resid(mod)^2)))
} 

### AH: So much tidier here :-)
### NOTE: dplyr::bind_rows() can replace plyr::rbind.fill() in most (all?) situations
###       plyr should probably not be used for data frame level operations anymore.

# Put all exponential model coefficients into a data frame
AllCoeffsExp <- 
  leaf_apply(modelsExp, class = c("lm"), f = model2df) %>%
  bind_rows() %>%
  mutate(model = "exp", CSP = NA)  

# Put all the cost-share principle (CSP) model coefficients into a data frame
AllCoeffsCSP <- 
  leaf_apply(modelsCSP, class = c("lm"), f = model2df) %>% 
  bind_rows() %>%
  mutate(CSP = "w/ CSP")

# Put all CD and CES model coefficients into a data frame.  
AllCoeffsNoCSP <- 
  leaf_apply(models, class = c("CDEmodel", "cesModel", "LINEXmodel"), f = model2df) %>%
  bind_rows() %>%
  mutate(CSP="w/o CSP")


AllCoeffs <- bind_rows(AllCoeffsExp, AllCoeffsCSP, AllCoeffsNoCSP)

AllCoeffs <-
  AllCoeffs %>% 
  mutate( 
    nest = ifelse(is.na(nest), "", nest),
    CSP = ifelse( CSP == "w/ CSP", "w/ CSP", "w/o CSP")
    )

# Relevel factors and re-order data
### NOTE:  Need to convert from strings to factors to use relevelFactor()
###        We could modify relevelFacotr() to accept character inputs
AllCoeffs <- 
  AllCoeffs %>%
  mutate(
    Country = relevelFactor(factor(Country), c("PT", "UK")),
    flavor = relevelFactor(factor(flavor), c("Unadjusted", "Quality-adjusted")),
    energy = relevelFactor(factor(energy), c("Without energy", "With energy")),
    model = relevelFactor(factor(model), c("exp", "CD", "CES")),
    nest = relevelFactor(factor(nest), c("kl", "kle", "lek", "ekl")),
    CSP = relevelFactor(factor(CSP), c("w/ CSP", "w/o CSP"))
  ) %>% 
  arrange(Country, model, flavor, energy, nest, CSP)
@


<<output-elasticity>>=
mod2oedf <- function(mod, id){
  # Parse the id to find out whether this is quality-adjusted data, etc.
  ### Don't name non-lists with variables whose names sound like a list.
  ### I'm guessing you just didn't know what kind of data you were working with here. 
  ### Either way, it's a bad thing.
  id_components <- strsplit(id, split = "[.]")[[1]]
  
  ### NOTE: data_frame does not auto-convert to factors.  It leaves things as strings.
  # message(class(mod))
  if (! inherits(mod, "cesModel") ) return(NULL)
  
  fortify(mod) %>%
    mutate(
      Country = id_components[1], 
      flavor  = ifelse(id_components[2]=="unadjusted", "Unadjusted", "Quality-adjusted"),
      energy  = ifelse(id_components[3]=="noE", "Without energy", "With energy"),
      model   = id_components[4], 
      nest    = id_components[5]
    ) 
} 

AllOE <- 
  leaf_apply(
    models, 
    class = "cesModel", 
    mod2oedf
  ) %>% 
  bind_rows() %>%
  # None of "models" adheres to the CSP.
  mutate (CSP = "w/o CSP")

# Now append to AllOE time-varying output elasticities from models that adhere to the CSP.
# These output elasticities are stored with variable names oe1, oe2, and oe3 in the data object in the models.
# See the <<Models_CSP>> chunk above.
# Uncomment when we're ready to add the CSP models to the alpha vs. time graph.

# AllOE <- leaf_apply(modelsCSP, class="lm", f=function(mod, id){
#   id_components <- strsplit(id, split = "[.]")[[1]]
#   if (id_components[4] == "CES") {
#     return(mod$data)
#   } else {
#     return(NULL)
#   }
# }) %>% 
#   do.call(plyr::rbind.fill, .) %>%
#   bind_rows(AllOE, .)

@

<<Resampling-CD>>=
print("Top of Resampling-CD")

resampleCoeffsCDFilename <- "EcolEcon2015ResampleCoeffsCD.rds"
resampleModelsCDFilename <- "EcolEcon2015ResampleModelsCD.rds"
if (rerunResampling){
  resamplesCD <- leaf_apply(models, class = "CDEmodel", f = function(model, id){
    id_components <- strsplit(id, split = "[.]")[[1]]
    print(id_components)
    resamples <- resampledFits(model, method = "wild", n = nResamples)
    resamples$coeffs <- mutate(
      resamples$coeffs, 
      Country = id_components[[1]],
      flavor = id_components[[2]],
      energy = id_components[[3]],
      model = id_components[[4]]
    )
    return(resamples)
  })
  # Resample coefficients
  resampleCoeffsCD <- lapply(resamplesCD, function(resample){
    resample$coeffs
  }) %>% plyr::rbind.fill()
  saveRDS(resampleCoeffsCD, resampleCoeffsCDFilename)
  # Resample models
  # At present these resample models are stored in a "flat" list.
  # We may want to change that later.
  resampleModelsCD <- lapply(resamplesCD, function(resample){
    resample$models
  })
  saveRDS(resampleModelsCD, resampleModelsCDFilename)
} else {
  resampleCoeffsCD <- readRDS(resampleCoeffsCDFilename)
  resampleModelsCD <- readRDS(resampleModelsCDFilename)
}
@

<<Resampling-CES-adjusted-kle>>=
print("Top of Resampling-CES-adjusted-kle")

resampleCoeffsCESFilename <- "EcolEcon2015kleResampleCoeffsCES.rds"
resampleModelsCESFilename <- "EcolEcon2015kleResampleModelsCES.rds"
if (rerunResampling){
  # Run some resampling on the PT and UK models that reject the cost-share theorem,
  # include energy, use quality-adjusted variables, and employ the (kl)e nesting.
  # This is u-g-l-y code. Just getting something running for now.
  modPT <- models$PT$adjusted$withE$CES$kle
  modUK <- models$UK$adjusted$withE$CES$kle
  resamplesCESPT <- resampledFits(modPT, method = "wild", n = nResamples)
  resamplesCESUK <- resampledFits(modUK, method = "wild", n = nResamples)
  # Resample coefficients
  resampleCoeffsCES <- rbind(cbind(resamplesCESPT$coeffs, Country="PT"), cbind(resamplesCESUK$coeffs, Country="UK"))
  resampleCoeffsCES$energy <- TRUE
  resampleCoeffsCES$nest <- "(kl)e"
  saveRDS(resampleCoeffsCES, file = resampleCoeffsCESFilename)
  # Resample models
  resampleModelsCES <- list(PT=resamplesCESPT$models, UK=resamplesCESUK$models)
  saveRDS(resampleModelsCES, file = resampleModelsCESFilename)
} else {
  resampleCoeffsCES <- readRDS(resampleCoeffsCESFilename)
  resampleModelsCES <- readRDS(resampleModelsCESFilename)
}
@

<<ReModels>>=
print("Top of ReModels")

ReModels <-
  bind_rows(
  leaf_apply(resampleModelsCES, 
             function(x,id) {mod2oedf(x, id) %>% mutate(id = id)},
             strict.lists = TRUE)
)
@


<<Fitted_and_Residuals>>=
### Why are we going back and forth between CamelCase and interspersed_underscores?
### If there isn't a reason, probably we should stick with one naming convention.

print("top of Fitted_and_Residuals")

temp_data_exp <- 
  leaf_apply(
    modelsExp, class=c("lm"), 
    f = function(model, id){
      model$dat %>% 
        select(Year, Country) %>%
        mutate(
          Country = as.character(Country),  # to avoid warning about unmatched levels of factors
          fitted = exp(fitted(model)), # exp accounts for the fact that the model was fitted in log space.
          residuals = resid(model)     
        )
    }
  ) %>% 
  bind_rows()

### If the function is this long, it should be separated out and named rather than embedded in another
### function call.  
### But this looks like model2df from above.  Let's use that instead.

### Probably just junk now.
# function_that_was_here_before <- function(model, id){
#   df <- data.frame(select(model$data, Year, Country, iGDP))
#   df$fitted <- exp(fitted(model)) # fitted is in log space. Return to regular space.
#   df$Residuals <- resid(model) # residuals are in log space, and that is what we want.
#   # Now add meta information
#   id_list <- strsplit(id, split = "[.]")[[1]]
#   df$flavor <- if (id_list[[2]] ==  "unadjusted") "Unadjusted" else "Quality-adjusted"
#   df$energy <- if (id_list[[3]] == "noE") "Without energy" else "With energy"
#   df$model <- id_list[[4]]
#   df$nest <- if (length(id_list) > 4) id_list[[5]] else NA
#   return(df)
# }


### This looks like a candidate for clean up a la model2df

function_that_was_here_before <- function(model, id){
  id_list <- strsplit(id, split = "[.]")[[1]]
  out <- model$data %>% 
    select(Year) %>%
    mutate(
      # By including [c(1:length(df$Year))] on the end, we 
      # add NAs (as appropriate) to the end of these columns
      # if data do not exist.
      fitted = yhat(model)[c(1:length(Year))],
      residuals = resid(model)[c(1:length(Year))],
      Country = id_list[[1]],
      flavor = ifelse (id_list[[2]] ==  "unadjusted", "Unadjusted", "Quality-adjusted"),
      energy = ifelse(id_list[[3]] == "noE", "Without energy", "With energy"),
      model = id_list[[4]],
      nest = ifelse (length(id_list) > 4, id_list[[5]], NA)
    )
  # Now add the response, using the original variable name.
  out[[summands(model$formula, right = FALSE)]] <- response(model)[c(1:length(out$Year))]
  return(out)  
}

temp_data_CSP <- 
  leaf_apply(modelsCSP, class=c("plm", "lm"), function_that_was_here_before) %>% 
  bind_rows() %>%
  mutate(CSP = "w/ CSP")

temp_data_noCSP <- 
  leaf_apply(models, class=c("CDEmodel", "cesModel", "LINEXmodel"), function_that_was_here_before) %>% 
  bind_rows() %>%
  mutate(CSP = "w/o CSP")

temp_data_noExp <- 
  bind_rows( temp_data_CSP, temp_data_noCSP )

# Now merge the exponential-only model with the CSP and noCSP models. 
# Doing this, because the exponential-only model is kind-of like iY:
# it applies to all situations.
fitted_and_resid_data <- merge(temp_data_noExp, temp_data_exp) 

# Relevel factors before plotting
fitted_and_resid_data <-
  fitted_and_resid_data %>% 
  mutate(
    Country = relevelFactor(factor(Country), c("PT", "UK")),
    flavor  = relevelFactor(factor(flavor), c("Unadjusted", "Quality-adjusted")),
    energy  = relevelFactor(factor(energy), c("Without energy", "With energy")),
    nest    = relevelFactor(factor(nest), c("kl", "kle", "lek", "ekl"))
  ) %>%
  arrange(Country, CSP, model, flavor, energy, nest)
@



<<Table_data>>=
table_data <- 
  AllCoeffs %>%
  plyr::rename(c(model = "Model", energy = "Energy", nest = "Nest")) %>%
  mutate(Nest = 
           plyr::mapvalues(
             Nest,
             from=c("kl", "kle", "lek", "ekl"),
             to=c("$kl$", "$(kl)e$", "$(le)k$", "$(ek)l$")),
         CSP =  
           plyr::mapvalues(
             CSP, 
             from=c("w/ CSP", "w/o CSP"), 
             to=c("Adhere", "Reject")),
         Energy =
           plyr::mapvalues(
             Energy, 
             from=c("Without energy", "With energy"), 
             to=c("Without", "With")),
         Model = 
           plyr::mapvalues(
             Model, 
             from=c("exp"), 
             to=c("Ref."))
  )
@


<<Historical_Data>>=

### Also, I find tidyr::gather() and tidyr::spread() easier to work with than melt() and cast()

histDataForGraph <- 
  leaf_apply(formulas, class = "formula", f=function(form, name){
    meta <- strsplit(name, split="[.]")[[1]]
    Country <- meta[1]
    flavor <- meta[2]
    measure.vars <- c(summands(form, right=FALSE), summands(form, 1:3))
    ### Is there any reason to select away some of the columns?
    trimmed_historical_data <- historicalData[[Country]][c("Year", measure.vars)]
    
    # return this.
    melt(
      trimmed_historical_data, 
      measure.vars = measure.vars, 
      value.name = "value",
      variable.name = "variable") %>%
    mutate(
      variable = as.character(variable), # eliminate factors, which cause warnings with bind_rows() below.
      Country = Country,
      flavor =  ifelse (flavor == "adjusted", "Quality-adjusted", "Unadjusted")
      )
  }
  ) %>% bind_rows() %>%
  
  mutate( 
    # Change variable names to make a nicer-looking graph and relevel factors before plotting
    variable = plyr::mapvalues(variable,
                               from=c("iGDP", 
                                      "iKstkS.L", "iKservS.L", "iKstkO.WwithRD", "iKservO.WwithRD",
                                      "iL", "ihLest",
                                      "iXpMP", "iXp", "iUMP", "iU"),
                               to=c("y", 
                                    "k", "k", "k", "k",
                                    "l", "l",
                                    "e", "e", "e", "e")),
    Country = relevelFactor(factor(Country), c("PT", "UK")), # Adjusts facet order
    flavor = relevelFactor(factor(flavor), c("Unadjusted", "Quality-adjusted")), # Adjusts facet order
    variable = relevelFactor(factor(variable), c("y", "k", "l", "e"))
  )
@


<<Historical_Plot>>=
ggplot(histDataForGraph) + 
  geom_line(aes(x=Year, y=value, group=variable, linetype=variable, colour=variable, size=variable)) +
  facet_grid(flavor ~ Country) + 
  scale_color_manual(name = "", values=c("black", "black", "black", "gray70")) +
  scale_linetype_manual(name="", values=c(1,2,3,1)) + 
  scale_size_manual(name="", values = c(1, 0.9, 0.9, 0.6)) +
  scale_y_continuous(breaks=c(1, 2, 4, 6, 8, 10, 12), limits=c(0.5, 12)) +
  xlab("") + 
  ylab("Indexed (1960=1)") +
  xy_theme()
@


<<Fitted_and_Residual_Graph_Functions>>=

### Can fittedGraphNoCSP and fittedGraphCSP be combined into one function with an argument?
### Or can the data filtering happen outside and everything else be the same?
### Did you copy and paste to make one from the other?  That should be a sign...
fittedGraphNoCSP <- function(data){
  fittedGraphData <- 
    data %>% 
    select(Year, Country, iGDP, fitted, fittedExp, flavor, energy, CSP, nest) %>%
    melt(measure.vars = c("iGDP", "fitted", "fittedExp"), 
         value.name = "value", variable.name = "variable") %>%
    mutate(label = paste(variable, energy)) %>%
    # Now collapse some of the information. Don't need multiple versions of the exponential model, e.g.
    filter(label %in% c("iGDP With energy", "fittedExp With energy", 
                        "fitted With energy", "fitted Without energy")
    ) %>% 
    mutate(
      label = plyr::mapvalues(label, 
                              from = c("iGDP With energy",  "fittedExp With energy",
                                       "fitted With energy", "fitted Without energy"), 
                              to = c("GDP",  "Ref. model",
                                     "w/ energy", "w/o energy")),
      label = relevelFactor(factor(label), 
                            c("GDP", "Ref. model", "w/o energy", "w/ energy"))
    )
  
  ggplot() +
    geom_line(data=fittedGraphData, mapping=aes(x=Year, y=value, group=label, linetype=label, size=label)) +
    scale_linetype_manual(values=c(1,2,4,3), name="") +
    scale_size_manual(name = "", values=c(1, 0.5, 0.5, 0.5)) +
    facet_grid(flavor ~ Country) +
    scale_x_continuous(breaks=c(1960, 1980, 2000)) +
    scale_y_continuous(breaks=c(1, 2, 4, 6, 8, 10, 12)) +
    xlab("") +
    ylab("Indexed GDP (1960=1)") +
    xy_theme()
}
@


<<ResidualPlotFunction>>=

cesResidualPlot2 <- function(data){
  dataToPlot <- 
    data %>%
    mutate(nest = 
             plyr::mapvalues(
               nest, 
               from=c("kl", "kle", "lek", "ekl"), 
               to=c("kl", "(kl)e", "(le)k", "(ek)l")
               ),
           Model = interaction(nest, CSP, sep = " ", drop=TRUE),
           Inputs = flavor)

  ggplot() +
    geom_point(
      data=dataToPlot, 
      mapping=aes(
        x=Year, 
        y=Residuals, 
        fill=Model, 
        shape=Model, 
        size=Model
        )
      ) +
    facet_grid(flavor ~ Country) +
    geom_hline(yintercept = 0, colour="gray50", size=0.1) +
    scale_x_continuous(breaks=c(1960, 1980, 2000)) +
    xlab("") +
    ylab("r") + 
    xy_theme() +
    labs(color = "Factors of production") +
    # This is custom stuff here to match the model_points_style function. 
    # We can't use model_points_style, because the aesthetics are different here
    # with only two series (kl w/o CSP and (kl)e w/o CSP) in the graph.
    scale_size_manual(values = c(3, 3)) +
    scale_fill_manual(values = c("transparent", "transparent")) +
    scale_shape_manual(values = c(21, 23)) +
  theme(legend.title=element_blank())
}
@


\section{End EcolEcon2015A}
