
\Sexpr{set_parent('Paper0/Paper0-Resampling.Rnw')}

\section{Begin EcolEcon2015A}

<<setup, echo=FALSE, message=FALSE, eval=TRUE, warning=FALSE>>=
library(EconData)
library(EconModels)
library(dplyr)
library(reshape2)
library(ggplot2)
library(mosaic)
library(xtable)
library(knitr)
library(texreg)
library(tidyr)
library(scales)
library(tidyr)
library(nlme)


# Tell whether to re-run the analysis to create the models
# or the resampling on the (kl)e models.
# This file will use previously-saved models and resampling to generate
# the paper if set to FALSE, greatly reducing time.
# If something changes in the data or in the code that
# performs the analysis or resampling, set 
# rerunModels = TRUE
# rerunResampling = TRUE
# once to re-generate the information needed to 
# create the paper.
# ********************************************************
rerunModels=FALSE
rerunResampling=FALSE
nResamples <- 100 # Number of resamples
# ********************************************************
opts_chunk$set(
  # ********************************************************
  eval=TRUE,
  include = FALSE,
  # ********************************************************
  # tikz allows LaTeX code in graphical output. 
  # E.g., "$y$" for a variable name in the legend for a graph.  
  # dev='tikz',
  tidy=FALSE,
  comment=NA,
  # Tells whether to cache output from chunks are saved. Cacheing saves time. 
  # However, references to LaTeX tables DO NOT WORK if cacheing is turned on.
  cache=FALSE,
  warning=FALSE,  #Tells whether to show warnings in the output.
  # Turns off messages for all chunks. 
  # Set TRUE on an individual chunk to see it.
  message=FALSE, 
  # Tells whether to echo code for all chunks. 
  # Set TRUE on an individual chunk to see its code.
  echo=FALSE,
  # Sets all table captions to the top.
  xtable.caption.placement="top"
)

# This function is used in many places below.
### That's nice.  I assume that's why you wrote a function.  But what does it DO?
@

<<myXTable>>=
myXTable <- function(data, caption, label, digits=2){
  table <- xtable(data, caption=caption, label=label, digits=digits)
  print(table, 
        caption.placement="top", 
        size="\\tiny", 
        include.rownames=FALSE, 
        math.style.negative=TRUE, 
        sanitize.text.function=function(x){x},
        booktabs=TRUE)
}
@

<<model_points_style>>=
model_points_style <- function(p) {
  p + 
  scale_colour_manual(values = c("gray70", "black")) +
  scale_size_manual(values = c(5, 3,3,3,3,3,3)) +
  # scale_alpha_manual(values = c(.2, .6,.6,.6,.6, .6, .6)) +
  scale_fill_manual(values = c(scales::alpha("gray50", .2), rep("transparent", 6))) +
  scale_shape_manual(values = c(21, 21, 23:27)) +
  guides( 
    col = guide_legend(override.aes = aes(size = 5, shape = 21)) )
}

model_points_style_quad <- function(p) {
  p + 
  # scale_colour_manual(values = c("gray70", "black")) +
  scale_size_manual(values = c(5, 3,3,3,3,3,3)) +
  # scale_alpha_manual(values = c(.2, .6,.6,.6,.6, .6, .6)) +
  scale_fill_manual(values = c(scales::alpha("gray50", .2), rep("transparent", 6))) +
  scale_shape_manual(values = c(21, 21, 23:27)) +
  theme(legend.title=element_blank())
}
@


<<Formulas>>=
# Set up the formulas for each type of analysis.
# These formulas contain energy. 
# We can use keep_summands to drop the energy term (3rd summand on the rhs)
# later if needed.
formulas <- 
  list( 
    PT = c(unadjusted = build_formula("iGDP", list("iKstkS.L", "iL", "iXpMP", "iYear")),
             adjusted = build_formula("iGDP", list("iKservS.L", "ihLest", "iUMP", "iYear"))),
    UK = c(unadjusted = build_formula("iGDP", list("iKstkO.WwithRD", "iL", "iXp", "iYear")),
             adjusted = build_formula("iGDP", list("iKservO.WwithRD", "ihLest", "iU", "iYear")))
  )
countries <- names(formulas)
flavors <- names(formulas$PT)
@

<<Data>>=
# Create the historicalData data frames
### If we need to select variables, we can do that.  Unfortunately, select() and select_() don't do
### what we would like here (they don't accept a vector of character strings), so we'd have to use
### something else.  I've kept the fake select_() command here just to record what was done earlier.

commonVars <- c("Year", "Country", "Source")
historicalData <- list(
  PT =  IST %>% 
    filter(Country == "PT"), 
    #  %>% select_(unique(c(commonVars, all.vars(formulas$PT$unadjusted), all.vars(formulas$PT$adjusted)))),
  UK = Leeds %>% 
    filter(Country == "UK") 
    # %>% select_(unique(c(commonVars, all.vars(formulas$UK$unadjusted), all.vars(formulas$UK$adjusted))))
)
@



<<Models>>=
fileNameCDCES <- "EcolEcon2015ModelsCDCES.rds"
fileNameCSP <- "EcolEcon2015ModelsCSP.rds"
fileNameExp <- "EcolEcon2015ModelsExp.rds"
if (!rerunModels){
  # load from the file on disk
  models <- readRDS(fileNameCDCES)
  modelsCSP <- readRDS(fileNameCSP)
  modelsExp <- readRDS(fileNameExp)
} else {   ### PLEASE USE COMMENTS TO MARK WHERE LONG CHUNKS END; BETTER: AVOID LONG CHUNKS, WHERE POSSIBLE
  
  ### This has not been inspected by rjp
  
  # re-run the models and save to disk.
  # In RStudio, be sure to set the working directory to the source file directory.
  
  #
  # Models that are exponential only, y = A * exp(lambda*t)
  #
  modelsExp <- list()
  alphaExp <- 0
  betaExp <- 0
  gammaExp <- 0
  for (country in countries){
    # Replace with better code later. 
    # Would like to say cdModel(formula, data, factorShares=c(alpha_1 = 0, alpha_2 = 0, alpha_3 = 0))
    # or something like that.
    form <- keep_summands(formulas[[country]][["unadjusted"]], n = c(-1, -2, -3)) # Keep none of the factors of production
    yVar <- as.name(summands(form, n=1, right=FALSE))
    tVar <- as.name(summands(form, n=1))
    data <- historicalData[[country]]
    expMod <- lm(log(eval(yVar)) ~ eval(tVar), data=data)
    attr(expMod, "naturalCoeffs") <- data.frame(lambda=coef(expMod)[[2]],
                                                  logscale=coef(expMod)[[1]], 
                                                  scale=exp(coef(expMod)[[1]]),
                                                  alpha_1=alphaExp,
                                                  alpha_2=betaExp, 
                                                  alpha_3=gammaExp)
    expMod$formula <- form
    sdata <- subset(data, select=all.vars(form))
    sdata <- data[complete.cases(sdata), unique(c(all.vars(form), names(data)))]
    expMod$data <- sdata
    expMod$response <- sdata$iGDP 
    modelsExp[[country]] <- expMod
  }
  # Save exponential models to disk.
  saveRDS(modelsExp, file=fileNameExp)

  
  #
  # Models that adhere to the cost-share theorem
  # 
  
  modelsCSP <- list()
  # Output elasticities based on cost share theorem
  alphaCSP <- 0.3 # Fraction of national accounts spent on capital
  betaCSP <- 0.7 # Fraction of national accounts spent on labor
  for (country in countries){
    for (adj in c("unadjusted", "adjusted")){
      # Replace with better code later. 
      # Would like to say cdModel(formula, data, factorShares=c(alpha_1 = 0.3, alpha_2 = 0.7, alpha_3 = 0))
      # or something like that.
      form <- keep_summands(formulas[[country]][[adj]], n=-3) # Remove energy
      yVar <- as.name(summands(form, n=1, right=FALSE))
      kVar <- as.name(summands(form, n=1))
      lVar <- as.name(summands(form, n=2))
      tVar <- as.name(summands(form, n=3))
      data <- historicalData[[country]]
      # Cobb-Douglas
      cdModCSP <- 
        lm(log(eval(yVar)) - alphaCSP*log(eval(kVar)) - betaCSP*log(eval(lVar)) ~ eval(tVar), 
           data = data)
      # cdModCSP is an "lm" object. It is not a "CDEmodel" object. 
      # Thus, it needs its own "naturalCoeffs" attribute if it is to work correctly in the "naturalCoef" function.
      attr(cdModCSP, "naturalCoeffs") <- data.frame(lambda=coef(cdModCSP)[[2]],
                                                    logscale=coef(cdModCSP)[[1]], 
                                                    scale=exp(coef(cdModCSP)[[1]]),
                                                    alpha_1=alphaCSP,
                                                    alpha_2=betaCSP, 
                                                    alpha_3=0)
      cdModCSP$formula <- form
      sdata <- subset(data, select=all.vars(form))
      sdata <- data[complete.cases(sdata), unique(c(all.vars(form), names(data)))]
      cdModCSP$data <- sdata
      cdModCSP$response <- sdata$iGDP
      modelsCSP[[country]][[adj]][["noE"]][["CD"]] <- cdModCSP
      # CES
      # The only CES models that can adhere to the CSP are models where
      # alpha values are constant with respect to time. 
      # I.e., models where energy is not included AND where rho_1 = 0.
      # CES models where rho_1 = 0 are the Cobb-Douglas model.
      # Convienently, we previously fit that model.
      cesModCSP <- cdModCSP
      # Again, we need a customized "naturalCoeffs" attribute so that 
      # the "naturalCoef" function will do the right thing.
      # "naturalCoeffs" can be based on the same "naturalCoeffs"
      # from the Cobb-Douglas model, but a few additions are needed.
      attr(cesModCSP, "naturalCoeffs") <- 
        naturalCoef(cdModCSP) %>%
        mutate(
          delta_1 = naturalCoef(cdModCSP)[["alpha_1"]],
          delta = 1,
          rho_1 = 0, 
          rho = NA,
          sigma_1 = 1,
          sigma = NA
        )
      modelsCSP[[country]][[adj]][["noE"]][["CES"]][["kl"]] <- cesModCSP
    }
  }
  # Save cost-share theorem models to disk.
  saveRDS(modelsCSP, file=fileNameCSP)

  #
  # Models where all parameters are estimated (models don't adhere to the cost share theorem)
  # 
  
  models <- list()
  for(country in countries){
    for (flavor in flavors){
      fnoE <- keep_summands(formulas[[country]][[flavor]], -3) # Drop the energy term (3rd term on RHS)
      fwithE <- formulas[[country]][[flavor]]
      # CD models
      models[[country]][[flavor]][["noE"]][["CD"]]   <- cdModel(fnoE, data = historicalData[[country]])
      models[[country]][[flavor]][["withE"]][["CD"]] <- cdModel(fwithE, data = historicalData[[country]])
      # CES models
      models[[country]][[flavor]][["noE"]][["CES"]][["kl"]] <- cesModel(fnoE, 
                                                                        data = historicalData[[country]], 
                                                                        nest=c(1,2), digits = 10)
      nestsWithE <- list(kle=c(1,2,3), lek=c(2,3,1), ekl=c(3,1,2))
      models[[country]][[flavor]][["withE"]][["CES"]] <- lapply(nestsWithE, function(nest){
          cesModel(formula=fwithE, data=historicalData[[country]], nest=nest, digits = 10)
        })
    }      
  }
  # Save models to disk.
  saveRDS(models, file=fileNameCDCES)
}  ### END ELSE FROM WAY UP THERE???
@

<<Models2>>=
### TIME FOR A NEW R CHUNK -- That helps detect the end of that long code chunk

### This function is the same in each model group below.  DRY (Don't repeat yourself).
### Using this makes it (a) easier to see what's going on, and (b) easier to make adjustments
### that affect all of the situations simultaneously.

### General hint:  If you find yourself wanting to copy and paste a chunk of code, there is usually
### a better way to do what you are about to do.

model2df <- function(mod, id){
  # Parse the id to find out whether this is quality-adjusted data, etc.
  ### Don't name non-lists with variables whose names sound like a list.
  ### I'm guessing you just didn't know what kind of data you were working with here. 
  ### Either way, it's a bad thing.
  id_components <- strsplit(id, split = "[.]")[[1]]
  
  # return this data frame 
  ### NOTE: ifelse() and [ ] handle NAs the way we want here
  ### The former use of [[ ]] was unnecessary and would break things in the new code
  ### I'm guessing you had [[ ]] because you thought you had a list when you did not.
  
  ### NOTE: data_frame does not auto-convert to factors.  It leaves things as strings.
  data_frame(
    Country = id_components[1], 
    flavor  = ifelse(id_components[2]=="unadjusted", "Unadjusted", "Quality-adjusted"),
    energy  = ifelse(id_components[3]=="noE", "Without energy", "With energy"),
    model   = id_components[4], 
    nest    = id_components[5]) %>%  
  cbind(naturalCoef(mod)) %>% 
  cbind(data.frame(sse = sum(resid(mod)^2)))
} 

### AH: So much tidier here :-)
### NOTE: dplyr::bind_rows() can replace plyr::rbind.fill() in most (all?) situations
###       plyr should probably not be used for data frame level operations anymore.

# Put all exponential model coefficients into a data frame
AllCoeffsExp <- 
  leaf_apply(modelsExp, class = c("lm"), f = model2df) %>%
  bind_rows() %>%
  mutate(model = "exp", CSP = NA)  

# Put all the cost-share theorem (CSP) model coefficients into a data frame
AllCoeffsCSP <- 
  leaf_apply(modelsCSP, class = c("lm"), f = model2df) %>% 
  bind_rows() %>%
  mutate(CSP = "w/ CSP")

# Put all CD and CES model coefficients into a data frame.  
AllCoeffsNoCSP <- 
  leaf_apply(models, class = c("CDEmodel", "cesModel", "LINEXmodel"), f = model2df) %>%
  bind_rows() %>%
  mutate(CSP="w/o CSP")


AllCoeffs <- bind_rows(AllCoeffsExp, AllCoeffsCSP, AllCoeffsNoCSP)

AllCoeffs <-
  AllCoeffs %>% 
  mutate( 
    nest = ifelse(is.na(nest), "", nest),
    CSP = ifelse( CSP == "w/ CSP", "w/ CSP", "w/o CSP")
    )
    

### It looks like this could also be done the otehr way arround:  We could scoop up all the models
### into AllCoeffs and then filter to the subsets.

# Get reference values for lambda and sse.
### This could be done without saving ref if we have no other need for it
### I've renamed ref to Ref since it is a data frame.
Ref <- 
  AllCoeffs %>% 
  filter(model=="exp") %>% 
  select(Country, sse, lambda) %>%
  rename(sse_ref = sse, lambda_ref = lambda)
AllCoeffs <- merge(AllCoeffs, Ref)

# Calculate differences relative to the reference model
### If all we need are the differences, we could skip the part where we put the intermediate stuff 
### into AllCoefs

AllCoeffs <- 
  AllCoeffs %>%
  mutate(
    Dlambda = abs(lambda) - abs(lambda_ref), 
    Dsse = sse - sse_ref,
    percDlambda = Dlambda / abs(lambda_ref) * 100, 
    percDsse = Dsse / sse_ref * 100
  )

# Relevel factors and re-order data
### NOTE:  Need to convert from strings to factors to use relevelFactor()
###        We could modify relevelFacotr() to accept character inputs
AllCoeffs <- 
  AllCoeffs %>%
  mutate(
    Country = relevelFactor(factor(Country), c("PT", "UK")),
    flavor = relevelFactor(factor(flavor), c("Unadjusted", "Quality-adjusted")),
    energy = relevelFactor(factor(energy), c("Without energy", "With energy")),
    model = relevelFactor(factor(model), c("exp", "CD", "CES")),
    nest = relevelFactor(factor(nest), c("kl", "kle", "lek", "ekl")),
    CSP = relevelFactor(factor(CSP), c("w/ CSP", "w/o CSP"))
  ) %>% 
  arrange(Country, model, flavor, energy, nest, CSP)
@

%' <<>>=
%' leaf_apply(models, function(mod, id) class(mod), class="cesModel")
%' @

<<output-elasticity>>=
mod2oedf <- function(mod, id){
  # Parse the id to find out whether this is quality-adjusted data, etc.
  ### Don't name non-lists with variables whose names sound like a list.
  ### I'm guessing you just didn't know what kind of data you were working with here. 
  ### Either way, it's a bad thing.
  id_components <- strsplit(id, split = "[.]")[[1]]
  
  # return this data frame 
  ### NOTE: ifelse() and [ ] handle NAs the way we want here
  ### The former use of [[ ]] was unnecessary and would break things in the new code
  ### I'm guessing you had [[ ]] because you thought you had a list when you did not.
  
  ### NOTE: data_frame does not auto-convert to factors.  It leaves things as strings.
  # message(class(mod))
  if (! inherits(mod, "cesModel") ) return(NULL)
  
  fortify(mod) %>%
    mutate(
      Country = id_components[1], 
      flavor  = ifelse(id_components[2]=="unadjusted", "Unadjusted", "Quality-adjusted"),
      energy  = ifelse(id_components[3]=="noE", "Without energy", "With energy"),
      model   = id_components[4], 
      nest    = id_components[5]
    ) 
} 

AllOE <- 
  leaf_apply(
    models, 
    class = "cesModel", 
    mod2oedf
  ) %>% 
  bind_rows()
@

<<Resampling-CD>>=
print("Top of Resampling-CD")

resampleCoeffsCDFilename <- "EcolEcon2015ResampleCoeffsCD.rds"
resampleModelsCDFilename <- "EcolEcon2015ResampleModelsCD.rds"
if (rerunResampling){
  resamplesCD <- leaf_apply(models, class = "CDEmodel", f = function(model, id){
    id_components <- strsplit(id, split = "[.]")[[1]]
    print(id_components)
    resamples <- resampledFits(model, method = "wild", n = nResamples)
    resamples$coeffs <- mutate(
      resamples$coeffs, 
      Country = id_components[[1]],
      flavor = id_components[[2]],
      energy = id_components[[3]],
      model = id_components[[4]]
    )
    return(resamples)
  })
  # Resample coefficients
  resampleCoeffsCD <- lapply(resamplesCD, function(resample){
    resample$coeffs
  }) %>% plyr::rbind.fill()
  saveRDS(resampleCoeffsCD, resampleCoeffsCDFilename)
  # Resample models
  # At present these resample models are stored in a "flat" list.
  # We may want to change that later.
  resampleModelsCD <- lapply(resamplesCD, function(resample){
    resample$models
  })
  saveRDS(resampleModelsCD, resampleModelsCDFilename)
} else {
  resampleCoeffsCD <- readRDS(resampleCoeffsCDFilename)
  resampleModelsCD <- readRDS(resampleModelsCDFilename)
}
@

<<Resampling-CES-adjusted-kle>>=
print("Top of Resampling-CES-adjusted-kle")

resampleCoeffsCESFilename <- "EcolEcon2015kleResampleCoeffsCES.rds"
resampleModelsCESFilename <- "EcolEcon2015kleResampleModelsCES.rds"
if (rerunResampling){
  # Run some resampling on the PT and UK models that reject the cost-share theorem,
  # include energy, use quality-adjusted variables, and employ the (kl)e nesting.
  # This is u-g-l-y code. Just getting something running for now.
  modPT <- models$PT$adjusted$withE$CES$kle
  modUK <- models$UK$adjusted$withE$CES$kle
  resamplesCESPT <- resampledFits(modPT, method = "wild", n = nResamples)
  resamplesCESUK <- resampledFits(modUK, method = "wild", n = nResamples)
  # Resample coefficients
  resampleCoeffsCES <- rbind(cbind(resamplesCESPT$coeffs, Country="PT"), cbind(resamplesCESUK$coeffs, Country="UK"))
  resampleCoeffsCES$energy <- TRUE
  resampleCoeffsCES$nest <- "(kl)e"
  saveRDS(resampleCoeffsCES, file = resampleCoeffsCESFilename)
  # Resample models
  resampleModelsCES <- list(PT=resamplesCESPT$models, UK=resamplesCESUK$models)
  saveRDS(resampleModelsCES, file = resampleModelsCESFilename)
} else {
  resampleCoeffsCES <- readRDS(resampleCoeffsCESFilename)
  resampleModelsCES <- readRDS(resampleModelsCESFilename)
}
@

<<ReModels>>=
print("Top of ReModels")

ReModels <-
  bind_rows(
  leaf_apply(resampleModelsCES, 
             function(x,id) {mod2oedf(x, id) %>% mutate(id = id)},
             strict.lists = TRUE)
)
@


<<Fitted_and_Residuals>>=
### Why are we going back and forth between CamelCase and interspersed_underscores?
### If there isn't a reason, probably we should stick with one naming convention.

print("top of Fitted_and_Residuals")

temp_data_exp <- 
  leaf_apply(
    modelsExp, class=c("lm"), 
    f = function(model, id){
      ### Why wrap in data.frame() something that already is a tbl_df?  If this is necessary, say why.
      #  df <- data.frame(select(model$data, Year, Country))
      ### Also: let's use a consistent style for the dplyr commands, prefering to use %>% in most cases.
      ### Also: The following use of white space makes it clearer what is going on (and how many steps 
      ###       are involved.  I'm going to change A LOT of code to this format.
      ### In this format, there is no name to create a temporary variable (or to use return())
      
      model$dat %>% 
        select(Year, Country) %>%
        mutate(
          Country = as.character(Country),  # to avoid warning about unmatched levels of factors
          fittedExp = exp(fitted(model)), # exp accounts for the fact that the model was fitted in log space.
          ResidualsExp = resid(model)     ### Why is this capitalized?
        )
    }
  ) %>% 
  bind_rows()

### If the function is this long, it should be separated out and named rather than embedded in another
### function call.  
### But this looks like model2df from above.  Let's use that instead.

### Probably just junk now.
# function_that_was_here_before <- function(model, id){
#   df <- data.frame(select(model$data, Year, Country, iGDP))
#   df$fitted <- exp(fitted(model)) # fitted is in log space. Return to regular space.
#   df$Residuals <- resid(model) # residuals are in log space, and that is what we want.
#   # Now add meta information
#   id_list <- strsplit(id, split = "[.]")[[1]]
#   df$flavor <- if (id_list[[2]] ==  "unadjusted") "Unadjusted" else "Quality-adjusted"
#   df$energy <- if (id_list[[3]] == "noE") "Without energy" else "With energy"
#   df$model <- id_list[[4]]
#   df$nest <- if (length(id_list) > 4) id_list[[5]] else NA
#   return(df)
# }

### One line for each operation:  first leaf_apply, then rbind, then mutate -- Clarity by Code Convention
temp_data_CSP <- 
  leaf_apply(modelsCSP, class=c("plm", "lm"), model2df) %>% 
  bind_rows() %>%
  mutate(CSP = "w/ CSP")

### This looks like a candidate for clean up a la model2df

function_that_was_here_before <- function(model, id){
  df <- data.frame(select(model$data, Year)) 
  # By including [c(1:length(df$Year))] on the end, we 
  # add NAs (as appropriate) to the end of these columns
  # if data do not exist.
  df$fitted <- yhat(model)[c(1:length(df$Year))]
  df$Residuals <- resid(model)[c(1:length(df$Year))]
  # Now add the response, using the original variable name.
  df[[summands(model$formula, right = FALSE)]] <- response(model)[c(1:length(df$Year))]
  # Now add meta information
  id_list <- strsplit(id, split = "[.]")[[1]]
  len <- length(id_list)
  df$Country <- id_list[[1]]
  df$flavor <- if (id_list[[2]] ==  "unadjusted") "Unadjusted" else "Quality-adjusted"
  df$energy <- if (id_list[[3]] == "noE") "Without energy" else "With energy"
  df$model <- id_list[[4]]
  df$nest <- if (length(id_list) > 4) id_list[[5]] else NA
  return(df)  
}

temp_data_noCSP <- 
  leaf_apply(models, class=c("CDEmodel", "cesModel", "LINEXmodel"), function_that_was_here_before) %>% 
  bind_rows() %>%
  mutate(CSP = "w/o CSP")

temp_data_noExp <- 
  bind_rows( temp_data_CSP, temp_data_noCSP )

# Now merge the exponential-only model with the CSP and noCSP models. 
# Doing this, because the exponential-only model is kind-of like iY:
# it applies to all situations.
fitted_and_resid_data <- 
  merge(temp_data_noExp, temp_data_exp) %>% 
  mutate( Dr = abs(Residuals) - abs(ResidualsExp) )  
### Caps in bad places?

# Create a column containing ∆r, the difference between a residual value
# and the residual value in the same year for the reference model
### BREAK LONG LINES IN REASONABLE PLACES
### BUT better to use mutate here.  See above.
# fitted_and_resid_data[["Dr"]] <- 
#   abs(fitted_and_resid_data[["Residuals"]]) - abs(fitted_and_resid_data[["ResidualsExp"]])

# Relevel factors before plotting
### Use mutate for this stuff!
### Align = to make similarities between successive lines stand out.

fitted_and_resid_data <-
  fitted_and_resid_data %>% 
  mutate(
    Country = relevelFactor(factor(Country), c("PT", "UK")),
    flavor  = relevelFactor(factor(flavor), c("Unadjusted", "Quality-adjusted")),
    energy  = relevelFactor(factor(energy), c("Without energy", "With energy")),
    nest    = relevelFactor(factor(nest), c("kl", "kle", "lek", "ekl"))
  ) %>%
  arrange(Country, CSP, model, flavor, energy, nest)
@



<<Table_data>>=
print("Top of Table_data")

table_data <- 
  AllCoeffs %>%
  plyr::rename(c(model = "Model", energy = "Energy", nest = "Nest")) %>%
  mutate(Nest = 
           plyr::mapvalues(
             Nest,
             from=c("kl", "kle", "lek", "ekl"),
             to=c("$kl$", "$(kl)e$", "$(le)k$", "$(ek)l$")),
         CSP =  
           plyr::mapvalues(
             CSP, 
             from=c("w/ CSP", "w/o CSP"), 
             to=c("Adhere", "Reject")),
         Energy =
           plyr::mapvalues(
             Energy, 
             from=c("Without energy", "With energy"), 
             to=c("Without", "With")),
         Model = 
           plyr::mapvalues(
             Model, 
             from=c("exp"), 
             to=c("Ref."))
  )
@


<<CES_sr_gof, results="asis">>=
print("Top of CES sr gof")

data_CES_SR_gof <- 
  table_data %>% 
  filter(Model=="CES" | Model=="Ref.") %>% 
  select(Country, Model, CSP, flavor, Energy, Nest, scale, lambda, sse) %>%
  plyr::rename(c("flavor" = "Factors of prod.",
                  "scale" = "$\\theta$",
                  "lambda" = "$\\lambda$"))

myXTable(data_CES_SR_gof,
         caption="Scale parameter~($\\theta$), Solow residual~($\\lambda$), and sum of squared errors~($sse$) for all modeling choices.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=c(1,1,1,1,1,1,1, 2, 4, 3))
@



<<CES_sigma_nest_aware_inner, results="asis">>=
sigma_inner_data <- 
  table_data %>% 
  filter(Model=="CES") %>% 
  select(Country, CSP, flavor, Energy, Nest, sigma_12, sigma_23, sigma_13) %>%
  plyr::rename( c("flavor" = "Factors of prod.",
                  "sigma_12" = "$\\sigma_{kl}$",
                  "sigma_23" = "$\\sigma_{le}$",
                  "sigma_13" = "$\\sigma_{ek}$"))
#
myXTable(sigma_inner_data,
         caption="Elasticities of substitution~($\\sigma$) for inner nests of CES models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=c(1,1,1,1,1,1, 3,3,3))
@



<<CES_sigma_nest_aware_outer, results="asis">>=
sigma_outer_data <- 
  table_data %>% 
  filter(Model=="CES") %>% 
  select(Country, CSP, flavor, Energy, Nest, sigma_12_3, sigma_23_1, sigma_13_2) %>%
  plyr::rename(c("flavor" = "Factors of prod.", 
                 "sigma_12_3" = "$\\sigma_{(kl)e}$",
                 "sigma_23_1" = "$\\sigma_{(le)k}$",
                 "sigma_13_2" = "$\\sigma_{(ek)l}$"))
myXTable(sigma_outer_data,
         caption="Elasticities of substitution~($\\sigma$) for outer nests of CES models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=c(1,1,1,1,1,1, 3,3,3))
@



<<Historical_Data_Graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Historical data.", warning=FALSE>>=

### Also, I find tidyr::gather() and tidyr::spread() easier to work with than melt() and cast()

histDataForGraph <- 
  leaf_apply(formulas, class = "formula", f=function(form, name){
    meta <- strsplit(name, split="[.]")[[1]]
    Country <- meta[1]
    flavor <- meta[2]
    measure.vars <- c(summands(form, right=FALSE), summands(form, 1:3))
    ### Is there any reason to select away some of the columns?
    trimmed_historical_data <- historicalData[[Country]][c("Year", measure.vars)]
    
    # return this.
    melt(
      trimmed_historical_data, 
      measure.vars = measure.vars, 
      value.name = "value",
      variable.name = "variable") %>%
    mutate(
      variable = as.character(variable), # eliminate factors, which cause warnings with bind_rows() below.
      Country = Country,
      flavor =  ifelse (flavor == "adjusted", "Quality-adjusted", "Unadjusted")
      )
  }
  ) %>% bind_rows() %>%
  
  mutate( 
    # Change variable names to make a nicer-looking graph and relevel factors before plotting
    variable = plyr::mapvalues(variable,
                               from=c("iGDP", 
                                      "iKstkS.L", "iKservS.L", "iKstkO.WwithRD", "iKservO.WwithRD",
                                      "iL", "ihLest",
                                      "iXpMP", "iXp", "iUMP", "iU"),
                               to=c("y", 
                                    "k", "k", "k", "k",
                                    "l", "l",
                                    "e", "e", "e", "e")),
    Country = relevelFactor(factor(Country), c("PT", "UK")), # Adjusts facet order
    flavor = relevelFactor(factor(flavor), c("Unadjusted", "Quality-adjusted")), # Adjusts facet order
    variable = relevelFactor(factor(variable), c("y", "k", "l", "e"))
  )

ggplot(histDataForGraph) + 
  geom_line(aes(x=Year, y=value, group=variable, linetype=variable, colour=variable, size=variable)) +
  facet_grid(flavor ~ Country) + 
  scale_color_manual(name = "", values=c("black", "black", "black", "gray70")) +
  scale_linetype_manual(name="", values=c(1,2,3,1)) + 
  scale_size_manual(name="", values = c(1, 0.9, 0.9, 0.6)) +
  scale_y_continuous(breaks=c(1, 2, 4, 6, 8, 10, 12), limits=c(0.5, 12)) +
  xlab("") + 
  ylab("Indexed (1960=1)") +
  xy_theme()
@


<<Fitted_and_Residual_Graph_Functions>>=

### Can fittedGraphNoCSP and fittedGraphCSP be combined into one function with an argument?
### Or can the data filtering happen outside and everything else be the same?
### Did you copy and paste to make one from the other?  That should be a sign...
fittedGraphNoCSP <- function(data){
  fittedGraphData <- 
    data %>% 
    select(Year, Country, iGDP, fitted, fittedExp, flavor, energy, CSP, nest) %>%
    melt(measure.vars = c("iGDP", "fitted", "fittedExp"), 
         value.name = "value", variable.name = "variable") %>%
    mutate(label = paste(variable, energy)) %>%
    # Now collapse some of the information. Don't need multiple versions of the exponential model, e.g.
    filter(label %in% c("iGDP With energy", "fittedExp With energy", 
                        "fitted With energy", "fitted Without energy")
    ) %>% 
    mutate(
      label = plyr::mapvalues(label, 
                              from = c("iGDP With energy",  "fittedExp With energy",
                                       "fitted With energy", "fitted Without energy"), 
                              to = c("GDP",  "Ref. model",
                                     "w/ energy", "w/o energy")),
      label = relevelFactor(factor(label), 
                            c("GDP", "Ref. model", "w/o energy", "w/ energy"))
    )
  
  ggplot() +
    geom_line(data=fittedGraphData, mapping=aes(x=Year, y=value, group=label, linetype=label, size=label)) +
    scale_linetype_manual(values=c(1,2,4,3), name="") +
    scale_size_manual(name = "", values=c(1, 0.5, 0.5, 0.5)) +
    facet_grid(flavor ~ Country) +
    scale_x_continuous(breaks=c(1960, 1980, 2000)) +
    scale_y_continuous(breaks=c(1, 2, 4, 6, 8, 10, 12)) +
    xlab("") +
    ylab("Indexed GDP (1960=1)") +
    xy_theme()
}
@


<<Graphs_CESkle-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="CES models with $kl$ and ($kl$)$e$ nesting that reject the CSP. Solid line is historical GDP.">>=
fittedGraphData_kle <- 
  fitted_and_resid_data %>% 
  filter(model=="CES" & CSP=="w/o CSP" & (nest == "kl" | nest == "kle"))

fittedGraphNoCSP(fittedGraphData_kle)
@


<<ResidualPlotFunction>>=

cesResidualPlot2 <- function(data){
  dataToPlot <- 
    data %>%
    mutate(nest = 
             plyr::mapvalues(
               nest, 
               from=c("kl", "kle", "lek", "ekl"), 
               to=c("kl", "(kl)e", "(le)k", "(ek)l")
               ),
           Model = interaction(nest, CSP, sep = " ", drop=TRUE),
           Inputs = flavor)

  ggplot() +
    geom_point(
      data=dataToPlot, 
      mapping=aes(
        x=Year, 
        y=Residuals, 
        fill=Model, 
        shape=Model, 
        size=Model
        )
      ) +
    facet_grid(flavor ~ Country) +
    geom_hline(yintercept = 0, colour="gray50", size=0.1) +
    scale_x_continuous(breaks=c(1960, 1980, 2000)) +
    xlab("") +
    ylab("r") + 
    xy_theme() +
    labs(color = "Factors of production") +
    # This is custom stuff here to match the model_points_style function. 
    # We can't use model_points_style, because the aesthetics are different here
    # with only two series (kl w/o CSP and (kl)e w/o CSP) in the graph.
    scale_size_manual(values = c(3, 3)) +
    scale_fill_manual(values = c("transparent", "transparent")) +
    scale_shape_manual(values = c(21, 23)) +
  theme(legend.title=element_blank())
}
@

<<Resid_plot_with_ref, eval=FALSE, include=FALSE>>=
# This version of the residual plot includes reference model residuals.
# But the reference model dwarfs all other residuals and looks bad on the graph.
# So, I decided not to use this. ---MKH, 14 Aug 2015

# residualPlot <- function(data, withEnergyShape = 0){
#   # Keep only the data we need
#   residGraphData <- select(data, Year, Country, Residuals, flavor, energy, model, nest, CSP, ResidualsExp)
#   # Melt the data so that we can include the reference model, too.
#   residGraphData <- melt(residGraphData, 
#                          measure.vars=c("Residuals", "ResidualsExp"),
#                          value.name="value",
#                          variable.name="variable")
#   residGraphData$label <- with(residGraphData, paste(variable, energy))
#   
#   # Now collapse some of the information. Don't need multiple versions of the exponential model, e.g.
#   residGraphData <- filter(residGraphData, label=="Residuals With energy" | label=="Residuals Without energy" |
#                              label=="ResidualsExp Without energy")
#   
#   residGraphData$label <- plyr::mapvalues(residGraphData$label, 
#                                           from = c("Residuals With energy", 
#                                                    "Residuals Without energy",
#                                                    "ResidualsExp Without energy"), 
#                                           to = c("With energy", 
#                                                  "Without energy",
#                                                  "Reference model"))
#   # Relevel factors
#   residGraphData$label <- relevelFactor(as.factor(residGraphData$label), 
#                                          c("Without energy", "With energy", "Reference model"))
#   
#   ggplot() +
#     geom_point(data=residGraphData, mapping=aes(x=Year, y=value, shape=label, color=label, size=label)) +
#     scale_shape_manual(values=c(1, withEnergyShape, 5)) +
#     scale_size_manual(values=c(4, 4, 2)) +
#     # scale_color_manual(values=c("gray50", "green", "red")) +
#     facet_grid(Country ~ flavor) +
#     geom_hline(yintercept = 0, colour="gray50", size=0.1) +
#     scale_x_continuous(breaks=c(1960, 1980, 2000)) +
#     xlab("") +
#     ylab("r") + 
#     xy_theme() +
#     theme(legend.title=element_blank())
# }
@


<<SRsse_CES_graph_3, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Solow Residuals~($\\lambda$) and mean squared error~($sse$). $\\lambda$ and $sse$ values for the reference (exponential-only) model are shown as gridlines. This version uses our proposed new style.">>=
data_sr_sse <- 
  AllCoeffs %>% 
  filter(model=="CES") %>% 
  mutate(nest = 
           plyr::mapvalues(
             nest, 
             from=c("kl", "kle", "lek", "ekl"), 
             to=c("kl", "(kl)e", "(le)k", "(ek)l")
             ),
         Model = interaction(nest, CSP, sep = " ", drop=TRUE),
         Inputs = flavor
  )

p <- ggplot() +
  geom_point(
    data=data_sr_sse, 
    mapping=aes(
      x=lambda, 
      y=sse, 
      fill=Model, 
      shape=Model, 
      size=Model #, 
      # color=Inputs
      )) +
  geom_vline(aes(xintercept = lambda), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, lambda), 
             colour="gray50", size=0.1) +
  geom_hline(aes(yintercept = sse), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, sse), 
             colour="gray50", size=0.1) +
  facet_grid(flavor ~ Country) +
  scale_x_continuous(breaks=c(0, 0.01, 0.02, 0.03), limits=c(0, 0.035)) +
  xlab(expression(lambda)) +
  scale_y_continuous(limits=c(-0.05, 0.7)) +
  ylab("SSE") + 
  labs(color = "Factors of production") +
  xy_theme() # +
  # theme(legend.title=element_blank())

# Add our style
model_points_style_quad(p)

@


<<Graphs_all_models_alphas_time, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=6, fig.cap="Output elasticity ($\\alpha$) for all models.">>=
AllOE %>% 
  mutate(split =
           as.character(
             interaction(
               factor(flavor, labels = c("QA", "UA")), 
               factor(nest, 
                      labels = c("(ek)l", "kl", "(kl)e", "(le)k")), 
               sep = ", ",
               lex.order = FALSE ) )
  ) %>%
  gather(factor, elasticity, oe1, oe2, oe3) %>%
  mutate(
    split2 = relevelFactor(
      factor(split), 
      paste( rep(c("UA", "QA"), times = 4 ), 
             rep(c("kl", "(kl)e", "(le)k", "(ek)l"), each=2),
             sep=", ")
    )
  ) %>%
  ggplot(aes(x=Year)) + 
  geom_line( 
    alpha = .8, # size=1.0,
    aes(y = elasticity, 
        colour = factor,
        linetype=factor,
        size = factor
    ) ) +
  facet_grid(split2 ~ Country) +
  scale_color_manual(
    name = "",
    labels = c(expression(alpha[k]), expression(alpha[l]), expression(alpha[e])),
    values=c("black", "black", "gray70")
  ) +
  scale_x_continuous(breaks = c(1960, 1980, 2000)) +
  scale_y_continuous(breaks = c(0.0, 0.5, 1.0), limits=c(-0.2, 1.2)) +
  scale_size_manual(
    name = "",
    labels = c(expression(alpha[k]), expression(alpha[l]), expression(alpha[e])),
    values = c(.9, .9, .6)) +
  scale_linetype_manual( 
    name = "",
    labels = c(expression(alpha[k]), expression(alpha[l]), expression(alpha[e])),
    values=c(2,3,1) ) + 
  labs(x="", y="") +
  xy_theme()
@


<<sigma_graph_3, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.82, fig.cap="Elasticities of substitution~($\\sigma$) with factors of production on the vertical facet.">>=
breaks_labels = c(0.01, 0.1, 1, 10, 100)
p <- 
  ggplot(
    AllCoeffs %>% 
      gather(type, value, matches("sigma")) %>% 
      filter(!is.na(value)) %>% 
      filter(! type %in% c("sigma", "sigma_1")) %>%
      mutate(nest = plyr::mapvalues(nest, 
                                    from=c("kle", "lek", "ekl"), 
                                    to=c("(kl)e", "(le)k", "(ek)l")),
             Model = interaction(nest, CSP, sep = " ", drop=TRUE),
             Inputs = flavor,
             type = relevelFactor(type, rev(c("sigma_12", "sigma_23", "sigma_13", "sigma_12_3", "sigma_23_1", "sigma_13_2")))
             )
    ) + 
  geom_point(aes(x=value, 
                 y=type, 
                 shape = Model, 
                 fill=Model, 
                 size=Model
                 )
             ) + 
  facet_grid( Inputs ~ Country) + 
  scale_x_log10(limits = c(0.001,2000), breaks=breaks_labels, labels=breaks_labels) +
  xlab("") +
  geom_vline(xintercept = 1, color="gray50", size=0.2) +
  ylab("") +
  scale_y_discrete(labels = c(
    sigma_12 = expression(sigma[kl]),
    sigma_23 = expression(sigma[le]),
    sigma_13 = expression(sigma[ek]),
    sigma_12_3 = expression(sigma["(kl)"*e]),
    sigma_23_1 = expression(sigma["(le)"*k]),
    sigma_13_2 = expression(sigma["(ek)"*l]))
    ) +
  xy_theme() +
  theme(axis.text.y = element_text(size=12))

model_points_style_quad(p)
@


<<resample_graph_lambda_theta, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.5, fig.cap="$\\lambda$ and $\\theta$ values for resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardScatterPlot(data=resampleCoeffsCES, mapping=aes(scale, lambda), facet_formula=~Country, alpha=0.05, orig_color = "black") +
    scale_x_continuous(breaks=c(0.95, 1.0, 1.05)) + 
    scale_y_continuous(breaks=c(0, 0.005, 0.01), limits=c(0, 0.01)) +
    labs(x=expression(theta), y=expression(lambda))
@

<<resample_graph_sigma1_delta1, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.5, fig.cap="$\\sigma_{(kl)}$ and $\\delta_1$ values for resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardScatterPlot(data=resampleCoeffsCES, mapping=aes(delta_1, sigma_1), 
                    facet_formula=~Country, alpha=0.1) +
    coord_trans(y="sigma2") +
    scale_x_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0,1)) +
    scale_y_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0, 1e6)) +
    labs(x=expression(delta[1]), y=expression(sigma[kl]))
@

<<resample_graph_sigma_delta, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.5, fig.cap="$\\sigma_{(kl)e}$ and $\\delta$ values for resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardScatterPlot(data=resampleCoeffsCES, mapping=aes(delta, sigma), 
                    facet_formula=~Country, alpha=0.1) +
    coord_trans(y="sigma2") +
    scale_x_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0,1)) +
    scale_y_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0, 1e6)) +
    labs(x=expression(delta), y=expression(sigma["(kl)"*e]))
@


<<resample_graph_alpha, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.2, fig.cap="Resample output elasticities for CES models with $(kl$)$e$ nesting.">>=
ReModels %>% 
  gather(factor, elasticity, oe1, oe2, oe3) %>%
  ggplot(aes(x=Year)) + 
  geom_line( 
    aes(y = elasticity,
        alpha = grepl("orig", id),
        group = interaction(id, factor),
        color = factor,
        linetype = factor,
        size = grepl("orig", id)
    ) ) +
  facet_grid(. ~ Country) +
  
  scale_x_continuous(breaks = c(1960, 1980, 2000)) +
  scale_y_continuous(breaks = c(0.0, 0.5, 1.0)) +
  labs(x="", y="") +
  
  scale_alpha_manual(
    name = "",
    values = c(.3, 1),
    guide = FALSE) + 
  scale_color_manual(
    name = "",
    labels = c(expression(alpha[k]), expression(alpha[l]), expression(alpha[e])),
    values=c("black", "black", "gray70"),
    guide=FALSE) +
  scale_size_manual(
    name = "",
    labels = c(expression(alpha[k]), expression(alpha[l]), expression(alpha[e])),
    values = c(.3, .9),
    guide = FALSE) +
  scale_linetype_manual( 
    name = "",
    labels = c(expression(alpha[k]), expression(alpha[l]), expression(alpha[e])),
    values=c(2,3,1) ) + 
  
  xy_theme() 
@



<<Correlograms_Exp, echo=FALSE, message=FALSE, include=FALSE, eval=FALSE>>=
leaf_apply(l = modelsExp, class = c("lm"), f = function(model, name){
  acf(resid(model), main=name)
})
@


<<Correlograms_CSP, echo=FALSE, message=FALSE, include=FALSE, eval=FALSE>>=
leaf_apply(l = modelsCSP, class = c("lm", "plm"), f = function(model, name){
  acf(resid(model), main=name)
})
@


<<Correlograms_noCSP, echo=FALSE, message=FALSE, include=FALSE, eval=FALSE>>=
leaf_apply(l = models, class = c("CDEmodel", "cesModel", "LINEXmodel"), f = function(model, name){
  acf(resid(model), main=name)
})
@



%' <<stat_details_table, results="asis", include=FALSE, eval=FALSE>>=
%' texreg(list(models$PT$adjusted$withE$CES$kle, models$UK$adjusted$withE$CES$kle), 
%'        dcolumn = TRUE, 
%'        booktabs = TRUE, 
%'        use.packages = FALSE, 
%'        label=paste0("tab:", opts_current$get("label")), 
%'        caption = "Example output from \\texttt{texreg}.",
%'        caption.above = TRUE, 
%'        digits = 6,
%'        fontsize = "tiny",
%'        float.pos = "hb")
%' @



<<Pre-econometric_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Pre-econometric data.", warning=FALSE>>=
pre_econometric_data <- 
  leaf_apply(
    formulas, class = "formula", 
    f=function(form, name){
      meta <- strsplit(name, split="[.]") %>% unlist
      Country <- meta[1]
      flavor <- meta[2]
      nums <- summands(form, n=1:3)
      denom <- summands(form, n=1, right=FALSE)
      ratios <- lapply(nums, function(num) {paste(num, denom, sep="/")}) %>% unlist
      coltemplate <- build_formula(NULL, c("Year", ratios))
      trimmed_historical_data <- historicalData[[Country]][all.vars(coltemplate)]
      ratio_data <- evalFormula(coltemplate, data=trimmed_historical_data)$right
      mratio_data <- melt(ratio_data, measure.vars = ratios, value.name = "ratio", variable.name = "variable")
      mratio_data$Country <- Country
      mratio_data$flavor <- if (flavor == "adjusted") "Quality-adjusted" else "Unadjusted"
      return(mratio_data)
    }
  ) %>%  
  bind_rows() 

# Fix levels
pre_econometric_data$flavor <- relevelFactor(as.factor(as.character(pre_econometric_data$flavor)), 
                                               c("Unadjusted", "Quality-adjusted"))
pre_econometric_data$Country <- relevelFactor(as.factor(pre_econometric_data$Country), 
                                              c("PT", "UK"))
pre_econometric_data$variable <- relevelFactor(as.factor(pre_econometric_data$variable),
                                               unique(pre_econometric_data$variable))
# Now make the plot of pre-econometric data
historicalPlot(pre_econometric_data, 
               mapping=aes(x=Year, y=ratio, group=variable, linetype=variable), 
               facet_formula = Country ~ flavor, 
               line_types = c(2,4,3, 2,4,3, 2,3,2, 3)) + 
  xlab("") + 
  ylab("Indexed (1960=1)")
@


<<Graphs_CD-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Cobb-Douglas models that reject the cost-share theorem. Solid line is historical GDP.">>=
fittedGraphNoCSP(fitted_and_resid_data %>% filter(model=="CD" & CSP=="w/o CSP"))
@

<<Graphs_CD-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for Cobb-Douglas models that reject the CSP.">>=
  ggplot() +
    geom_point(
      data=fitted_and_resid_data %>% 
        filter(model=="CD" & CSP=="w/o CSP"), 
      mapping=aes(
        x=Year,
        y=Residuals,
        fill=energy, 
        shape=energy 
        )
      ) +
    facet_grid( flavor ~ Country) +
    geom_hline(yintercept = 0, colour="gray50", size=0.1) +
    scale_x_continuous(breaks=c(1960, 1980, 2000)) +
    xlab("") +
    ylab("r") + 
    xy_theme() +
    # This is custom stuff here to match the model_points_style function. 
    # We can't use model_points_style, because the aesthetics are different here
    scale_fill_manual(values = c("transparent", "transparent")) +
    scale_shape_manual(values = c(21, 23)) +
  theme(legend.title=element_blank())
@
%

<<Effect_of_CSP_CD, results="asis">>=
data_CSP_CD <- 
  AllCoeffs %>%
  filter((model=="CD" & flavor=="Unadjusted" & energy=="Without energy") | model=="exp") %>% 
  select(Country, model, CSP, scale, lambda, alpha_1, alpha_2, sse)

data_CSP_CD <- plyr::rename(data_CSP_CD, c("alpha_1" = "$\\alpha_1$", "alpha_2" = "$\\alpha_2$"))

myXTable(data_CSP_CD,
         caption="Model parameters for Cobb-Douglas models with unadjusted factors of production, without energy.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@
%

<<CD_coeffs, results="asis">>=
data_CD_exp <- 
  AllCoeffs %>% 
  filter(model=="CD" | model=="exp") %>% 
  select(Country, model, flavor, energy, CSP, scale, lambda, alpha_1, alpha_2, alpha_3, sse)

data_CD_exp <- plyr::rename(data_CD_exp, c("alpha_1" = "$\\alpha_1$", 
                                           "alpha_2" = "$\\alpha_2$", 
                                           "alpha_3" = "$\\alpha_3$"))
myXTable(data_CD_exp,
         caption="Model parameters for all Cobb-Douglas models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@

<<DSRsse_CD, results="asis">>=
myXTable(AllCoeffs %>% 
           filter(model=="CD") %>% 
           select(Country, model, flavor, energy, CSP, Dlambda, Dsse),
         caption="$\\Delta \\lambda$ and $\\Delta sse$ for Cobb-Douglas models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@

<<DSRsse_CD_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Change in Solow Residuals~($\\Delta\\lambda$) and mean squared error~($\\Delta sse$) for the Cobb-Douglas model relative to the exponential-only model.">>=
ggplot() +
  geom_point(data=AllCoeffs %>% filter(model=="CD"), 
             mapping=aes(x=Dsse, y=Dlambda, color=energy, size=CSP)) +
  facet_grid(Country ~ flavor) +
  scale_size_manual(values=c(2,3.5)) +
  xlab(expression(Delta * sse)) + 
  ylab(expression(Delta * lambda)) +
  scale_y_continuous(limits=c(-0.04, 0)) +
  xy_theme() + 
  theme(legend.title=element_blank())
@

<<percDSRsse_CD_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Percentage change in Solow Residuals~($\\Delta\\lambda \\, [\\%]$) and mean squared error~($\\Delta sse \\, [\\%]$) for the Cobb-Douglas model relative to exponential-only models.">>=
ggplot() +
  geom_point(data=AllCoeffs %>% filter(model=="CD"), 
             mapping=aes(x=percDsse, y=percDlambda, color=energy, size=CSP)) +
  facet_grid(Country ~ flavor) +
  scale_size_manual(values=c(2,3.5)) +
  xlab(expression(paste(Delta * sse, " [%]"))) + 
  scale_x_continuous(breaks=seq(-50, 50, 50), limits=c(-90, 50)) +  
  ylab(expression(paste(Delta * lambda, " [%]"))) +
  scale_y_continuous(breaks=seq(-80, 0, 20), limits=c(-100, 10)) +  
  xy_theme() + 
  theme(legend.title=element_blank())
@

<<DSRsse_CES_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Change in Solow Residuals~($\\Delta\\lambda$) and mean squared error~($\\Delta sse$) for the CES modles relative to the exponential-only model.">>=
ggplot() +
  geom_point(data=AllCoeffs %>% filter(model=="CES"), 
             mapping=aes(x=Dsse, y=Dlambda, color=energy, size=CSP, shape=nest)) +
  scale_size_manual(values=c(2,3.5)) +
  scale_shape_manual(values=c(16,17,18,15)) +
  facet_grid(Country ~ flavor) +
  xlab(expression(Delta * sse)) + 
  scale_x_continuous(breaks=seq(-0.005, 0, 0.005)) +  
  ylab(expression(Delta * lambda)) +
  xy_theme() +
  theme(legend.title=element_blank())
@
%
<<percDSRsse_CES_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Percentage change in Solow Residuals~($\\Delta\\lambda \\, [\\%]$) and mean squared error~($\\Delta sse \\, [\\%]$) for the CES models relative to the exponential-only model.">>=
ggplot() +
  geom_point(data=AllCoeffs %>% filter(model=="CES"), 
             mapping=aes(x=percDsse, y=percDlambda, color=energy, size=CSP, shape=nest)) +
  scale_size_manual(values=c(2,3.5)) +
  scale_shape_manual(values=c(16,17,18,15)) +
  facet_grid(Country ~ flavor) +
  xlab(expression(paste(Delta * SSE, " [%]"))) + 
  scale_x_continuous(breaks=seq(-80, 0, 20)) +  
  ylab(expression(paste(Delta * lambda, " [%]"))) +
  scale_y_continuous(breaks=seq(-80, 0, 20), limits=c(-100, 10)) +  
  xy_theme() +
  theme(legend.title=element_blank())
@


<<CES_alpha, results="asis">>=
data_CES_alpha <- 
  table_data %>% 
  filter(Model=="CES" | Model=="Ref.") %>% 
  select(Country, Model, CSP, flavor, Energy, Nest, alpha_1, alpha_2, alpha_3) %>%
  plyr::rename(c("flavor" = "Factors of prod.",
                 "alpha_1" = "$\\alpha_k$",
                 "alpha_2" = "$\\alpha_l$",
                 "alpha_3" = "$\\alpha_e$"))
myXTable(data_CES_alpha,
         caption="Output elasticities~($\\alpha$) for all models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=3)
@


<<CES_sigma, results="asis">>=
### Is sigma_data defined anywhere?

# data_CES_sigma_raw <- sigma_data %>% select(Country, Model, flavor, Energy, Nest, CSP, sigma_1, sigma)
# data_CES_sigma_raw <- plyr::rename(data_CES_sigma_raw, c("sigma" = "$\\sigma$",
#                                                          "sigma_1" = "$\\sigma_1$"))
# data_CES_sigma_raw <- plyr::rename(data_CES_sigma_raw, c("flavor" = "Factors of prod."))
# data_CES_sigma_raw$CSP <- plyr::mapvalues(data_CES_sigma_raw$CSP, 
#                                          from=c("w/ CSP", "w/o CSP"), 
#                                          to=c("Adhere", "Reject"))
# data_CES_sigma_raw$Energy <- plyr::mapvalues(data_CES_sigma_raw$Energy, 
#                                          from=c("Without energy", "With energy"), 
#                                          to=c("Without", "With"))

data_CES_sigma_raw <- AllCoeffs %>%
  filter(model=="CES") %>%
   mutate(
     Nest = plyr::mapvalues(nest,
                            from=c("kl", "kle", "lek", "ekl"),
                            to=c("$kl$", "$(kl)e$", "$(le)k$", "$(ek)l$")),
     CSP = plyr::mapvalues(CSP, 
                           from=c("w/ CSP", "w/o CSP"), 
                           to=c("Adhere", "Reject")),
     Energy = plyr::mapvalues(energy, 
                              from=c("Without energy", "With energy"), 
                              to=c("Without", "With"))
     ) %>%
  select(Country, flavor, Energy, Nest, CSP, sigma_1, sigma) %>%
  plyr::rename(
    c("sigma" = "$\\sigma$",
      "sigma_1" = "$\\sigma_1$",
      "flavor" = "Factors of Prod."))

myXTable(data_CES_sigma_raw,
         caption="Factor substitution~($\\sigma$) for CES models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@

<<Graphs_CESlek-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="CES models with $kl$ and ($le$)$k$ nesting that reject the CSP. Solid line is historical GDP.">>=
fittedGraphData_lek <- fitted_and_resid_data %>% filter(model=="CES" & CSP=="w/o CSP" & (nest == "kl" | nest == "lek"))
fittedGraphNoCSP(fittedGraphData_lek)
@

<<Graphs_CESekl-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="CES models with $kl$ and ($ek$)$l$ nesting that reject the CSP. Solid line is historical GDP.">>=
fittedGraphData_ekl <- 
  fitted_and_resid_data %>% 
  filter(model=="CES" & CSP=="w/o CSP" & (nest == "kl" | nest == "ekl"))
fittedGraphNoCSP(fittedGraphData_ekl)
@
%

<<Graphs_CESkle-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for CES models with $(kl$)$e$ nesting.">>=
cesResidualPlot2(
  fitted_and_resid_data %>% 
    filter(model=="CES" & CSP=="w/o CSP" & (nest=="kle" | nest=="kl"))
)
@

<<Graphs_CESlek-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for CES models with ($le$)$k$ nesting.">>=
cesResidualPlot2(
  fitted_and_resid_data %>% 
    filter(model=="CES" & CSP=="w/o CSP" & (nest == "lek" | nest=="kl"))
)
@

<<Graphs_CESekl-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for CES models with $(ek$)$l$ nesting.">>=
cesResidualPlot2(
  fitted_and_resid_data %>% 
    filter(model=="CES" & CSP=="w/o CSP" & (nest=="ekl" | nest=="kl"))
)
@

<<SRsse_CES_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Solow Residuals~($\\lambda$) and mean squared error~($sse$). $\\lambda$ and $sse$ values for the reference (exponential-only) model are shown as gridlines.">>=
data_sr_sse <- 
  AllCoeffs %>% 
  filter(model=="CES") %>% 
  mutate(nest = 
           plyr::mapvalues(
             nest, 
             from=c("kl", "kle", "lek", "ekl"), 
             to=c("kl", "(kl)e", "(le)k", "(ek)l")
             ),
         Model = interaction(nest, CSP, sep = " ", drop=TRUE),
         Inputs = flavor
  )
ggplot() +
  geom_point(data=data_sr_sse, mapping=aes(x=sse, y=lambda, color=energy, size=CSP, shape=nest)) +
  geom_vline(aes(xintercept = sse), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, sse), 
             colour="gray50", size=0.1) +
  geom_hline(aes(yintercept = lambda), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, lambda), 
             colour="gray50", size=0.1) +
  scale_size_manual(values=c(2,4)) +
  scale_shape_manual(values=c(1,0,3,4)) + 
  facet_grid(flavor ~ Country) +
  scale_y_continuous(breaks=c(0, 0.01, 0.02, 0.03), limits=c(0, 0.035)) +
  xlab("SSE") + 
  ylab(expression(lambda)) +
  xy_theme() +
  theme(legend.title=element_blank())

@


<<SRsse_CES_graph_2, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=2.5, fig.cap="Solow Residuals~($\\lambda$) and mean squared error~($sse$). $\\lambda$ and $sse$ values for the reference (exponential-only) model are shown as gridlines. This version uses our proposed new style.">>=
data_sr_sse <- 
  AllCoeffs %>% 
  filter(model=="CES") %>% 
  mutate(nest = 
           plyr::mapvalues(
             nest, 
             from=c("kl", "kle", "lek", "ekl"), 
             to=c("kl", "(kl)e", "(le)k", "(ek)l")
             ),
         Model = interaction(nest, CSP, sep = " ", drop=TRUE),
         Inputs = flavor
  )

p <- ggplot() +
  geom_point(
    data=data_sr_sse, 
    mapping=aes(
      x=lambda, 
      y=sse, 
      fill=Model, 
      shape=Model, 
      size=Model, 
      color=Inputs
      )) +
  geom_vline(aes(xintercept = lambda), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, lambda), 
             colour="gray50", size=0.1) +
  geom_hline(aes(yintercept = sse), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, sse), 
             colour="gray50", size=0.1) +
  facet_grid(. ~ Country) +
  scale_x_continuous(breaks=c(0, 0.01, 0.02, 0.03), limits=c(0, 0.035)) +
  xlab(expression(lambda)) +
  scale_y_continuous(limits=c(-0.05, 0.7)) +
  ylab("SSE") + 
  labs(color = "Factors of production") +
  xy_theme() # +
  # theme(legend.title=element_blank())

# Add our style
model_points_style(p)

@

<<Factor_shares_bar_graph_function>>=
fsbg <- function(coun, mod){
  bar_chart_data <- 
    AllCoeffs %>% 
    filter(Country==coun & model==mod) %>% 
    select(Country, model, flavor, energy, nest, CSP, alpha_1, alpha_2, alpha_3) %>%
    mutate(nest =   # Change nest to a nicer-looking nest string
             plyr::mapvalues(nest, 
                             from=c("kl", "kle", "lek", "ekl"), 
                             to=c("kl", "(kl)e", "(le)k", "(ek)l")),
           label = # Add a label column
              paste(CSP, flavor, energy, nest, sep=", "),
           label =  # Add row numbers to the label column
              paste(paste0(1:length(label), ". "), label)
    )
  # Capture the order that we want for the models on the vertical axis.
  order <- bar_chart_data$label
  # Now melt the data
  ### tidyr::spread and tidyr::gather are preferred in most cases now
#   bar_chart_data <- melt(bar_chart_data, 
#                          measure.vars = c("alpha_1", "alpha_2", "alpha_3"), 
#                          value.name = "value", 
#                          variable.name = "variable")
  bar_chart_data <-
    bar_chart_data %>% gather( key=variable, value=value, alpha_1 : alpha_3 )

  # Make the plot
  plot <- ggplot(bar_chart_data, mapping=aes(x=label, y=value, fill=variable, width=0.4)) + 
    geom_bar(stat="identity") + 
    xlab("") +
    scale_x_discrete(limits=rev(order)) +
    ylab("") +
    scale_y_continuous(breaks=c(0, 0.5, 1)) + 
    guides(fill=guide_legend(title=NULL)) +
    coord_flip() + 
    scale_fill_brewer(palette="OrRd", 
                      labels=c(expression(alpha[k]), expression(alpha[l]), expression(alpha[e]))) +
    xy_theme() +
    theme(axis.ticks.y = element_blank())
  return(plot)
}
@

<<Factor_shares_graph_PT, fig.pos="H", fig.align='center', fig.width=7.5, fig.height=2.5, fig.cap="Factor shares ($\\alpha$ values) for CES models for Portugal.">>=
fsbg(coun = "PT", mod = "CES")
@

<<Factor_shares_graph_UK, fig.pos="H", fig.align='center', fig.width=7.5, fig.height=2.5, fig.cap="Factor shares ($\\alpha$ values) for CES models for the UK.">>=
fsbg(coun = "UK", mod = "CES")
@

<<output_elasticities_graph_ternary, fig.pos="H", fig.align="center", fig.width=6.5, fig.height=2.3, fig.cap="Ternary graph of output elasticities~($\\alpha$). This version shows all Unadjusted and Quality-adjusted points on the same graph. Perhaps it is easier to see the effect of quality-adjustment of data this way.">>=
#p <- triPlot(
#  data=
p <-
  AllCoeffs %>% filter(model == "CES") %>%
    mutate( nest = plyr::mapvalues(nest, 
                                   from=c("kle", "lek", "ekl"), 
                                   to=c("(kl)e", "(le)k", "(ek)l")),
            Model = interaction(nest, CSP, sep = " ", drop=TRUE),
            Inputs = flavor
            ) %>%
  ggplot() +
  tri_theme() +
  tri_grid(grid_lines = 5) +
#  tri_labels(labels = c("alpha[k]", "alpha[l]", "alpha[e]")) +
  geom_tripoint(
    aes(
      x = alpha_1, y = alpha_2, z = alpha_3, 
      fill  = Model, 
      shape = Model,
      size = Model,
      color = Inputs)
  ) +
  labs(color = "Factors of production") +
  facet_grid(. ~ Country) 

  model_points_style(p)
@

<<output_elasticities_graph_ternary_2, fig.pos="H", fig.align="center", fig.width=6.5, fig.height=4.1, fig.cap="Ternary graph of output elasticities~($\\alpha$). This version splits the Unadjusted and Quality-adjusted values on their own graphs. This approach is parallel to the previous figures (historical data, fitted GDP, and residuals.">>=
p <- 
#    triPlot(
#  data=
    AllCoeffs %>% filter(model == "CES") %>%
    mutate( nest = plyr::mapvalues(nest, 
                                   from=c("kle", "lek", "ekl"), 
                                   to=c("(kl)e", "(le)k", "(ek)l")),
            Model = interaction(nest, CSP, sep = " ", drop=TRUE),
            Inputs = flavor) %>%
    ggplot() +
    tri_theme() + 
    tri_grid(grid_lines = 5) +
    tri_labels(labels = c("alpha[k]", "alpha[l]", "alpha[e]")) +
    geom_tripoint(
      aes(
        x = alpha_1, y = alpha_2, z = alpha_3, 
        fill  = Model, 
        shape = Model,
        size = Model
      # color = Inputs
      )
  ) +
  facet_grid(Inputs ~ Country)
    
  model_points_style_quad(p)
@

<<>>=
OEplot <- function( data ) {
  ggplot( data %>% 
          mutate(
            slice = interaction(Country, flavor, lex.order=TRUE, sep= " ")
            )
          ) +
    tri_theme() +
    tri_grid() +
    tri_labels(labels = c("alpha[k]", "alpha[l]", "alpha[e]"), parse = TRUE) +
    geom_tripath( 
      aes(x=oe1, y=oe2, z=oe3, 
          colour = Year,
          group=interaction(Country, nest, flavor)),
      alpha=0.6,  size=1) +
    geom_tripoint( 
      aes(x=oe1, y=oe2, z=oe3, colour = Year, size=Year), 
      alpha=0.7, shape=21)  +
    scale_colour_gradient(low = scales::muted("navy"),  high = "green") +
    facet_grid(nest ~ slice) +
    scale_size_continuous( range = c(1.4, 4))
}

OEplot2 <- function( data ) {
  ggplot( data %>% 
          mutate(
            slice = interaction(Country, flavor, lex.order=TRUE, sep= " ")
            )
          ) +
    tri_theme() +
    tri_grid() +
    tri_labels(labels = c("alpha[k]", "alpha[l]", "alpha[e]"), parse = TRUE) +
    geom_tripath( 
      aes(x=oe1, y=oe2, z=oe3, 
          colour = Year,
          group=interaction(Country, nest, flavor)),
      alpha=0.6,  size=1) +
    scale_colour_gradient(low = scales::muted("navy"),  high = "green") +
    facet_grid(nest ~ slice) +
    scale_size_continuous( range = c(1.4, 4))
}
OEplot(AllOE) 
OEplot2(AllOE) 
@


<<>>=
ggplot(AllOE %>% mutate(split = interaction(Country, flavor, lex.order=TRUE))) +
  tri_theme() + 
  tri_grid() +
  tri_labels( labels = c("alpha[k]", "alpha[l]", "alpha[e]") ) +
  geom_tripath(alpha = 0.8, size = 1.2,
               aes(x = oe1, y = oe2, z = oe3,
                   colour = Year, group = interaction(Country, nest, flavor)
               ) ) +
#  geom_tripoint( size = 1.8, alpha = 0.5,
#                 aes(x = oe1, y = oe2, z = oe3,
#                     shape = flavor,
#                     colour = Year
#                 ) ) +
  facet_grid( nest~ split) + 
  scale_shape_manual(values = c(21:25)) +
  scale_colour_gradient2(low = scales::muted("navy"), mid="red", high = "green", midpoint = 1985)

@

<<>>=
ggplot(AllOE %>% mutate(split = interaction(Country, flavor, lex.order=TRUE))) +
  tri_theme() + 
  tri_grid() +
  tri_labels( labels = c("alpha[k]", "alpha[l]", "alpha[e]") ) +
  geom_tripath(alpha = 0.8, size = 1.2,
               aes(x = oe1, y = oe2, z = oe3,
                   alpha = Year, 
                   colour = flavor,
                   group = interaction(Country, nest, flavor)
               ) ) +
  facet_grid( nest~ Country)  +
  scale_colour_manual(values = c("black", "gray70")) 
@


<<>>=

OEplot(ReModels)
OEplot2(ReModels)
@



<<resample_graph_alpha_ternary, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.0, fig.cap="$\\alpha_k$, $\\alpha_l$, and $\\alpha_e$ values for CES resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardTriPlot(data=resampleCoeffsCES, facet_formula=~Country, alpha=0.1,
                labels=c("alpha[k]", "alpha[l]", "alpha[e]"), size=2.0)
@

<<sigma_graph>>=
sigma_graph <- function(data){
  sigma_graph_data <- 
    data %>% 
    select(Country, CSP, flavor, energy, nest, 
           sigma_12, sigma_23, sigma_13, 
           sigma_12_3, sigma_23_1, sigma_13_2) %>%
    mutate(nest = plyr::mapvalues( # Change nest to a nicer-looking nest string
      nest, 
      from=c("kl", "kle", "lek", "ekl"), 
      to=c("kl", "(kl)e", "(le)k", "(ek)l"))
    ) %>%
    gather(variable, value, sigma_12, sigma_23, sigma_13, sigma_12_3, sigma_23_1, sigma_13_2) %>%
    mutate(label = paste(CSP, flavor, energy, nest, variable, sep=", ")) %>%
    na.omit()
  
  # return(sigma_graph_data)
  
  # Make the plot
  plot <- ggplot(sigma_graph_data, mapping=aes(x=label, y=value, fill=variable, width=0.4)) + 
    geom_bar(stat="identity") + 
    xlab("") +
    # scale_x_discrete(limits=rev(order)) +
    scale_x_discrete(labels=sigma_graph_data$label) +
    geom_hline(aes(yintercept = 1), colour="gray50", size=0.1) +
    ylab("") +
    # coord_trans(y="sigma") +
    scale_y_continuous(limits=c(0, 10), breaks=c(0, 1.0, 10)) +
    guides(fill=guide_legend(title=NULL)) +
    scale_fill_brewer(palette="OrRd") +
#     scale_fill_brewer(palette="OrRd",
#                       labels=c(expression(sigma[kl]), 
#                                expression(sigma[le]), 
#                                expression(sigma[ek]),
#                                expression(sigma["(kl)e"]),
#                                expression(sigma["(le)k"]),
#                                expression(sigma["(ek)l"]))) +
    coord_flip() + 
    xy_theme() +
    theme(axis.ticks.y = element_blank())
  return(plot)
}
@

<<sigma_graph_PT, fig.pos="H", fig.align='center', fig.width=7.5, fig.height=3.3, fig.cap="Elasticities of substitution~($\\sigma$) for Portugal.">>=
sigma_graph(AllCoeffs %>% filter(model=="CES", Country=="PT"))
@

<<sigma_graph_UK, fig.pos="H", fig.align='center', fig.width=7.5, fig.height=3.3, fig.cap="Elasticities of substitution~($\\sigma$) for the UK.">>=
sigma_graph(AllCoeffs %>% filter(model=="CES", Country=="UK"))
@

<<sigma_graph_2, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.82, fig.cap="Elasticities of substitution~($\\sigma$).">>=
breaks_labels = c(0.01, 0.1, 1, 10, 100)
p <- 
ggplot(
  AllCoeffs %>% 
    gather(type, value, matches("sigma")) %>% 
    filter(!is.na(value)) %>% 
    filter(! type %in% c("sigma", "sigma_1")) %>%
    mutate(nest = plyr::mapvalues(nest, 
                                  from=c("kle", "lek", "ekl"), 
                                  to=c("(kl)e", "(le)k", "(ek)l")),
           type = relevelFactor(type, c("sigma_12", "sigma_23", "sigma_13", "sigma_12_3", "sigma_23_1", "sigma_13_2")),
           Model = interaction(nest, CSP, sep = " ", drop=TRUE),
           Inputs = flavor
           )
  ) + 
  geom_point(aes(x=value, y=type, 
                 shape = Model, fill=Model, size=Model,
                 color=Inputs
                 )
                 # position = position_jitter(height=0.2, width=0)
             ) + 
  facet_grid( type ~ Country, scales = "free_y" ) + 
  scale_x_log10(limits = c(0.001,2000), breaks=breaks_labels, labels=breaks_labels) +
  xlab("") +
  geom_vline(xintercept = 1, color="gray50", size=0.2) +
  scale_y_discrete(labels = c(
    sigma_12 = expression(sigma[kl]),
    sigma_23 = expression(sigma[le]),
    sigma_13 = expression(sigma[ek]),
    sigma_12_3 = expression(sigma["(kl)"*e]),
    sigma_23_1 = expression(sigma["(le)"*k]),
    sigma_13_2 = expression(sigma["(ek)"*l]))
    ) +
  ylab("") +
  labs(color = "Factors of production") +
  xy_theme() +
  theme(
    legend.position="top",
    strip.text.y = element_blank(),
    axis.text.y = element_text(size=12)
    )

model_points_style(p)
@

\section{End EcolEcon2015A}
