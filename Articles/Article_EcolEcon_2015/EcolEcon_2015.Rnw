% This article has been prepared for publication in RStudio with knitr.
% According to http://www.elsevier.com/author-schemas/the-elsarticle-latex-document-class, we should be using the
% elsarticle.cls file.
% According to http://cdn.elsevier.com/assets/pdf_file/0006/109392/journal_refstyles.pdf, we should be using
% elsarticle-template-2-harv.tex as the template for the text.
% Furthermore, we should be using model2-names.bst for the bibliographic references.
% The approach here is to load the frontmatter and backmatter from elsarticle-template-2-harv.tex
% both ahead of and behind the text for our paper.
% -- Matthew Kuperus Heun, 2014-08-01

%% This is file `elsarticle-template-2-harv.tex',
%%
%% Copyright 2009 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle  Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for Elsevier's document class `elsarticle'
%% with harvard style bibliographic references
%%
%% $Id: elsarticle-template-2-harv.tex 155 2009-10-08 05:35:05Z rishi $
%% $URL: http://lenova.river-valley.com/svn/elsbst/trunk/elsarticle-template-2-harv.tex $
%%
\documentclass[preprint,authoryear,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[authoryear,preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,authoryear,1p,times]{elsarticle}
%% \documentclass[final,authoryear,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,authoryear,3p,times]{elsarticle}
%% \documentclass[final,authoryear,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,authoryear,5p,times]{elsarticle}
%% \documentclass[final,authoryear,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
%% \usepackage{graphics}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

\usepackage{wrapfig}    % Allows wrapping of text around figures
\usepackage{soul}       % Provides strikethrough text
\usepackage{float}      % Allows precise positioning of tables and figures within the text
\usepackage{amsmath}    % Allows \begin{equation*} \end{equation*} for unnumbered equations
\usepackage{multirow}   % To create multirow tables
\usepackage{hyperref}   % To create hyperlinks in the paper
\usepackage{microtype}  % produces hanging punctuation and beautiful type
\usepackage{booktabs}   % for beautiful tables
\usepackage{dcolumn}    % aligns table columns at decimal places


% From http://economics.utoronto.ca/osborne/latex/BIBTEX.HTM
\newcommand{\citeapos}[1]{\citeauthor{#1}'s (\citeyear{#1})} % Posessive citations. 

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
%% \usepackage{lineno}

%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon (default)
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   authoryear - selects author-year citations (default)
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%   longnamesfirst  -  makes first citation full author list
%%
%% \biboptions{longnamesfirst,comma}

% \biboptions{}

\journal{Ecological Economics}

\begin{document}

<<setup, echo=FALSE, message=FALSE, eval=TRUE, warning=FALSE>>=
library(EconData)
library(EconModels)
library(dplyr)
library(reshape2)
library(ggplot2)
library(mosaic)
library(xtable)
library(knitr)
library(texreg)

# Tell whether to re-run the analysis to create the models.
# This file will use previously-saved models to generate
# the paper if set to FALSE, greatly reducing time.
# If something changes in the data or in the code that
# performs the analysis, set 
# rerunModels = TRUE
# once to re-generate the information needed to 
# create the paper.
# ********************************************************
rerunModels=FALSE
rerunResampling=FALSE
nResamples <- 1000 # Number of resamples
# ********************************************************
opts_chunk$set(
  # ********************************************************
  eval=TRUE,
  # ********************************************************
  # tikz allows LaTeX code in graphical output. 
  # E.g., "$y$" for a variable name in the legend for a graph.  
  # dev='tikz',
  tidy=FALSE,
  comment=NA,
  # Tells whether to cache output from chunks are saved. Cacheing saves time. 
  # However, references to LaTeX tables DO NOT WORK if cacheing is turned on.
  cache=FALSE,
  warning=FALSE,  #Tells whether to show warnings in the output.
  # Turns off messages for all chunks. 
  # Set TRUE on an individual chunk to see it.
  message=FALSE, 
  # Tells whether to echo code for all chunks. 
  # Set TRUE on an individual chunk to see its code.
  echo=FALSE,
  # Sets all table captions to the top.
  xtable.caption.placement="top"
)

# This function is used in many places below.
myXTable <- function(data, caption, label, digits=2){
  table <- xtable(data, caption=caption, label=label, digits=digits)
  print(table, 
        caption.placement="top", 
        size="\\tiny", 
        include.rownames=FALSE, 
        math.style.negative=TRUE, 
        booktabs=TRUE)
}
@


\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{Energy and the CES production function}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{<author name>}
%% \address[label1]{<address>}
%% \address[label2]{<address>}

\author[IST]{Jo\~{a}o dos Santos}
\author[CalvinEngr]{Matthew Kuperus Heun\corref{cor1}}
\author[Leeds]{Paul Brockway}
\ead{mkh2@calvin.edu}
\author[Leeds]{Marco Sekai}
\author[IST]{Tiago Domingos}
\author[CalvinMath]{Randall Pruim}

\address[IST]{IST, Lisbon, Portugal}
\address[Leeds]{Leeds University, Leeds, UK}
\address[CalvinEngr]{Engineering Department, Calvin College, Grand Rapids, MI 49546, USA}
\address[CalvinMath]{Mathematics \& Statistics Department, Calvin College, Grand Rapids, MI 49546, USA}
\cortext[cor1]{Corresponding author}

\begin{abstract}
%% Text of abstract
**** Add abstract ****
\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
economic growth \sep exergy \sep energy \sep CES
%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)
\end{keyword}

\end{frontmatter}

% \linenumbers
%% main text


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction} 
\label{sec:Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This is a study of the effects of quality-adjusted production function inputs
on the importance of energy in the production function.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coordinates of Analysis} 
\label{sec:Coordinates}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section describes the coordinates of analysis and briefly reviews 
literature related to each.


%++++++++++++++++++++++++++++++
\subsection{Mathematical Forms of the Energy-augmented Production Function} 
\label{sec:Prod_Func_Forms}
%++++++++++++++++++++++++++++++

In this paper, we assess a prominent energy-augmented production function:
Constant Elasticity of Substitution (CES).
The CES model is assessed relative to 
a model of exponential growth only.
The following subsections describe each.







%------------------------------
\subsubsection{Constant Elasticity of Substitution Production Function (CES)} 
\label{sec:CES}
%------------------------------

The energy-augmented 
Constant Elasticity of Substitution (CES) production function%
  \footnote{
  We use the The \texttt{R} 
  % \citep{R} 
  package \texttt{micEconCES} 
  % \citep{Henningsen:2011td} 
  to estimate the CES production function.
  }
can be given as
%
\begin{equation} \label{eq:CESgeneric}
  y = \gamma \: A \: \left\{\delta \left[\delta_1 x_1^{-\rho_1} 
      + (1-\delta_1)x_2^{-\rho_1} \right]^{\rho/\rho_1} 
      + (1-\delta) x_3^{-\rho} \right\}^{-1/\rho}; 
      A \equiv \mathrm{e}^{\lambda (t-t_0)},
\end{equation}
%
where
$y \equiv Y/Y_{0}$,
$\gamma$ is a scale parameter,
e is the base of the natural logarithm, 
$\lambda$ is the Solow residual (often thougth to represent the pace of technological progress),
$t$ (time) is measured in years,
$x_1$, $x_2$, and $x_3$ are factors of production
and permutations of capital~($k$), labor~($l$), and energy~($e$),
$k \equiv K/K_{0}$, 
$l \equiv L/L_{0}$, 
$Y$ (economic output) is represented by GDP, 
$K$ (capital) is expressed in currency units, 
$L$ (labor) is expressed in workers or work-hours/year, and
the 0 subscript indicates values at an initial year.%
  \footnote{Dimensionless, indexed quantities are represented by 
  lower-case symbols 
  ($y$, $k$, $l$, $e$, $q$, $x$, and $u$), and dimensional 
  quantities are represented by upper-case symbols 
  ($Y$, $K$, $L$, $E$, $Q$, $X$, and $U$). 
  Model parameters are represented by Greek letters
  ($\alpha_1$, $\alpha_2$, $\lambda$, $\theta$).
  }
The CES model without energy is given in Equation~\ref{eq:CESkl}.
%
\begin{equation} \label{eq:CESkl}
  y = \gamma \: A \: \left[\delta_1 k^{-\rho_1} 
      + (1-\delta_1)l^{-\rho_1} \right]^{-1/\rho_1}; 
      A \equiv \mathrm{e}^{\lambda (t-t_0)} . 
\end{equation}
%
Equation~\ref{eq:CESkle} augments Equation~\ref{eq:CESkl} with energy 
using a ($kl$)($e$) nesting structure, as is typical in the literature. 
Equation~\ref{eq:CESkl} is a degenerate form of Equation~\ref{eq:CESkle} 
where $\delta \rightarrow 1$. 
%
\begin{equation} \label{eq:CESkle}
  y = \gamma \: A \: \left\{\delta \left[\delta_1 k^{-\rho_1} 
      + (1-\delta_1)l^{-\rho_1} \right]^{\rho/\rho_1} 
      + (1-\delta) e^{-\rho} \right\}^{-1/\rho}; 
      A \equiv \mathrm{e}^{\lambda (t-t_0)}.
\end{equation}
%
In the CES production function, 
$\gamma$ is a fitting parameter that accounts for an atypical first year. 
The fitting parameters $\rho_1$ and $\rho$ indicate elasticities 
of substitution ($\sigma_1$ and $\sigma$).
The elasticity of substitution 
between capital ($k$) and labor ($l$) is given by 
$\sigma_1 = \frac{1}{1+\rho_1}$, and
the elasticity of substitution between ($kl$) and ($e$) is given by 
$\sigma = \frac{1}{1+\rho}$. 
As $\rho_1 \rightarrow 0$, $\sigma_1 \rightarrow 1$,
and the embedded CES production function for $k$ and $l$ degenerates 
to the Cobb-Douglas production function.
Similarly, as $\rho \rightarrow 0$, $\sigma \rightarrow 1$,
and the CES production function for $(kl)$ and $(e)$ degenerates 
to the Cobb-Douglas production function.
As $\sigma \rightarrow \infty$ ($\rho \rightarrow -1$), 
($kl$) and ($e$) are perfect substitutes. 
As $\sigma \rightarrow 0$ ($\rho \rightarrow \infty$), 
($kl$) and ($e$) are perfect complements: 
no substitution is possible. Similarly, 
as $\sigma_1 \rightarrow 0$ ($\rho_1 \rightarrow \infty$),
$k$ and $l$ are perfect complements.
$\delta_1$ describes the relative importance of capital ($k$)
and labor ($l$), and
$\delta$ describes the importance of ($kl$) relative to ($e$).

Constraints on the fitting parameters include 
$\delta_1 \in [0,1]$,
$\delta \in [0,1]$,
$\rho_1 \in [-1,0) \cup (0,\infty)$, and
$\rho \in [-1,0) \cup (0,\infty)$. 

Two other nestings of the factors of production ($k$, $l$, and $e$)
are possible with the CES model.
%
\begin{equation} \label{eq:CESlek}
  y = \gamma \: A \: \left\{\delta \left[\delta_1 l^{-\rho_1} 
      + (1-\delta_1) e^{-\rho_1} \right]^{\rho/\rho_1} 
      + (1-\delta) k^{-\rho} \right\}^{-1/\rho}; 
      A \equiv \mathrm{e}^{\lambda (t-t_0)}
\end{equation}
%
\begin{equation} \label{eq:CESekl}
  y = \gamma \: A \: \left\{\delta \left[\delta_1 e^{-\rho_1} 
      + (1-\delta_1) k^{-\rho_1} \right]^{\rho/\rho_1} 
      + (1-\delta) l^{-\rho} \right\}^{-1/\rho}; 
      A \equiv \mathrm{e}^{\lambda (t-t_0)}
\end{equation}
% 
Note that $\rho$ ($\sigma$), $\rho_1$ ($\sigma_1$), $\delta$, and $\delta_1$ have different
meanings depending upon the nesting of the factors of production.

For the CES model, factors shares~($\alpha_1$, $\alpha_2$, and $\alpha_3$) are calculated by
$\alpha_1 = \delta_1$, $\alpha_2 = 1 - \delta_1$, and $\alpha_3 = 0$ 
for the CES model with two factors of production
and by 
$\alpha_1 = \delta \delta_1$, $\alpha_2 = \delta(1 - \delta_1)$, and $\alpha_3 = 1 - \delta$
for the CES model with three factors of production and the ($kl$)$e$ nesting.
The values of $\alpha_1$, $\alpha_2$, and $\alpha_3$ are interpreted as
factor shares for capital, labor, and energy, respectively,
as shown in Table \ref{tab:CES_abg_equations}.

\begin{table} \caption{Equations for $\alpha_1$, $\alpha_2$, and $\alpha_3$ 
                        (factor shares for capital, labor, and energy, respectively)
                        for the various CES nestings.} 
\label{tab:CES_abg_equations} 
  \begin{center}
    \begin{tabular}{c c c c} 
      \toprule
      Nesting    & $\alpha_1$              & $\alpha_2$              & $\alpha_3$       \\
      \midrule
      ($kl$) \;  & $\delta_1$              & $1 - \delta_1$          & 0          \\
      ($kl$)$e$  & $\delta \delta_1$       & $\delta (1 - \delta_1)$ & $1 - \delta$ \\   
      ($le$)$k$  & $1 - \delta$            & $\delta \delta_1$       & $\delta (1 - \delta_1)$ \\
      ($ek$)$l$  & $\delta (1 - \delta_1)$ & $1 - \delta$            & $\delta \delta_1$ \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}


%------------------------------
\subsubsection{Exponential Production Function (reference model)} 
\label{sec:exp}
%------------------------------

We define an exponential-only reference model for economic growth
in Equation~\ref{eq:exponential-only-model}.
%
\begin{equation} \label{eq:exponential-only-model}
  y = \theta A \; ; \; A \equiv \mathrm{e}^{\lambda(t-t_0)} \; .
\end{equation}
%
We expect that the reference model
will have a larger fitted Solow residual term than
the CES model, because no factors of production are
included in the reference model to drive economic growth.
Indeed, in the reference model, 
all economic growth is attributed to the Solow residual~($\lambda$).

In contrast, it is not necessarily true that 
CES models will exhibit lower $sse$ than the reference model
shown in Equation~\ref{eq:exponential-only-model}.
The CES model has more fitting parameters,
but it incorporates the factors of production
at constant returns to scale. 
The reference model has $\alpha_1 + \alpha_2 + \alpha_3 = 0$,
whereas the CES model~(Equation~\ref{eq:CESgeneric})
implicitly assumes constant returns to scale.
Thus, if the factors of production~($\alpha_1$, $\alpha_2$, and $\alpha_3$) 
are poorly correlated to output~($y$),
the constant returns to scale constraint may cause higher $sse$ for
the CES model relative to the reference model.


%++++++++++++++++++++++++++++++
\subsection{Economies} 
\label{sec:Economies}
%++++++++++++++++++++++++++++++

Discuss economies here.

UK and Portugal.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sources of Data}
\label{sec:Sources_of_Data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Discuss data sources here.


%++++++++++++++++++++++++++++++
\subsection{Historical Data} 
\label{sec:Historical_Data}
%++++++++++++++++++++++++++++++

Historical data are stored in the \texttt{IST} and \texttt{Leeds} data sets.

<<Formulas>>=
# Set up the formulas for each type of analysis.
# These formulas contain energy. 
# We can use keep_summands to drop the energy term (3rd summand on the rhs)
# later if needed.
formulas <- 
  list( 
    PT = c(unadjusted = build_formula("iGDP", list("iKstkS.L", "iL", "iXpMP", "iYear")),
             adjusted = build_formula("iGDP", list("iKservS.L", "ihLest", "iUMP", "iYear"))),
    UK = c(unadjusted = build_formula("iGDP", list("iKstkO.WwithRD", "iL", "iXp", "iYear")),
             adjusted = build_formula("iGDP", list("iKservO.WwithRD", "ihLest", "iU", "iYear")))
  )
countries <- names(formulas)
flavors <- names(formulas$PT)
@

<<Data>>=
# Create the historicalData data frames
historicalData <- list()
commonVars <- c("Year", "Country", "Source")
historicalData$PT <- filter(IST, Country == "PT") 
historicalData$PT <- historicalData$PT[ , unique(c(commonVars,
                                                   all.vars(formulas$PT$unadjusted), 
                                                   all.vars(formulas$PT$adjusted)))]
historicalData$UK <- filter(Leeds, Country == "UK")
historicalData$UK <- historicalData$UK[ , unique(c(commonVars,
                                                   all.vars(formulas$UK$unadjusted), 
                                                   all.vars(formulas$UK$adjusted)))]
@

For unadjusted variables, we use the time series shown in Table~\ref{tab:unadjusted_variables}.

\begin{table} \caption{Unadjusted time-series variables.} 
\label{tab:unadjusted_variables} 
  \begin{center}
    \begin{tabular}{r l l} 
      \toprule
      Variable    & Portugal           & UK                 \\
      \midrule
      Output      & \Sexpr{summands(formulas$PT$unadjusted, n=1, right=FALSE)}   
                                                             & \Sexpr{summands(formulas$UK$unadjusted, n=1, right=FALSE)}\\
      Capital     & \Sexpr{summands(formulas$PT$unadjusted, 1)} & \Sexpr{summands(formulas$UK$unadjusted, 1)} \\
      Labor       & \Sexpr{summands(formulas$PT$unadjusted, 2)} & \Sexpr{summands(formulas$UK$unadjusted, 2)} \\
      Energy      & \Sexpr{summands(formulas$PT$unadjusted, 3)} & \Sexpr{summands(formulas$UK$unadjusted, 3)} \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

For quality-adjusted variables, we use the time series shown in Table~\ref{tab:quality_adjusted_variables}.

\begin{table} \caption{Quality-adjusted time series variables.} 
\label{tab:quality_adjusted_variables} 
  \begin{center}
    \begin{tabular}{r l l} 
      \toprule
      Variable    & Portugal         & UK               \\
      \midrule
      Output      & \Sexpr{summands(formulas$PT$adjusted, n=1, right=FALSE)}   
                                                           & \Sexpr{summands(formulas$UK$adjusted, n=1, right=FALSE)} \\
      Capital     & \Sexpr{summands(formulas$PT$adjusted, 1)} & \Sexpr{summands(formulas$UK$adjusted, 1)} \\
      Labor       & \Sexpr{summands(formulas$PT$adjusted, 2)} & \Sexpr{summands(formulas$UK$adjusted, 2)} \\
      Energy      & \Sexpr{summands(formulas$PT$adjusted, 3)} & \Sexpr{summands(formulas$UK$adjusted, 3)} \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

Unadjusted and quality-adjusted data for both Portugal and the United Kingdom 
are shown in Figure~\ref{fig:Historical_Data_Graph}.

<<Historical_Data_Graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Historical data.", warning=FALSE>>=
# Melt the data into a form that is useful in a couple places
histDataForGraph <- leaf_apply(formulas, class = "formula", f=function(form, name){
  meta <- strsplit(name, split="[.]") %>% unlist
  Country <- meta[1]
  flavor <- meta[2]
  measure.vars <- c(summands(form, right=FALSE), summands(form, 1:3))
  trimmed_historical_data <- historicalData[[Country]][c("Year", measure.vars)]
  mtrimmed_historical_data <- melt(trimmed_historical_data, measure.vars = measure.vars, 
                                   value.name = "value", variable.name = "variable")
  mtrimmed_historical_data$Country <- Country
  mtrimmed_historical_data$flavor <- if (flavor == "adjusted") "Quality-adjusted" else "Unadjusted"
  return(mtrimmed_historical_data)
}) %>% do.call(rbind, .)

# Change variable names to make a nicer-looking graph
histDataForGraph$variable <- plyr::mapvalues(histDataForGraph$variable,
                                             from=c("iGDP", 
                                                    "iKstkS.L", "iKservS.L", "iKstkO.WwithRD", "iKservO.WwithRD",
                                                    "iL", "ihLest",
                                                    "iXpMP", "iXp", "iUMP", "iU"),
                                             to=c("y", 
                                                  "k", "k", "k", "k",
                                                  "l", "l",
                                                  "e", "e", "e", "e"))

# Relevel factors before plotting
histDataForGraph$Country <- relevelFactor(as.factor(histDataForGraph$Country), c("PT", "UK"))
histDataForGraph$flavor <- relevelFactor(as.factor(histDataForGraph$flavor), c("Unadjusted", "Quality-adjusted"))
histDataForGraph$variable <- relevelFactor(as.factor(histDataForGraph$variable), unique(histDataForGraph$variable))

historicalPlot(histDataForGraph, 
               mapping=aes(x=Year, y=value, group=variable, linetype=variable), 
               facet_formula = Country ~ flavor, 
               line_types = c(1,2,4,3,2,4,3,2,3,2,3)) + 
  scale_y_continuous(breaks=c(1, 2, 4, 6, 8, 10, 12)) +
  coord_cartesian(ylim=c(0.5, 13)) +
  xlab("") + 
  ylab("Indexed (1960=1)")
@

<<Pre-econometric_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Pre-econometric data.", warning=FALSE>>=
pre_econometric_data <- leaf_apply(formulas, class = "formula", f=function(form, name){
  meta <- strsplit(name, split="[.]") %>% unlist
  Country <- meta[1]
  flavor <- meta[2]
  nums <- summands(form, n=1:3)
  denom <- summands(form, n=1, right=FALSE)
  ratios <- lapply(nums, function(num) {paste(num, denom, sep="/")}) %>% unlist
  coltemplate <- build_formula(NULL, c("Year", ratios))
  trimmed_historical_data <- historicalData[[Country]][all.vars(coltemplate)]
  ratio_data <- evalFormula(coltemplate, data=trimmed_historical_data)$right
  mratio_data <- melt(ratio_data, measure.vars = ratios, value.name = "ratio", variable.name = "variable")
  mratio_data$Country <- Country
  mratio_data$flavor <- if (flavor == "adjusted") "Quality-adjusted" else "Unadjusted"
  return(mratio_data)
}) %>% do.call(rbind, .)

# Fix levels
pre_econometric_data$flavor <- relevelFactor(as.factor(as.character(pre_econometric_data$flavor)), 
                                               c("Unadjusted", "Quality-adjusted"))
pre_econometric_data$Country <- relevelFactor(as.factor(pre_econometric_data$Country), 
                                              c("PT", "UK"))
pre_econometric_data$variable <- relevelFactor(as.factor(pre_econometric_data$variable),
                                               unique(pre_econometric_data$variable))
# Now make the plot of pre-econometric data
historicalPlot(pre_econometric_data, 
               mapping=aes(x=Year, y=ratio, group=variable, linetype=variable), 
               facet_formula = Country ~ flavor, 
               line_types = c(2,4,3, 2,4,3, 2,3,2, 3)) + 
  xlab("") + 
  ylab("Indexed (1960=1)")
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parameter Estimation (Without Cost-share Theorem)}
\label{sec:parameter_estimation_noCSP}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Parameter estimation is accomplished with \texttt{formula}s of the form
% %
% \begin{equation} \label{eq:formulas}
%   y \sim x_1 + x_2 + x_3 + time,
% \end{equation}
% %
% where $y$ is economic output and 
% $x_1$, $x_2$, and $x_3$ are factors of production
% and permutations of
% capital ($k$), labor ($l$), and energy ($e$).
% (The factors of production may be quality-adjusted.)
% $time$ is the time variable, usually \texttt{iYear}. 
% The \texttt{formula}s are used in a fitting function such as 
% \texttt{cdModel} to create a \texttt{model} object.
% The function \texttt{naturalCoef} extracts reasonable
% coefficients from \texttt{model} objects.
% 
% Note that in the fitting process for the Cobb-Douglas equation,
% $\texttt{scale} = \theta$, 
% $\alpha_1 = \alpha$,
% $\alpha_2 = \beta$, and
% $\alpha_3 = \gamma$,
% when the \texttt{formula} is specified as 
% %
% \begin{equation} \label{eq:formula_kle}
%   \texttt{y} \sim \texttt{k + l + e + time}.
% \end{equation}
% %
% Note that for the CES model, $\texttt{scale} = \gamma$ and is expected to be close to unity. 

The models being fit can be described by the algebraic form of the model 
(Cobb-Douglas, CES, etc.) and a formula that enumerates 
which data variables are being used in which roles to fit the model.  
A formula of the form
%
\begin{equation} \label{eq:formulas-3-factor}
y \sim x_1 + x_2 + x_3 + t,
\end{equation}
%
or 
%
\begin{equation} \label{eq:formulas-2-factor}
y \sim x_1 + x_2 + t,
\end{equation}
%
describes the economic output variable ($y$, usually \texttt{iGDP},
                                        indexed GDP) 
and the factors of production ($x_1$, $x_2$, and $x_3$,
                               which will be some measure of capital, labor, and energy, 
                               but perhaps not in that order), 
and a time variable ($t$, usually \texttt{iYear}, 
                     the number of years since the beginning of data collection).  
All of the models assume an error term that is additive on the 
logarithmic scale and are fit by the method of least squares.  
Model fitting provides estimates for all parameters in the model.

<<Models>>=
fileNameCDCES <- "EcolEcon2015ModelsCDCES.rds"
fileNameCSP <- "EcolEcon2015ModelsCSP.rds"
fileNameExp <- "EcolEcon2015ModelsExp.rds"
if (!rerunModels){
  # load from the file on disk
  models <- readRDS(fileNameCDCES)
  modelsCSP <- readRDS(fileNameCSP)
  modelsExp <- readRDS(fileNameExp)
} else {
  # re-run the models and save to disk.
  # In RStudio, be sure to set the working directory to the source file directory.
  
  #
  # Models that are exponential only, y = A * exp(lambda*t)
  #
  modelsExp <- list()
  alphaExp <- 0
  betaExp <- 0
  gammaExp <- 0
  for (country in countries){
    # Replace with better code later. 
    # Would like to say cdModel(formula, data, factorShares=c(alpha_1 = 0, alpha_2 = 0, alpha_3 = 0))
    # or something like that.
    form <- keep_summands(formulas[[country]][["unadjusted"]], n = c(-1, -2, -3)) # Keep none of the factors of production
    yVar <- as.name(summands(form, n=1, right=FALSE))
    tVar <- as.name(summands(form, n=1))
    data <- historicalData[[country]]
    expMod <- lm(log(eval(yVar)) ~ eval(tVar), data=data)
    attr(expMod, "naturalCoeffs") <- data.frame(lambda=coef(expMod)[[2]],
                                                  logscale=coef(expMod)[[1]], 
                                                  scale=exp(coef(expMod)[[1]]),
                                                  alpha_1=alphaExp,
                                                  alpha_2=betaExp, 
                                                  alpha_3=gammaExp)
    expMod$formula <- form
    sdata <- subset(data, select=all.vars(form))
    sdata <- data[complete.cases(sdata), unique(c(all.vars(form), names(data)))]
    expMod$data <- sdata
    expMod$response <- sdata$iGDP 
    modelsExp[[country]] <- expMod
  }
  # Save exponential models to disk.
  saveRDS(modelsExp, file=fileNameExp)

  
  #
  # Models that adhere to the cost-share theorem
  # 
  
  modelsCSP <- list()
  # Output elasticities based on cost share theorem
  alphaCSP <- 0.3 # Fraction of national accounts spent on capital
  betaCSP <- 0.7 # Fraction of national accounts spent on labor
  for (country in countries){
    for (adj in c("unadjusted", "adjusted")){
      # Replace with better code later. 
      # Would like to say cdModel(formula, data, factorShares=c(alpha_1 = 0.3, alpha_2 = 0.7, alpha_3 = 0))
      # or something like that.
      form <- keep_summands(formulas[[country]][[adj]], n=-3) # Remove energy
      yVar <- as.name(summands(form, n=1, right=FALSE))
      kVar <- as.name(summands(form, n=1))
      lVar <- as.name(summands(form, n=2))
      tVar <- as.name(summands(form, n=3))
      data <- historicalData[[country]]
      # Cobb-Douglas
      cdModCSP <- lm(log(eval(yVar)) - alphaCSP*log(eval(kVar)) - betaCSP*log(eval(lVar)) ~ eval(tVar), data = data)
      attr(cdModCSP, "naturalCoeffs") <- data.frame(lambda=coef(cdModCSP)[[2]],
                                                    logscale=coef(cdModCSP)[[1]], 
                                                    scale=exp(coef(cdModCSP)[[1]]),
                                                    alpha_1=alphaCSP,
                                                    alpha_2=betaCSP, 
                                                    alpha_3=0)
      cdModCSP$formula <- form
      sdata <- subset(data, select=all.vars(form))
      sdata <- data[complete.cases(sdata), unique(c(all.vars(form), names(data)))]
      cdModCSP$data <- sdata
      cdModCSP$response <- sdata$iGDP
      modelsCSP[[country]][[adj]][["noE"]][["CD"]] <- cdModCSP
      # CES
      cesModCSP <- plm(log(eval(yVar) / (alphaCSP*eval(kVar)^(-rho_1) + betaCSP*eval(lVar)^(-rho_1))^(-1/rho_1)) ~ eval(tVar),
                       data = historicalData[[country]],
                       params=c(rho_1=0.8))
      names(cesModCSP$coefficients) <- c("logscale", "lambda", "rho_1")
      cesModCSP$coefficients <- c(coef(cesModCSP), c(delta_1=alphaCSP, delta=1))
      attr(cesModCSP, "naturalCoeffs") <- EconModels:::makeNatCoef(cesModCSP)
      cesModCSP$formula <- form
      cesModCSP$data <- sdata
      modelsCSP[[country]][[adj]][["noE"]][["CES"]][["kl"]] <- cesModCSP
    }
  }
  # Save cost-share theorem models to disk.
  saveRDS(modelsCSP, file=fileNameCSP)

  #
  # Models where all parameters are estimated (models don't adhere to the cost share theorem)
  # 
  
  models <- list()
  for(country in countries){
    for (flavor in flavors){
      fnoE <- keep_summands(formulas[[country]][[flavor]], -3) # Drop the energy term (3rd term on RHS)
      fwithE <- formulas[[country]][[flavor]]
      # CD models
      models[[country]][[flavor]][["noE"]][["CD"]]   <- cdModel(fnoE, data = historicalData[[country]])
      models[[country]][[flavor]][["withE"]][["CD"]] <- cdModel(fwithE, data = historicalData[[country]])
      # CES models
      models[[country]][[flavor]][["noE"]][["CES"]][["kl"]] <- cesModel(fnoE, 
                                                                        data = historicalData[[country]], 
                                                                        nest=c(1,2))
      nestsWithE <- list(kle=c(1,2,3), lek=c(2,3,1), ekl=c(3,1,2))
      models[[country]][[flavor]][["withE"]][["CES"]] <- lapply(nestsWithE, function(nest){
          cesModel(formula=fwithE, data=historicalData[[country]], nest=nest)
        })
    }      
  }
  # Save models to disk.
  saveRDS(models, file=fileNameCDCES)
}
# Put all exponential model coefficients into a data frame
AllCoeffsExp <- leaf_apply(modelsExp, class = c("lm"), f = function(modExp, id){
  # Parse the id to find details of this model
  id_list <- strsplit(id, split = "[.]")[[1]]
  res <- rbind(list(Country = id_list[[1]], 
                    flavor = NA,
                    energy = "Without energy", 
                    model = "exp", 
                    nest = NA,
                    CSP = "Reject CSP"))
  res <- cbind(res, naturalCoef(modExp))
  # Now caluculate mean squared error (sse) for each model.
  sse <- sum(resid(modExp)^2)
  res <- cbind(res, list(sse=sse))
  return(res)
}) %>% do.call(plyr::rbind.fill, .)

# Put all the cost-share theorem (CSP) model coefficients into a data frame
AllCoeffsCSP <- leaf_apply(modelsCSP, class = c("lm"), f = function(modCSP, id){
  # Parse the id to find out whether this is quality-adjusted data, etc.
  id_list <- strsplit(id, split = "[.]")[[1]]
  res <- rbind(list(Country = id_list[[1]], 
                    flavor = if (id_list[[2]]=="unadjusted") "Unadjusted" else "Quality-adjusted",
                    energy = if (id_list[[3]]=="noE") "Without energy" else "With energy",
                    model=id_list[[4]], 
                    nest=if(length(id_list) > 4) id_list[[5]] else NA,
                    CSP="Adhere to CSP"))
  res <- cbind(res, naturalCoef(modCSP))
  # Now calculate the mean squared error (sse) for each model.
  sse <- sum(resid(modCSP)^2)
  res <- cbind(res, list(sse=sse))
  return(res)
}) %>% do.call(plyr::rbind.fill, .)

# Put all CD and CES model coefficients into a data frame.  
AllCoeffsNoCSP <- leaf_apply(models, class = c("CDEmodel", "cesModel", "LINEXmodel"), f = function(mod, id){
  # Parse the id to find out whether this is quality-adjusted data, etc.
  id_list <- strsplit(id, split = "[.]")[[1]]
  res <- rbind(list(Country = id_list[[1]], 
                    flavor = if (id_list[[2]]=="unadjusted") "Unadjusted" else "Quality-adjusted",
                    energy = if (id_list[[3]]=="noE") "Without energy" else "With energy",
                    model=id_list[[4]], 
                    nest=if(length(id_list) > 4) id_list[[5]] else NA,
                    CSP="Reject CSP"))
  res <- cbind(res, naturalCoef(mod))
  # Now calculate the sum of squared error (sse) for each model.
  sse <- sum(resid(mod)^2)
  res <- cbind(res, list(sse=sse))
  return(res)
}) %>% do.call(plyr::rbind.fill, .)
AllCoeffs <- plyr::rbind.fill(AllCoeffsExp, AllCoeffsCSP, AllCoeffsNoCSP)
# See hint at http://stackoverflow.com/questions/22555249/how-to-merge-data-frame-with-same-column-names
AllCoeffs <- as.data.frame(lapply(AllCoeffs, function(x) unname(unlist(x))))
# Get reference values for lambda and sse.
ref <- filter(AllCoeffs, model=="exp") %>% select(Country, sse, lambda)
colnames(ref)[colnames(ref)=="sse"] <- "sse_ref"
colnames(ref)[colnames(ref)=="lambda"] <- "lambda_ref"
AllCoeffs <- merge(AllCoeffs, ref)
# Calculate differences relative to the reference model
AllCoeffs <- mutate(AllCoeffs, 
                    Dlambda = abs(lambda) - abs(lambda_ref), 
                    Dsse = sse - sse_ref,
                    percDlambda = Dlambda / abs(lambda_ref) * 100, 
                    percDsse = Dsse / sse_ref * 100)

# Relevel factors
AllCoeffs$Country <- relevelFactor(as.factor(unlist(AllCoeffs$Country)), c("PT", "UK"))
AllCoeffs$flavor <- relevelFactor(as.factor(unlist(AllCoeffs$flavor)), c("Unadjusted", "Quality-adjusted"))
AllCoeffs$energy <- relevelFactor(as.factor(unlist(AllCoeffs$energy)), c("Without energy", "With energy"))
AllCoeffs$model <- relevelFactor(as.factor(unlist(AllCoeffs$model)), c("exp", "CD", "CES"))
AllCoeffs$nest <- relevelFactor(as.factor(unlist(AllCoeffs$nest)), c("kl", "kle", "lek", "ekl"))
AllCoeffs$CSP <- relevelFactor(as.factor(unlist(AllCoeffs$CSP)), c("Adhere to CSP", "Reject CSP"))
# Rearrange for easier viewing
AllCoeffs <- arrange(AllCoeffs, Country, model, flavor, energy, nest, CSP)
@

<<Resampling>>=
resampleFilename <- "EcolEcon2015kleResamples.rds"
if (rerunResampling){
  # Run some resampling on the PT and UK models that adhere to the cost-share theorem,
  # includes energy, uses quality-adjusted variables, and employs the (kl)e nesting.
  # This is u-g-l-y code. Just getting something running for now.
  modPT <- models$PT$adjusted$withE$CES$kle
  modUK <- models$UK$adjusted$withE$CES$kle
  resamplesPT <- resampledFits(modPT, method = "wild", n = nResamples)
  resamplesUK <- resampledFits(modUK, method = "wild", n = nResamples)
  resampleCoeffs <- rbind(cbind(resamplesPT$coeffs, Country="PT"), cbind(resamplesUK$coeffs, Country="UK"))
  resampleCoeffs$energy <- TRUE
  resampleCoeffs$nest <- "(kl)e"
  saveRDS(resampleCoeffs, file = resampleFilename)
} else {
  resampleCoeffs <- readRDS(resampleFilename)
}
@


<<Fitted_and_Residuals>>=
temp_data_exp <- leaf_apply(modelsExp, class=c("lm"), f = function(model, id){
  df <- data.frame(select(model$data, Year, Country))
  df$fittedExp <- exp(fitted(model)) # exp accounts for the fact that the model was fitted in log space.
  df$ResidualsExp <- resid(model)
  return(df)
}) %>% do.call(rbind, .)

temp_data_CSP <- leaf_apply(modelsCSP, class=c("plm", "lm"), f = function(model, id){
  df <- data.frame(select(model$data, Year, Country, iGDP))
  df$fitted <- exp(fitted(model)) # fitted is in log space. Return to regular space.
  df$Residuals <- resid(model) # residuals are in log space, and that is what we want.
  # Now add meta information
  id_list <- strsplit(id, split = "[.]")[[1]]
  df$flavor <- if (id_list[[2]] ==  "unadjusted") "Unadjusted" else "Quality-adjusted"
  df$energy <- if (id_list[[3]] == "noE") "Without energy" else "With energy"
  df$model <- id_list[[4]]
  df$nest <- if (length(id_list) > 4) id_list[[5]] else NA
  return(df)
}) %>% do.call(rbind, .)
temp_data_CSP$CSP <- "Adhere to CSP"

temp_data_noCSP <- leaf_apply(models, class=c("CDEmodel", "cesModel", "LINEXmodel"), f = function(model, id){
  df <- data.frame(select(model$data, Year)) 
  # By including [c(1:length(df$Year))] on the end, we 
  # add NAs (as appropriate) to the end of these columns
  # if data do not exist.
  df$fitted <- yhat(model)[c(1:length(df$Year))]
  df$Residuals <- resid(model)[c(1:length(df$Year))]
  # Now add the response, using the original variable name.
  df[[summands(model$formula, right = FALSE)]] <- response(model)[c(1:length(df$Year))]
  # Now add meta information
  id_list <- strsplit(id, split = "[.]")[[1]]
  len <- length(id_list)
  df$Country <- id_list[[1]]
  df$flavor <- if (id_list[[2]] ==  "unadjusted") "Unadjusted" else "Quality-adjusted"
  df$energy <- if (id_list[[3]] == "noE") "Without energy" else "With energy"
  df$model <- id_list[[4]]
  df$nest <- if (length(id_list) > 4) id_list[[5]] else NA
  return(df)  
}) %>% do.call(rbind, .)
temp_data_noCSP$CSP <- "Reject CSP"

temp_data_noExp <- plyr::rbind.fill( temp_data_CSP, temp_data_noCSP )

# Now merge the exponential-only model with the CSP and noCSP models. 
# Doing this, because the exponential-only model is kind-of like iY:
# it applies to all situations.
# temp_data <- merge(temp_data_noExp, temp_data_exp)
fitted_and_resid_data <- merge(temp_data_noExp, temp_data_exp)

# Create a column containing âˆ†r, the difference between a residual value
# and the residual value in the same year for the reference model
fitted_and_resid_data[["Dr"]] <- abs(fitted_and_resid_data[["Residuals"]]) - abs(fitted_and_resid_data[["ResidualsExp"]])

# Relevel factors before plotting
fitted_and_resid_data$Country <- relevelFactor(as.factor(fitted_and_resid_data$Country), c("PT", "UK"))
fitted_and_resid_data$flavor <- relevelFactor(as.factor(fitted_and_resid_data$flavor), c("Unadjusted", "Quality-adjusted"))
fitted_and_resid_data$energy <- relevelFactor(as.factor(fitted_and_resid_data$energy), c("Without energy", "With energy"))
fitted_and_resid_data$nest <- relevelFactor(as.factor(fitted_and_resid_data$nest), c("kl", "kle", "lek", "ekl"))

# Make data viewing easier
fitted_and_resid_data <- arrange(fitted_and_resid_data, Country, CSP, model, flavor, energy, nest)
@


%++++++++++++++++++++++++++++++
\subsection{Fits to historical data} 
\label{sec:fits_to_historical_data}
%++++++++++++++++++++++++++++++

<<Fitted_and_Residual_Graph_Functions>>=
fittedGraphNoCSP <- function(data){
  fittedGraphData <- select(data, Year, Country, iGDP, fitted, fittedExp, flavor, energy, CSP, nest)
  fittedGraphData <- melt(fittedGraphData, 
                     measure.vars = c("iGDP", "fitted", "fittedExp"), 
                     value.name = "value", 
                     variable.name = "variable")
  fittedGraphData$label <- with(fittedGraphData, paste(variable, energy))
  # Now collapse some of the information. Don't need multiple versions of the exponential model, e.g.
  fittedGraphData <- filter(fittedGraphData, label=="iGDP With energy" | label=="fittedExp With energy" |
                       label == "fitted With energy" | label == "fitted Without energy")
  fittedGraphData$label <- plyr::mapvalues(fittedGraphData$label, 
                                      from = c("iGDP With energy", 
                                               "fittedExp With energy",
                                               "fitted With energy",
                                               "fitted Without energy"), 
                                      to = c("GDP", 
                                             "Reference model",
                                             "With energy",
                                             "Without energy"))
  # Relevel factors
  fittedGraphData$label <- relevelFactor(as.factor(fittedGraphData$label), 
                                         c("GDP", "Reference model", "Without energy", "With energy"))
  # Make (and return) the graph
  ggplot() +
    geom_line(data=fittedGraphData, mapping=aes(x=Year, y=value, group=label, linetype=label)) +
    scale_linetype_manual(values=c(1,4,2,3), name="") +
    facet_grid(Country ~ flavor) +
    scale_x_continuous(breaks=c(1960, 1980, 2000)) +
    scale_y_continuous(breaks=c(1, 2, 4, 6, 8, 10, 12)) +
    xlab("") +
    ylab("Indexed GDP (1960=1)") +
    xy_theme()
}
@

Both historical GDP and fitted GDP are shown in 
Figures~\ref{fig:Graphs_CESkle-fitted}--\ref{fig:Graphs_CESekl-fitted}.
%
<<Graphs_CESkle-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="CES models with $kl$ and ($kl$)$e$ nesting that reject the CSP. Solid line is historical GDP.">>=
fittedGraphData_kle <- fitted_and_resid_data %>% filter(model=="CES" & CSP=="Reject CSP" & (nest == "kl" | nest == "kle"))
fittedGraphNoCSP(fittedGraphData_kle)
@
%
<<Graphs_CESlek-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="CES models with $kl$ and ($le$)$k$ nesting that reject the CSP. Solid line is historical GDP.">>=
fittedGraphData_lek <- fitted_and_resid_data %>% filter(model=="CES" & CSP=="Reject CSP" & (nest == "kl" | nest == "lek"))
fittedGraphNoCSP(fittedGraphData_lek)
@
%
<<Graphs_CESekl-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="CES models with $kl$ and ($ek$)$l$ nesting that reject the CSP. Solid line is historical GDP.">>=
fittedGraphData_ekl <- fitted_and_resid_data %>% filter(model=="CES" & CSP=="Reject CSP" & (nest == "kl" | nest == "ekl"))
fittedGraphNoCSP(fittedGraphData_ekl)
@


%++++++++++++++++++++++++++++++
\subsection{Fitting residuals} 
\label{sec:fitting_residuals}
%++++++++++++++++++++++++++++++

<<ResidualPlotFunction>>=

residualPlot <- function(data, withEnergyShape = 0){
  ggplot() +
    geom_point(data=data, mapping=aes(x=Year, y=Residuals, shape=energy, color=energy, size=energy)) +
    scale_shape_manual(values=c(1, withEnergyShape)) +
    scale_size_manual(values=c(4,4)) +
    facet_grid(Country ~ flavor) +
    # geom_hline(aes(yintercept = 0), colour="gray50", size=0.1) +
    geom_hline(yintercept = 0, colour="gray50", size=0.1) +
    scale_x_continuous(breaks=c(1960, 1980, 2000)) +
    xlab("") +
    ylab("r") + 
    xy_theme() +
    theme(legend.title=element_blank())
}

# This version also plots reference model residuals.
# But the reference model dwarfs all other residuals and looks bad on the graph.
# So, I decided not to use this. ---MKH, 14 Aug 2015

# residualPlot <- function(data, withEnergyShape = 0){
#   # Keep only the data we need
#   residGraphData <- select(data, Year, Country, Residuals, flavor, energy, model, nest, CSP, ResidualsExp)
#   # Melt the data so that we can include the reference model, too.
#   residGraphData <- melt(residGraphData, 
#                          measure.vars=c("Residuals", "ResidualsExp"),
#                          value.name="value",
#                          variable.name="variable")
#   residGraphData$label <- with(residGraphData, paste(variable, energy))
#   
#   # Now collapse some of the information. Don't need multiple versions of the exponential model, e.g.
#   residGraphData <- filter(residGraphData, label=="Residuals With energy" | label=="Residuals Without energy" |
#                              label=="ResidualsExp Without energy")
#   
#   residGraphData$label <- plyr::mapvalues(residGraphData$label, 
#                                           from = c("Residuals With energy", 
#                                                    "Residuals Without energy",
#                                                    "ResidualsExp Without energy"), 
#                                           to = c("With energy", 
#                                                  "Without energy",
#                                                  "Reference model"))
#   # Relevel factors
#   residGraphData$label <- relevelFactor(as.factor(residGraphData$label), 
#                                          c("Without energy", "With energy", "Reference model"))
#   
#   ggplot() +
#     geom_point(data=residGraphData, mapping=aes(x=Year, y=value, shape=label, color=label, size=label)) +
#     scale_shape_manual(values=c(1, withEnergyShape, 5)) +
#     scale_size_manual(values=c(4, 4, 2)) +
#     # scale_color_manual(values=c("gray50", "green", "red")) +
#     facet_grid(Country ~ flavor) +
#     geom_hline(yintercept = 0, colour="gray50", size=0.1) +
#     scale_x_continuous(breaks=c(1960, 1980, 2000)) +
#     xlab("") +
#     ylab("r") + 
#     xy_theme() +
#     theme(legend.title=element_blank())
# }
@

Because we fit in log-space, fitting residuals ($r_i$) are defined as
%
\begin{equation} \label{eq:log-residuals}
  r_i \equiv \ln(y_i) - \ln(\hat{y}_i) =\ln\left( \frac{y_i}{\hat{y}_i} \right), 
\end{equation}
%
where $r_i$ will be zero when there is agreement between 
historical~($y_i$) and fitted~($\hat{y}_i$) economic output.

Figures~\ref{fig:Graphs CESkle-resid}--\ref{fig:Graphs CESekl-resid}
show fitting residuals for all CES models.
%
<<Graphs_CESkle-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for CES models with $(kl$)$e$ nesting.">>=
residualPlot(filter(fitted_and_resid_data, model=="CES" & CSP=="Reject CSP" & (nest=="kle" | nest=="kl")), 
             withEnergyShape = 0) # square
@
%
<<Graphs_CESlek-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for CES models with ($le$)$k$ nesting.">>=
residualPlot(filter(fitted_and_resid_data, model=="CES" & CSP=="Reject CSP" & (nest == "lek" | nest=="kl")),
             withEnergyShape = 3) # plus
@
%
<<Graphs_CESekl-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for CES models with $(ek$)$l$ nesting.">>=
residualPlot(filter(fitted_and_resid_data, model=="CES" & CSP=="Reject CSP" & (nest=="ekl" | nest=="kl")),
             withEnergyShape = 4) # times
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results}
\label{sec:results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The primary results from this paper involve the effects of
the following modeling decisions:
rejecting (or adhering to) the cost share theorem,
quality-adjusting (or not) the factors of production,
including energy (or not) in the production function, and
nesting (in the CES model).





We evaluate the effects of these modeling decisions 
first on goodness of fit and Solow residual,
next on factor shares, and 
finally on factor substitutability.


%++++++++++++++++++++++++++++++
\subsection{Goodness of fit and Solow residual} 
\label{sec:fit_and_sr}
%++++++++++++++++++++++++++++++

Table~\ref{tab:CES_sr_gof} shows 
the Solow residual~($\lambda$) and
goodness of fit~($sse$)
for all modeling decisions.
%
<<CES_sr_gof, results="asis">>=
myXTable(filter(AllCoeffs, model=="CES" | model=="exp") %>% 
           select(Country, model, flavor, energy, nest, CSP, scale, lambda, sse),
         caption="$\\theta$, Solow residual, and $sse$ for CES models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@
%
We can evaluate the effect of modeling decisions on 
goodness of fit and Solow residual by
calculating values relative to the reference model.
To do so, we define 
$\Delta \lambda$ and $\Delta sse$, where
%
\begin{equation} \label{eq:delta_lambda}
  \Delta \lambda \equiv \lambda - \lambda_{ref}
\end{equation}
%
and
%
\begin{equation} \label{eq:delta_sse}
  \Delta sse \equiv sse - sse_{ref},
\end{equation}
%
with~$\lambda_{ref}$ and $sse_{ref}$ being the values 
of the Solow residual and $sse$ for the reference model, respectively.
On a percentage basis,
%
\begin{equation} \label{eq:delta_lambda_perc}
  \Delta \lambda \, [\%] = \frac{100 \, \Delta \lambda}{\lambda_{ref}} 
            = \frac{100 \, \lambda}{\lambda_{ref}} - 1 \; ,
\end{equation}
%
and
%
\begin{equation} \label{eq:delta_sse_perc}
  \Delta sse \, [\%] = \frac{100 \, \Delta sse}{sse_{ref}} 
            = \frac{100 \, sse}{sse_{ref}} - 1 \; .
\end{equation}

When $\Delta \lambda$, $\Delta \lambda \, [\%]$, or $\Delta sse$ are negative, 
we observe reduction in the Solow residual ($\lambda$) or
the fitting residuals ($sse$)
relative to the reference model.

Figure~\ref{fig:DSRsse_CES_graph} summarizes 
$\lambda$ and $sse$ 
results for CES models.

<<SRsse_CES_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Solow Residuals~($\\lambda$) and mean squared error~($sse$). $\\lambda$ and $sse$ values for the reference (exponential-only) model are shown as gridlines.">>=
ggplot() +
  geom_point(data=filter(AllCoeffs, model=="CES"), mapping=aes(x=sse, y=lambda, color=energy, size=CSP, shape=nest)) +
  geom_vline(aes(xintercept = sse), filter(AllCoeffs, model=="exp") %>% select(Country, sse), colour="gray50", size=0.1) +
  geom_hline(aes(yintercept = lambda), filter(AllCoeffs, model=="exp") %>% select(Country, lambda), colour="gray50", size=0.1) +
  scale_size_manual(values=c(2,4)) +
  scale_shape_manual(values=c(1,0,3,4)) + 
  facet_grid(Country ~ flavor) +
  scale_y_continuous(breaks=c(0, 0.01, 0.02, 0.03), limits=c(0, 0.035)) +
  xlab("SSE") + 
  ylab(expression(lambda)) +
  xy_theme() +
  theme(legend.title=element_blank())
@





%------------------------------
\subsubsection{Rejecting (or adhering to) the cost share theorem} 
\label{sec:gfsr_CSP}
%------------------------------


%------------------------------
\subsubsection{Quality-adjusting (or not) factors of production} 
\label{sec:gfsr_fop}
%------------------------------


%------------------------------
\subsubsection{Including energy (or not)} 
\label{sec:gfsr_energy}
%------------------------------


%------------------------------
\subsubsection{CES nesting} 
\label{sec:gfsr_nesting}
%------------------------------






%++++++++++++++++++++++++++++++
\subsection{Factor shares} 
\label{sec:shares}
%++++++++++++++++++++++++++++++

Table~\ref{tab:CES_alpha} shows 
the factor shares~($\alpha_i$ values) for all CES modeling decisions.
%
<<CES_alpha, results="asis">>=
myXTable(filter(AllCoeffs, model=="CES" | model=="exp") %>% 
           select(Country, model, flavor, energy, nest, CSP, alpha_1, alpha_2, alpha_3),
         caption="Factor shares~($\\alpha$) for CES models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@
%
Figures~\ref{fig:Factor_shares_graph_PT} and~\ref{fig:Factor_shares_graph_UK}
show factor shares ($\alpha$ values) for CES models for
Portugal and the UK, respectively.
See Table~\ref{tab:CES_abg_equations} for details on the calculation
of factor shares from fitted values of $\delta_1$ and $\delta$.
%
<<Factor_shares_bar_graph_function>>=
fsbg <- function(coun, mod){
  bar_chart_data <- filter(AllCoeffs, Country==coun & model==mod) %>% 
    select(Country, model, flavor, energy, nest, CSP, alpha_1, alpha_2, alpha_3)
  # Change nest to a nicer-looking nest string
  bar_chart_data$nest <- plyr::mapvalues(bar_chart_data$nest, 
                                         from=c("kl", "kle", "lek", "ekl"), 
                                         to=c("(kl)", "(kl)e", "(le)k", "(ek)l"))
  # Add a label column
  bar_chart_data$label <- paste(bar_chart_data$CSP, bar_chart_data$flavor, 
                                bar_chart_data$energy, bar_chart_data$nest, sep=", ")
  # Add row numbers to the label column
  bar_chart_data$label <- paste(paste0(1:length(bar_chart_data$label), ". "), bar_chart_data$label)
  # Capture the order that we want for the models on the vertical axis.
  order <- bar_chart_data$label
  # Now melt the data
  bar_chart_data <- melt(bar_chart_data, 
                         measure.vars = c("alpha_1", "alpha_2", "alpha_3"), 
                         value.name = "value", 
                         variable.name = "variable")
  bar_chart_data$variable <- plyr::mapvalues(bar_chart_data$variable, 
                                       from=c("alpha_1", "alpha_2", "alpha_3"), 
                                       to=c("alpha_k", "alpha_l", "alpha_e"))

  # Define the color palette (see http://www.cookbook-r.com/Graphs/Colors_(ggplot2))
  cbPalette <- c("#E69F00", "#999999", "#F0E442", "#56B4E9", "#009E73", "#0072B2", "#D55E00", "#CC79A7")
  # Make the plot
  plot <- ggplot(bar_chart_data, mapping=aes(x=label, y=value, fill=variable, width=0.4)) + 
    geom_bar(stat="identity") + 
    xlab("") +
    scale_x_discrete(limits=rev(order)) +
    ylab("") +
    scale_y_continuous(breaks=c(0, 0.5, 1)) + 
    guides(fill=guide_legend(title=NULL)) +
    coord_flip() + 
    scale_fill_brewer(palette="OrRd") +
    xy_theme() +
    theme(axis.ticks.y = element_blank())
  return(plot)
}
@

<<Factor_shares_graph_PT, fig.pos="H", fig.align='center', fig.width=7.5, fig.height=2.5, fig.cap="Factor shares ($\\alpha$ values) for CES models for Portugal.">>=
fsbg(coun = "PT", mod = "CES")
@

<<Factor_shares_graph_UK, fig.pos="H", fig.align='center', fig.width=7.5, fig.height=2.5, fig.cap="Factor shares ($\\alpha$ values) for CES models for the UK.">>=
fsbg(coun = "UK", mod = "CES")
@


%------------------------------
\subsubsection{Rejecting (or adhering to) the cost share theorem} 
\label{sec:fs_CSP}
%------------------------------


%------------------------------
\subsubsection{Quality-adjusting (or not) factors of production} 
\label{sec:fs_fop}
%------------------------------


%------------------------------
\subsubsection{Including energy (or not)} 
\label{sec:fs_energy}
%------------------------------


%------------------------------
\subsubsection{CES nesting} 
\label{sec:fs_nesting}
%------------------------------



%++++++++++++++++++++++++++++++
\subsection{Factor substitutability} 
\label{sec:substitutability}
%++++++++++++++++++++++++++++++

Table~\ref{tab:CES_sigma} shows 
substitutability parameters~($\sigma_i$ values) 
for all CES modeling decisions.

**** Note: At the present time, Table~\ref{tab:CES_sigma}
requires a LOT of effort to interpret, 
because $\sigma_1$ and $\sigma$ have different meanings
for each nesting.
I'm planning to change the table to make interpretation easier. ---MKH ****



**** Is there a graph we want to make here? ---MKH ****
%
<<CES_sigma, results="asis">>=
myXTable(filter(AllCoeffs, model=="CES") %>% 
           select(Country, model, flavor, energy, nest, CSP, sigma_1, sigma),
         caption="Factor substitution~($\\sigma$) for CES models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@
%



%------------------------------
\subsubsection{Rejecting (or adhering to) the cost share theorem} 
\label{sec:sigma_CSP}
%------------------------------


%------------------------------
\subsubsection{Quality-adjusting (or not) factors of production} 
\label{sec:sigma_fop}
%------------------------------


%------------------------------
\subsubsection{Including energy (or not)} 
\label{sec:sigma_energy}
%------------------------------


%------------------------------
\subsubsection{CES nesting} 
\label{sec:sigma_nesting}
%------------------------------


%++++++++++++++++++++++++++++++
\subsection{Resampling} 
\label{sec:resampling}
%++++++++++++++++++++++++++++++

<<resample_graph_lambda_theta, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.5, fig.cap="$\\lambda$ and $\\theta$ values for resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardScatterPlot(data=resampleCoeffs, mapping=aes(scale, lambda), facet_formula=~Country, alpha=0.05, orig_color = "black") +
    scale_x_continuous(breaks=c(0.95, 1.0, 1.05)) + 
    scale_y_continuous(breaks=c(0, 0.005, 0.01), limits=c(0, 0.01)) +
    labs(x=expression(theta), y=expression(lambda))
@

<<resample_graph_alpha, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.0, fig.cap="$\\alpha_k$, $\\alpha_l$, and $\\alpha_e$ values for CES resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardTriPlot(data=resampleCoeffs, facet_formula=~Country, alpha=0.1,
                labels=c("alpha[e]", "alpha[k]", "alpha[l]"), size=2.0)
@

<<resample_graph_sigma1_delta1, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.5, fig.cap="$\\sigma_{(kl)}$ and $\\delta_1$ values for resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardScatterPlot(data=resampleCoeffs, mapping=aes(delta_1, sigma_1), 
                    facet_formula=~Country, alpha=0.1) +
    coord_trans(y="sigma2") +
    scale_x_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0,1)) +
    scale_y_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0, 1e6)) +
    labs(x=expression(delta[1]), y=expression(sigma[kl]))
@

<<resample_graph_sigma_delta, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.5, fig.cap="$\\sigma_{(kl)e}$ and $\\delta$ values for resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardScatterPlot(data=resampleCoeffs, mapping=aes(delta, sigma), 
                    facet_formula=~Country, alpha=0.1) +
    coord_trans(y="sigma2") +
    scale_x_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0,1)) +
    scale_y_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0, 1e6)) +
    labs(x=expression(delta), y=expression(sigma["(kl)"*e]))
@





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
\label{sec:Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future Work}
\label{sec:FutureWork}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}
\label{sec:Acknowledgements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Reproducible Research}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% In the spirit of Reproducible Research \citep{Gandrud:2013vx}, 
% all data, spreadsheets, \texttt{R} code \citep{R}, and other materials 
% associated with this paper can be found at\\*
% \protect\url{https://github.com/MatthewHeun/Econ-Growth-R-Analysis}.



%% References
%%
%% Following citation commands can be used in the body text:
%%
%%  \citet{key}  ==>>  Jones et al. (1990)
%%  \citep{key}  ==>>  (Jones et al., 1990)
%%
%% Multiple citations as normal:
%% \citep{key1,key2}         ==>> (Jones et al., 1990; Smith, 1989)
%%                            or  (Jones et al., 1990, 1991)
%%                            or  (Jones et al., 1990a,b)
%% \cite{key} is the equivalent of \citet{key} in author-year mode
%%
%% Full author lists may be forced with \citet* or \citep*, e.g.
%%   \citep*{key}            ==>> (Jones, Baker, and Williams, 1990)
%%
%% Optional notes as:
%%   \citep[chap. 2]{key}    ==>> (Jones et al., 1990, chap. 2)
%%   \citep[e.g.,][]{key}    ==>> (e.g., Jones et al., 1990)
%%   \citep[see][pg. 34]{key}==>> (see Jones et al., 1990, pg. 34)
%%  (Note: in standard LaTeX, only one note is allowed, after the ref.
%%   Here, one note is like the standard, two make pre- and post-notes.)
%%
%%   \citealt{key}          ==>> Jones et al. 1990
%%   \citealt*{key}         ==>> Jones, Baker, and Williams 1990
%%   \citealp{key}          ==>> Jones et al., 1990
%%   \citealp*{key}         ==>> Jones, Baker, and Williams, 1990
%%
%% Additional citation possibilities
%%   \citeauthor{key}       ==>> Jones et al.
%%   \citeauthor*{key}      ==>> Jones, Baker, and Williams
%%   \citeyear{key}         ==>> 1990
%%   \citeyearpar{key}      ==>> (1990)
%%   \citetext{priv. comm.} ==>> (priv. comm.)
%%   \citenum{key}          ==>> 11 [non-superscripted]
%% Note: full author lists depends on whether the bib style supports them;
%%       if not, the abbreviated list is printed even when full requested.
%%
%% For names like della Robbia at the start of a sentence, use
%%   \Citet{dRob98}         ==>> Della Robbia (1998)
%%   \Citep{dRob98}         ==>> (Della Robbia, 1998)
%%   \Citeauthor{dRob98}    ==>> Della Robbia


%% References with bibTeX database:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{References}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \bibliographystyle{model2-names}
%%\bibliography{<your-bib-database>}
% \bibliography{Paper2.bib}

%% Authors are advised to submit their bibtex database files. They are
%% requested to list a bibtex style file in the manuscript if they do
%% not want to use model2-names.bst.

%% References without bibTeX database:

% \begin{thebibliography}{00}

%% \bibitem must have one of the following forms:
%%   \bibitem[Jones et al.(1990)]{key}...
%%   \bibitem[Jones et al.(1990)Jones, Baker, and Williams]{key}...
%%   \bibitem[Jones et al., 1990]{key}...
%%   \bibitem[\protect\citeauthoryear{Jones, Baker, and Williams}{Jones
%%       et al.}{1990}]{key}...
%%   \bibitem[\protect\citeauthoryear{Jones et al.}{1990}]{key}...
%%   \bibitem[\protect\astroncite{Jones et al.}{1990}]{key}...
%%   \bibitem[\protect\citename{Jones et al., }1990]{key}...
%%   \harvarditem[Jones et al.]{Jones, Baker, and Williams}{1990}{key}...
%%

% \bibitem[ ()]{}

% \end{thebibliography}


%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix
%% \section{}
%% \label{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Correlograms} 
\label{sec:correlograms}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This appendix contains correlograms for all models.

%++++++++++++++++++++++++++++++
\subsection{Correlograms for the reference models} 
\label{sec:correlograms_ref}
%++++++++++++++++++++++++++++++

In this section we present correlograms for the reference (exponential-only) models. 

<<Correlograms_Exp, echo=FALSE, message=FALSE>>=
leaf_apply(l = modelsExp, class = c("lm"), f = function(model, name){
  acf(resid(model), main=name)
})
@


%++++++++++++++++++++++++++++++
\subsection{Correlograms for models that adhere to the cost-share theorem} 
\label{sec:correlograms_CSP}
%++++++++++++++++++++++++++++++

In this section we present correlograms for all models that adhere to the cost-share theorem.

<<Correlograms_CSP, echo=FALSE, message=FALSE>>=
leaf_apply(l = modelsCSP, class = c("lm", "plm"), f = function(model, name){
  acf(resid(model), main=name)
})
@


%++++++++++++++++++++++++++++++
\subsection{Correlograms for models that reject the cost-share theorem} 
\label{sec:correlograms_noCSP}
%++++++++++++++++++++++++++++++

In this section we present correlograms for all models that reject the cost-share theorem.

<<Correlograms_noCSP, echo=FALSE, message=FALSE>>=
leaf_apply(l = models, class = c("CDEmodel", "cesModel", "LINEXmodel"), f = function(model, name){
  acf(resid(model), main=name)
})
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Statistical details on all models} 
\label{sec:staistical_details}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section, we present statistical details of all models.

At the moment, this is a simple example of two models.
I hope to develop a table later, after I figure out some things.
Both models are CES models with energy fitted to Quality-adjusted data using the ($kl$)($e$) nesting.
In Table~\ref{tab:stat_details_table}, Model 1 is for Portugal, and Model 2 is for the UK.

<<stat_details_table, results="asis">>=
texreg(list(models$PT$adjusted$withE$CES$kle, models$UK$adjusted$withE$CES$kle), 
       dcolumn = TRUE, 
       booktabs = TRUE, 
       use.packages = FALSE, 
       label=paste0("tab:", opts_current$get("label")), 
       caption = "Example output from \\texttt{texreg}.",
       caption.above = TRUE, 
       digits = 6,
       fontsize = "tiny",
       float.pos = "hb")
@





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cobb-Douglas Graveyard} 
\label{sec:cd_results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section is the graveyard for information pertaining to the Cobb-Douglas model.

%------------------------------
\subsubsection{Cobb-Douglas Production Function} 
\label{sec:CDe}
%------------------------------

The Cobb-Douglas production function can be expressed as
%
\begin{equation} \label{eq:CD}
  y = \theta A k^{\alpha_1} l^{\alpha_2} \; ; \; A \equiv \mathrm{e}^{\lambda(t-t_0)} \; ,
\end{equation}
%
where 

Constant returns to scale are represented by the constraint
$\alpha_1 + \alpha_2 = 1$.

The capital-labor Cobb-Douglas production function shown in Equation~\ref{eq:CD}
can be augmented to include an energy term:
%
\begin{equation} \label{eq:CDe}
  y = \theta A k^{\alpha_1} l^{\alpha_2} e^{\alpha_3} \; ; \; A \equiv \mathrm{e}^{\lambda(t-t_0)} \; ,
\end{equation}
%
where $e \equiv E/E_0$, and $E$ is in units of energy per time, typically TJ/year.
The energy-augmented Cobb-Douglas production function 
is often assumed to have constant returns to scale for the three factors 
of production: $\alpha_1 + \alpha_2 + \alpha_3 = 1$.
The term $A$ is known as total factor productivity,
and $\lambda$ is the Solow residual. 

The Cobb-Douglas production function can be expressed as
%
\begin{equation} \label{eq:CD}
  y = \theta A k^{\alpha_1} l^{\alpha_2} \; ; \; A \equiv \mathrm{e}^{\lambda(t-t_0)} \; ,
\end{equation}
%
where 
$y \equiv Y/Y_{0}$,
$\theta$ is a scale parameter,
e is the base of the natural logarithm, 
$\lambda$ is represents the pace of technological progress,
$t$ (time) is measured in years,
$k \equiv K/K_{0}$, 
$l \equiv L/L_{0}$, 
$Y$ (economic output) is represented by GDP, 
$K$ (capital) is expressed in currency units, 
$L$ (labor) is expressed in workers or work-hours/year, and
the 0 subscript indicates values at an initial year.%
  \footnote{Dimensionless, indexed quantities are represented by 
  lower-case symbols 
  ($y$, $k$, $l$, $e$, $q$, $x$, and $u$), and dimensional 
  quantities are represented by upper-case symbols 
  ($Y$, $K$, $L$, $E$, $Q$, $X$, and $U$). 
  Model parameters are represented by Greek letters
  ($\alpha_1$, $\alpha_2$, $\lambda$, $\theta$).
  }
Constant returns to scale are represented by the constraint
$\alpha_1 + \alpha_2 = 1$.

The capital-labor Cobb-Douglas production function shown in Equation~\ref{eq:CD}
can be augmented to include an energy term:
%
\begin{equation} \label{eq:CDe}
  y = \theta A k^{\alpha_1} l^{\alpha_2} e^{\alpha_3} \; ; \; A \equiv \mathrm{e}^{\lambda(t-t_0)} \; ,
\end{equation}
%
where $e \equiv E/E_0$, and $E$ is in units of energy per time, typically TJ/year.
The energy-augmented Cobb-Douglas production function 
is often assumed to have constant returns to scale for the three factors 
of production: $\alpha_1 + \alpha_2 + \alpha_3 = 1$.
The term $A$ is known as total factor productivity,
and $\lambda$ is the Solow residual. 
%
<<Graphs_CD-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Cobb-Douglas models that reject the cost-share theorem. Solid line is historical GDP.">>=
fittedGraphNoCSP(filter(fitted_and_resid_data, model=="CD" & CSP=="Reject CSP"))
@

%
<<Graphs_CD-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for Cobb-Douglas models.">>=
residualPlot(filter(fitted_and_resid_data, model=="CD" & CSP=="Reject CSP"))
@


Table~\ref{tab:Effect_of_CSP_CD} shows the effect of the CSP 
on fitted parameters for the Cobb-Douglas model and the exponential-only model.
The Cobb-Douglas models show lower $sse$ than the exponential-only models.
The Cobb-Douglas models also reduce solow residual ($\lambda$) relative
to the exponential-only case.
%
<<Effect_of_CSP_CD, results="asis">>=
myXTable(filter(AllCoeffs, (model=="CD" & flavor=="Unadjusted" & energy=="Without energy") | model=="exp") %>% 
           select(Country, model, CSP, scale, lambda, alpha_1, alpha_2, sse),
         caption="Model parameters for Cobb-Douglas models with unadjusted factors of production, without energy.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@
%


Table~\ref{tab:CD_coeffs} shows coefficients for all fitted Cobb-Douglas models
and the reference model (exponential-only).
%
<<CD_coeffs, results="asis">>=
myXTable(filter(AllCoeffs, model=="CD" | model=="exp") %>% 
           select(Country, model, flavor, energy, CSP, scale, lambda, alpha_1, alpha_2, alpha_3, sse),
         caption="Model parameters for all Cobb-Douglas models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@
%

Table~\ref{tab:DSRsse_CD} shows $\Delta \lambda$ and $\Delta sse$ results for the Cobb-Douglas models.
%
<<DSRsse_CD, results="asis">>=
myXTable(filter(AllCoeffs, model=="CD") %>% select(Country, model, flavor, energy, CSP, Dlambda, Dsse),
         caption="$\\Delta \\lambda$ and $\\Delta sse$ for Cobb-Douglas models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@
% 

%
Figures~\ref{fig:DSRsse_CD_graph} and~\ref{fig:percDSRsse_CD_graph} summarize 
$\Delta \lambda$ and $\Delta sse$ 
results for the Cobb-Douglas model.
%
<<DSRsse_CD_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Change in Solow Residuals~($\\Delta\\lambda$) and mean squared error~($\\Delta sse$) for the Cobb-Douglas model relative to the exponential-only model.">>=
ggplot() +
  geom_point(data=filter(AllCoeffs, model=="CD"), mapping=aes(x=Dsse, y=Dlambda, color=energy, size=CSP)) +
  facet_grid(Country ~ flavor) +
  scale_size_manual(values=c(2,3.5)) +
  xlab(expression(Delta * sse)) + 
  scale_x_continuous(breaks=seq(-0.01, 0, 0.005), limits=c(-0.012, 0.003)) +  
  ylab(expression(Delta * lambda)) +
  scale_y_continuous(limits=c(-0.04, 0)) +
  xy_theme() + 
  theme(legend.title=element_blank())
@
%
<<percDSRsse_CD_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Percentage change in Solow Residuals~($\\Delta\\lambda \\, [\\%]$) and mean squared error~($\\Delta sse \\, [\\%]$) for the Cobb-Douglas model relative to exponential-only models.">>=
ggplot() +
  geom_point(data=filter(AllCoeffs, model=="CD"), mapping=aes(x=percDsse, y=percDlambda, color=energy, size=CSP)) +
  facet_grid(Country ~ flavor) +
  scale_size_manual(values=c(2,3.5)) +
  xlab(expression(paste(Delta * sse, " [%]"))) + 
  scale_x_continuous(breaks=seq(-50, 50, 50), limits=c(-90, 50)) +  
  ylab(expression(paste(Delta * lambda, " [%]"))) +
  scale_y_continuous(breaks=seq(-80, 0, 20), limits=c(-100, 10)) +  
  xy_theme() + 
  theme(legend.title=element_blank())
@
%
<<DSRsse_CES_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Change in Solow Residuals~($\\Delta\\lambda$) and mean squared error~($\\Delta sse$) for the CES modles relative to the exponential-only model.">>=
ggplot() +
  geom_point(data=filter(AllCoeffs, model=="CES"), mapping=aes(x=Dsse, y=Dlambda, color=energy, size=CSP, shape=nest)) +
  scale_size_manual(values=c(2,3.5)) +
  scale_shape_manual(values=c(16,17,18,15)) +
  facet_grid(Country ~ flavor) +
  xlab(expression(Delta * sse)) + 
  scale_x_continuous(breaks=seq(-0.005, 0, 0.005)) +  
  ylab(expression(Delta * lambda)) +
  xy_theme() +
  theme(legend.title=element_blank())
@
%
<<percDSRsse_CES_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Percentage change in Solow Residuals~($\\Delta\\lambda \\, [\\%]$) and mean squared error~($\\Delta sse \\, [\\%]$) for the CES models relative to the exponential-only model.">>=
ggplot() +
  geom_point(data=filter(AllCoeffs, model=="CES"), mapping=aes(x=percDsse, y=percDlambda, color=energy, size=CSP, shape=nest)) +
  scale_size_manual(values=c(2,3.5)) +
  scale_shape_manual(values=c(16,17,18,15)) +
  facet_grid(Country ~ flavor) +
  xlab(expression(paste(Delta * SSE, " [%]"))) + 
  scale_x_continuous(breaks=seq(-80, 0, 20)) +  
  ylab(expression(paste(Delta * lambda, " [%]"))) +
  scale_y_continuous(breaks=seq(-80, 0, 20), limits=c(-100, 10)) +  
  xy_theme() +
  theme(legend.title=element_blank())
@



\end{document}

%%
%% End of file `elsarticle-template-2-harv.tex'.
