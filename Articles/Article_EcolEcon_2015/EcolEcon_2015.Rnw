% This article has been prepared for publication in RStudio with knitr.
% According to http://www.elsevier.com/author-schemas/the-elsarticle-latex-document-class, we should be using the
% elsarticle.cls file.
% According to http://cdn.elsevier.com/assets/pdf_file/0006/109392/journal_refstyles.pdf, we should be using
% elsarticle-template-2-harv.tex as the template for the text.
% Furthermore, we should be using model2-names.bst for the bibliographic references.
% The approach here is to load the frontmatter and backmatter from elsarticle-template-2-harv.tex
% both ahead of and behind the text for our paper.
% -- Matthew Kuperus Heun, 2014-08-01

%% This is file `elsarticle-template-2-harv.tex',
%%
%% Copyright 2009 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle  Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for Elsevier's document class `elsarticle'
%% with harvard style bibliographic references
%%
%% $Id: elsarticle-template-2-harv.tex 155 2009-10-08 05:35:05Z rishi $
%% $URL: http://lenova.river-valley.com/svn/elsbst/trunk/elsarticle-template-2-harv.tex $
%%
\documentclass[preprint,authoryear,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[authoryear,preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,authoryear,1p,times]{elsarticle}
%% \documentclass[final,authoryear,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,authoryear,3p,times]{elsarticle}
%% \documentclass[final,authoryear,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,authoryear,5p,times]{elsarticle}
%% \documentclass[final,authoryear,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
%% \usepackage{graphics}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

\usepackage{wrapfig}    % Allows wrapping of text around figures
\usepackage{soul}       % Provides strikethrough text
\usepackage{float}      % Allows precise positioning of tables and figures within the text
\usepackage{amsmath}    % Allows \begin{equation*} \end{equation*} for unnumbered equations
\usepackage{multirow}   % To create multirow tables
\usepackage{hyperref}   % To create hyperlinks in the paper
\usepackage{microtype}  % produces hanging punctuation and beautiful type
\usepackage{booktabs}   % for beautiful tables
\usepackage{dcolumn}    % aligns table columns at decimal places


% From http://economics.utoronto.ca/osborne/latex/BIBTEX.HTM
\newcommand{\citeapos}[1]{\citeauthor{#1}'s (\citeyear{#1})} % Posessive citations. 

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
%% \usepackage{lineno}

%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon (default)
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   authoryear - selects author-year citations (default)
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%   longnamesfirst  -  makes first citation full author list
%%
%% \biboptions{longnamesfirst,comma}

% \biboptions{}

\journal{Ecological Economics}

\begin{document}

<<setup, echo=FALSE, message=FALSE, eval=TRUE, warning=FALSE>>=
library(EconData)
library(EconModels)
library(dplyr)
library(reshape2)
library(ggplot2)
library(mosaic)
library(xtable)
library(knitr)
library(texreg)
library(tidyr)
library(scales)

# Tell whether to re-run the analysis to create the models
# or the resampling on the (kl)e models.
# This file will use previously-saved models and resampling to generate
# the paper if set to FALSE, greatly reducing time.
# If something changes in the data or in the code that
# performs the analysis or resampling, set 
# rerunModels = TRUE
# rerunResampling = TRUE
# once to re-generate the information needed to 
# create the paper.
# ********************************************************
rerunModels=FALSE
rerunResampling=FALSE
nResamples <- 1000 # Number of resamples
# ********************************************************
opts_chunk$set(
  # ********************************************************
  eval=TRUE,
  # ********************************************************
  # tikz allows LaTeX code in graphical output. 
  # E.g., "$y$" for a variable name in the legend for a graph.  
  # dev='tikz',
  tidy=FALSE,
  comment=NA,
  # Tells whether to cache output from chunks are saved. Cacheing saves time. 
  # However, references to LaTeX tables DO NOT WORK if cacheing is turned on.
  cache=FALSE,
  warning=FALSE,  #Tells whether to show warnings in the output.
  # Turns off messages for all chunks. 
  # Set TRUE on an individual chunk to see it.
  message=FALSE, 
  # Tells whether to echo code for all chunks. 
  # Set TRUE on an individual chunk to see its code.
  echo=FALSE,
  # Sets all table captions to the top.
  xtable.caption.placement="top"
)

# This function is used in many places below.
### That's nice.  I assume that's why you wrote a function.  But what does it DO?
@

<<myXTable>>=
myXTable <- function(data, caption, label, digits=2){
  table <- xtable(data, caption=caption, label=label, digits=digits)
  print(table, 
        caption.placement="top", 
        size="\\tiny", 
        include.rownames=FALSE, 
        math.style.negative=TRUE, 
        sanitize.text.function=function(x){x},
        booktabs=TRUE)
}
@

<<model_points_style>>=
model_points_style <- function(p) {
  p + 
  scale_colour_manual(values = c("gray70", "black")) +
  scale_size_manual(values = c(5, 3,3,3,3,3,3)) +
  # scale_alpha_manual(values = c(.2, .6,.6,.6,.6, .6, .6)) +
  scale_fill_manual(values = c(scales::alpha("gray50", .2), rep("transparent", 6))) +
  scale_shape_manual(values = c(21, 21, 23:27)) +
  guides( 
    col = guide_legend(override.aes = aes(size = 5, shape = 21)) )
}

model_points_style_quad <- function(p) {
  p + 
  # scale_colour_manual(values = c("gray70", "black")) +
  scale_size_manual(values = c(5, 3,3,3,3,3,3)) +
  # scale_alpha_manual(values = c(.2, .6,.6,.6,.6, .6, .6)) +
  scale_fill_manual(values = c(scales::alpha("gray50", .2), rep("transparent", 6))) +
  scale_shape_manual(values = c(21, 21, 23:27)) +
  theme(legend.title=element_blank())
}
@

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

\title{Energy and the CES production function}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{<author name>}
%% \address[label1]{<address>}
%% \address[label2]{<address>}

\author[IST]{Jo\~{a}o dos Santos}
\author[CalvinEngr]{Matthew Kuperus Heun\corref{cor1}}
\author[Leeds]{Paul Brockway}
\ead{mkh2@calvin.edu}
\author[Leeds]{Marco Sekai}
\author[IST]{Tiago Domingos}
\author[CalvinMath]{Randall Pruim}

\address[IST]{IST, Lisbon, Portugal}
\address[Leeds]{Leeds University, Leeds, UK}
\address[CalvinEngr]{Engineering Department, Calvin College, Grand Rapids, MI 49546, USA}
\address[CalvinMath]{Mathematics \& Statistics Department, Calvin College, Grand Rapids, MI 49546, USA}
\cortext[cor1]{Corresponding author}

\begin{abstract}
%% Text of abstract
**** Add abstract ****
\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
economic growth \sep exergy \sep energy \sep CES
%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)
\end{keyword}

\end{frontmatter}

% \linenumbers
%% main text


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction} 
\label{sec:Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This is a study of the effects of quality-adjusted production function inputs
on the importance of energy in the production function.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coordinates of Analysis} 
\label{sec:Coordinates}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section describes the coordinates of analysis and briefly reviews 
literature related to each.


%++++++++++++++++++++++++++++++
\subsection{Mathematical Forms of the Energy-augmented Production Function} 
\label{sec:Prod_Func_Forms}
%++++++++++++++++++++++++++++++

In this paper, we assess a prominent energy-augmented production function:
Constant Elasticity of Substitution (CES).
The CES model is assessed relative to 
a model of exponential growth only.
The following subsections describe each.







%------------------------------
\subsubsection{Constant Elasticity of Substitution Production Function (CES)} 
\label{sec:CES}
%------------------------------

The energy-augmented 
Constant Elasticity of Substitution (CES) production function%
  \footnote{
  We use the The \texttt{R} 
  % \citep{R} 
  package \texttt{micEconCES} 
  % \citep{Henningsen:2011td} 
  to estimate the CES production function.
  }
can be given as
%
\begin{equation} \label{eq:CESgeneric}
  y = \gamma \: A \: \left\{\delta \left[\delta_1 x_1^{-\rho_1} 
      + (1-\delta_1)x_2^{-\rho_1} \right]^{\rho/\rho_1} 
      + (1-\delta) x_3^{-\rho} \right\}^{-1/\rho}; 
      A \equiv \mathrm{e}^{\lambda (t-t_0)},
\end{equation}
%
where
$y \equiv Y/Y_{0}$,
$\gamma$ is a scale parameter,
e is the base of the natural logarithm, 
$\lambda$ is the Solow residual (often thougth to represent the pace of technological progress),
$t$ (time) is measured in years,
$x_1$, $x_2$, and $x_3$ are factors of production
and permutations of capital~($k$), labor~($l$), and energy~($e$),
$k \equiv K/K_{0}$, 
$l \equiv L/L_{0}$, 
$Y$ (economic output) is represented by GDP, 
$K$ (capital) is expressed in currency units, 
$L$ (labor) is expressed in workers or work-hours/year, and
the 0 subscript indicates values at an initial year.%
  \footnote{Dimensionless, indexed quantities are represented by 
  lower-case symbols 
  ($y$, $k$, $l$, $e$, $q$, $x$, and $u$), and dimensional 
  quantities are represented by upper-case symbols 
  ($Y$, $K$, $L$, $E$, $Q$, $X$, and $U$). 
  Model parameters are represented by Greek letters
  ($\alpha_1$, $\alpha_2$, $\lambda$, $\theta$).
  }
The CES model without energy is given in Equation~\ref{eq:CESkl}.
%
\begin{equation} \label{eq:CESkl}
  y = \gamma \: A \: \left[\delta_1 k^{-\rho_1} 
      + (1-\delta_1)l^{-\rho_1} \right]^{-1/\rho_1}; 
      A \equiv \mathrm{e}^{\lambda (t-t_0)} . 
\end{equation}
%
Equation~\ref{eq:CESkle} augments Equation~\ref{eq:CESkl} with energy 
using a ($kl$)($e$) nesting structure, as is typical in the literature. 
Equation~\ref{eq:CESkl} is a degenerate form of Equation~\ref{eq:CESkle} 
where $\delta \rightarrow 1$. 
%
\begin{equation} \label{eq:CESkle}
  y = \gamma \: A \: \left\{\delta \left[\delta_1 k^{-\rho_1} 
      + (1-\delta_1)l^{-\rho_1} \right]^{\rho/\rho_1} 
      + (1-\delta) e^{-\rho} \right\}^{-1/\rho}; 
      A \equiv \mathrm{e}^{\lambda (t-t_0)}.
\end{equation}
%
In the CES production function, 
$\gamma$ is a fitting parameter that accounts for an atypical first year. 
The fitting parameters $\rho_1$ and $\rho$ indicate elasticities 
of substitution ($\sigma_1$ and $\sigma$).
The elasticity of substitution 
between capital ($k$) and labor ($l$) is given by 
$\sigma_1 = \frac{1}{1+\rho_1}$, and
the elasticity of substitution between ($kl$) and ($e$) is given by 
$\sigma = \frac{1}{1+\rho}$. 
As $\rho_1 \rightarrow 0$, $\sigma_1 \rightarrow 1$,
and the embedded CES production function for $k$ and $l$ degenerates 
to the Cobb-Douglas production function.
Similarly, as $\rho \rightarrow 0$, $\sigma \rightarrow 1$,
and the CES production function for $(kl)$ and $(e)$ degenerates 
to the Cobb-Douglas production function.
As $\sigma \rightarrow \infty$ ($\rho \rightarrow -1$), 
($kl$) and ($e$) are perfect substitutes. 
As $\sigma \rightarrow 0$ ($\rho \rightarrow \infty$), 
($kl$) and ($e$) are perfect complements: 
no substitution is possible. Similarly, 
as $\sigma_1 \rightarrow 0$ ($\rho_1 \rightarrow \infty$),
$k$ and $l$ are perfect complements.
$\delta_1$ describes the relative importance of capital ($k$)
and labor ($l$), and
$\delta$ describes the importance of ($kl$) relative to ($e$).

Constraints on the fitting parameters include 
$\delta_1 \in [0,1]$,
$\delta \in [0,1]$,
$\rho_1 \in [-1,0) \cup (0,\infty)$, and
$\rho \in [-1,0) \cup (0,\infty)$. 

Two other nestings of the factors of production ($k$, $l$, and $e$)
are possible with the CES model.
%
\begin{equation} \label{eq:CESlek}
  y = \gamma \: A \: \left\{\delta \left[\delta_1 l^{-\rho_1} 
      + (1-\delta_1) e^{-\rho_1} \right]^{\rho/\rho_1} 
      + (1-\delta) k^{-\rho} \right\}^{-1/\rho}; 
      A \equiv \mathrm{e}^{\lambda (t-t_0)}
\end{equation}
%
\begin{equation} \label{eq:CESekl}
  y = \gamma \: A \: \left\{\delta \left[\delta_1 e^{-\rho_1} 
      + (1-\delta_1) k^{-\rho_1} \right]^{\rho/\rho_1} 
      + (1-\delta) l^{-\rho} \right\}^{-1/\rho}; 
      A \equiv \mathrm{e}^{\lambda (t-t_0)}
\end{equation}
% 
Note that $\rho$ ($\sigma$), $\rho_1$ ($\sigma_1$), $\delta$, and $\delta_1$ have different
meanings depending upon the nesting of the factors of production.

For the CES model, factors shares~($\alpha_1$, $\alpha_2$, and $\alpha_3$) are calculated by
$\alpha_1 = \delta_1$, $\alpha_2 = 1 - \delta_1$, and $\alpha_3 = 0$ 
for the CES model with two factors of production
and by 
$\alpha_1 = \delta \delta_1$, $\alpha_2 = \delta(1 - \delta_1)$, and $\alpha_3 = 1 - \delta$
for the CES model with three factors of production and the ($kl$)$e$ nesting.
The values of $\alpha_1$, $\alpha_2$, and $\alpha_3$ are interpreted as
factor shares for capital, labor, and energy, respectively,
as shown in Table \ref{tab:CES_abg_equations}.

\begin{table} \caption{Equations for $\alpha_1$, $\alpha_2$, and $\alpha_3$ 
                        (factor shares for capital, labor, and energy, respectively)
                        for the various CES nestings.} 
\label{tab:CES_abg_equations} 
  \begin{center}
    \begin{tabular}{c c c c} 
      \toprule
      Nesting    & $\alpha_1$              & $\alpha_2$              & $\alpha_3$       \\
      \midrule
      ($kl$) \;  & $\delta_1$              & $1 - \delta_1$          & 0          \\
      ($kl$)$e$  & $\delta \delta_1$       & $\delta (1 - \delta_1)$ & $1 - \delta$ \\   
      ($le$)$k$  & $1 - \delta$            & $\delta \delta_1$       & $\delta (1 - \delta_1)$ \\
      ($ek$)$l$  & $\delta (1 - \delta_1)$ & $1 - \delta$            & $\delta \delta_1$ \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}


%------------------------------
\subsubsection{Exponential Production Function (reference model)} 
\label{sec:exp}
%------------------------------

We define an exponential-only reference model for economic growth
in Equation~\ref{eq:exponential-only-model}.
%
\begin{equation} \label{eq:exponential-only-model}
  y = \theta A \; ; \; A \equiv \mathrm{e}^{\lambda(t-t_0)} \; .
\end{equation}
%
We expect that the reference model
will have a larger fitted Solow residual term than
the CES model, because no factors of production are
included in the reference model to drive economic growth.
Indeed, in the reference model, 
all economic growth is attributed to the Solow residual~($\lambda$).

In contrast, it is not necessarily true that 
CES models will exhibit lower $sse$ than the reference model
shown in Equation~\ref{eq:exponential-only-model}.
The CES model has more fitting parameters,
but it incorporates the factors of production
at constant returns to scale. 
The reference model has $\alpha_1 + \alpha_2 + \alpha_3 = 0$,
whereas the CES model~(Equation~\ref{eq:CESgeneric})
implicitly assumes constant returns to scale.
Thus, if the factors of production~($\alpha_1$, $\alpha_2$, and $\alpha_3$) 
are poorly correlated to output~($y$),
the constant returns to scale constraint may cause higher $sse$ for
the CES model relative to the reference model.


%++++++++++++++++++++++++++++++
\subsection{Economies} 
\label{sec:Economies}
%++++++++++++++++++++++++++++++

Discuss economies here.

UK and Portugal.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sources of Data}
\label{sec:Sources_of_Data}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Discuss data sources here.


%++++++++++++++++++++++++++++++
\subsection{Historical Data} 
\label{sec:Historical_Data}
%++++++++++++++++++++++++++++++

Historical data are stored in the \texttt{IST} and \texttt{Leeds} data sets.

<<Formulas>>=
# Set up the formulas for each type of analysis.
# These formulas contain energy. 
# We can use keep_summands to drop the energy term (3rd summand on the rhs)
# later if needed.
formulas <- 
  list( 
    PT = c(unadjusted = build_formula("iGDP", list("iKstkS.L", "iL", "iXpMP", "iYear")),
             adjusted = build_formula("iGDP", list("iKservS.L", "ihLest", "iUMP", "iYear"))),
    UK = c(unadjusted = build_formula("iGDP", list("iKstkO.WwithRD", "iL", "iXp", "iYear")),
             adjusted = build_formula("iGDP", list("iKservO.WwithRD", "ihLest", "iU", "iYear")))
  )
countries <- names(formulas)
flavors <- names(formulas$PT)
@

<<Data>>=
# Create the historicalData data frames
### If we need to select variables, we can do that.  Unfortunately, select() and select_() don't do
### what we would like here (they don't accept a vector of character strings), so we'd have to use
### something else.  I've kept the fake select_() command here just to record what was done earlier.

commonVars <- c("Year", "Country", "Source")
historicalData <- list(
  PT =  IST %>% 
    filter(Country == "PT"), 
    #  %>% select_(unique(c(commonVars, all.vars(formulas$PT$unadjusted), all.vars(formulas$PT$adjusted)))),
  UK = Leeds %>% 
    filter(Country == "UK") 
    # %>% select_(unique(c(commonVars, all.vars(formulas$UK$unadjusted), all.vars(formulas$UK$adjusted))))
)
@

For unadjusted variables, we use the time series shown in Table~\ref{tab:unadjusted_variables}.

\begin{table} \caption{Unadjusted time-series variables.} 
\label{tab:unadjusted_variables} 
  \begin{center}
    \begin{tabular}{r l l} 
      \toprule
      Variable    & Portugal           & UK                 \\
      \midrule
      Output      & \Sexpr{summands(formulas$PT$unadjusted, n=1, right=FALSE)}   
                                                             & \Sexpr{summands(formulas$UK$unadjusted, n=1, right=FALSE)}\\
      Capital     & \Sexpr{summands(formulas$PT$unadjusted, 1)} & \Sexpr{summands(formulas$UK$unadjusted, 1)} \\
      Labor       & \Sexpr{summands(formulas$PT$unadjusted, 2)} & \Sexpr{summands(formulas$UK$unadjusted, 2)} \\
      Energy      & \Sexpr{summands(formulas$PT$unadjusted, 3)} & \Sexpr{summands(formulas$UK$unadjusted, 3)} \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

For quality-adjusted variables, we use the time series shown in Table~\ref{tab:quality_adjusted_variables}.

\begin{table} \caption{Quality-adjusted time series variables.} 
\label{tab:quality_adjusted_variables} 
  \begin{center}
    \begin{tabular}{r l l} 
      \toprule
      Variable    & Portugal         & UK               \\
      \midrule
      Output      & \Sexpr{summands(formulas$PT$adjusted, n=1, right=FALSE)}   
                                                           & \Sexpr{summands(formulas$UK$adjusted, n=1, right=FALSE)} \\
      Capital     & \Sexpr{summands(formulas$PT$adjusted, 1)} & \Sexpr{summands(formulas$UK$adjusted, 1)} \\
      Labor       & \Sexpr{summands(formulas$PT$adjusted, 2)} & \Sexpr{summands(formulas$UK$adjusted, 2)} \\
      Energy      & \Sexpr{summands(formulas$PT$adjusted, 3)} & \Sexpr{summands(formulas$UK$adjusted, 3)} \\
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parameter Estimation (Without Cost-share Theorem)}
\label{sec:parameter_estimation_noCSP}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Parameter estimation is accomplished with \texttt{formula}s of the form
% %
% \begin{equation} \label{eq:formulas}
%   y \sim x_1 + x_2 + x_3 + time,
% \end{equation}
% %
% where $y$ is economic output and 
% $x_1$, $x_2$, and $x_3$ are factors of production
% and permutations of
% capital ($k$), labor ($l$), and energy ($e$).
% (The factors of production may be quality-adjusted.)
% $time$ is the time variable, usually \texttt{iYear}. 
% The \texttt{formula}s are used in a fitting function such as 
% \texttt{cdModel} to create a \texttt{model} object.
% The function \texttt{naturalCoef} extracts reasonable
% coefficients from \texttt{model} objects.
% 
% Note that in the fitting process for the Cobb-Douglas equation,
% $\texttt{scale} = \theta$, 
% $\alpha_1 = \alpha$,
% $\alpha_2 = \beta$, and
% $\alpha_3 = \gamma$,
% when the \texttt{formula} is specified as 
% %
% \begin{equation} \label{eq:formula_kle}
%   \texttt{y} \sim \texttt{k + l + e + time}.
% \end{equation}
% %
% Note that for the CES model, $\texttt{scale} = \gamma$ and is expected to be close to unity. 

The models being fit can be described by the algebraic form of the model 
(Cobb-Douglas, CES, etc.) and a formula that enumerates 
which data variables are being used in which roles to fit the model.  
A formula of the form
%
\begin{equation} \label{eq:formulas-3-factor}
y \sim x_1 + x_2 + x_3 + t,
\end{equation}
%
or 
%
\begin{equation} \label{eq:formulas-2-factor}
y \sim x_1 + x_2 + t,
\end{equation}
%
describes the economic output variable ($y$, usually \texttt{iGDP},
                                        indexed GDP) 
and the factors of production ($x_1$, $x_2$, and $x_3$,
                               which will be some measure of capital, labor, and energy, 
                               but perhaps not in that order), 
and a time variable ($t$, usually \texttt{iYear}, 
                     the number of years since the beginning of data collection).  
All of the models assume an error term that is additive on the 
logarithmic scale and are fit by the method of least squares.  
Model fitting provides estimates for all parameters in the model.

<<Models>>=
fileNameCDCES <- "EcolEcon2015ModelsCDCES.rds"
fileNameCSP <- "EcolEcon2015ModelsCSP.rds"
fileNameExp <- "EcolEcon2015ModelsExp.rds"
if (!rerunModels){
  # load from the file on disk
  models <- readRDS(fileNameCDCES)
  modelsCSP <- readRDS(fileNameCSP)
  modelsExp <- readRDS(fileNameExp)
} else {   ### PLEASE USE COMMENTS TO MARK WHERE LONG CHUNKS END; BETTER: AVOID LONG CHUNKS, WHERE POSSIBLE
  
  ### This has not been inspected by rjp
  
  # re-run the models and save to disk.
  # In RStudio, be sure to set the working directory to the source file directory.
  
  #
  # Models that are exponential only, y = A * exp(lambda*t)
  #
  modelsExp <- list()
  alphaExp <- 0
  betaExp <- 0
  gammaExp <- 0
  for (country in countries){
    # Replace with better code later. 
    # Would like to say cdModel(formula, data, factorShares=c(alpha_1 = 0, alpha_2 = 0, alpha_3 = 0))
    # or something like that.
    form <- keep_summands(formulas[[country]][["unadjusted"]], n = c(-1, -2, -3)) # Keep none of the factors of production
    yVar <- as.name(summands(form, n=1, right=FALSE))
    tVar <- as.name(summands(form, n=1))
    data <- historicalData[[country]]
    expMod <- lm(log(eval(yVar)) ~ eval(tVar), data=data)
    attr(expMod, "naturalCoeffs") <- data.frame(lambda=coef(expMod)[[2]],
                                                  logscale=coef(expMod)[[1]], 
                                                  scale=exp(coef(expMod)[[1]]),
                                                  alpha_1=alphaExp,
                                                  alpha_2=betaExp, 
                                                  alpha_3=gammaExp)
    expMod$formula <- form
    sdata <- subset(data, select=all.vars(form))
    sdata <- data[complete.cases(sdata), unique(c(all.vars(form), names(data)))]
    expMod$data <- sdata
    expMod$response <- sdata$iGDP 
    modelsExp[[country]] <- expMod
  }
  # Save exponential models to disk.
  saveRDS(modelsExp, file=fileNameExp)

  
  #
  # Models that adhere to the cost-share theorem
  # 
  
  modelsCSP <- list()
  # Output elasticities based on cost share theorem
  alphaCSP <- 0.3 # Fraction of national accounts spent on capital
  betaCSP <- 0.7 # Fraction of national accounts spent on labor
  for (country in countries){
    for (adj in c("unadjusted", "adjusted")){
      # Replace with better code later. 
      # Would like to say cdModel(formula, data, factorShares=c(alpha_1 = 0.3, alpha_2 = 0.7, alpha_3 = 0))
      # or something like that.
      form <- keep_summands(formulas[[country]][[adj]], n=-3) # Remove energy
      yVar <- as.name(summands(form, n=1, right=FALSE))
      kVar <- as.name(summands(form, n=1))
      lVar <- as.name(summands(form, n=2))
      tVar <- as.name(summands(form, n=3))
      data <- historicalData[[country]]
      # Cobb-Douglas
      ### breaking a formerly long line
      cdModCSP <- 
        lm(log(eval(yVar)) - alphaCSP*log(eval(kVar)) - betaCSP*log(eval(lVar)) ~ eval(tVar), 
           data = data)
      attr(cdModCSP, "naturalCoeffs") <- data.frame(lambda=coef(cdModCSP)[[2]],
                                                    logscale=coef(cdModCSP)[[1]], 
                                                    scale=exp(coef(cdModCSP)[[1]]),
                                                    alpha_1=alphaCSP,
                                                    alpha_2=betaCSP, 
                                                    alpha_3=0)
      cdModCSP$formula <- form
      sdata <- subset(data, select=all.vars(form))
      sdata <- data[complete.cases(sdata), unique(c(all.vars(form), names(data)))]
      cdModCSP$data <- sdata
      cdModCSP$response <- sdata$iGDP
      modelsCSP[[country]][[adj]][["noE"]][["CD"]] <- cdModCSP
      # CES
      cesModCSP <- plm(log(eval(yVar) / (alphaCSP*eval(kVar)^(-rho_1) + betaCSP*eval(lVar)^(-rho_1))^(-1/rho_1)) ~ eval(tVar),
                       data = historicalData[[country]],
                       params=c(rho_1=0.8))
      names(cesModCSP$coefficients) <- c("logscale", "lambda", "rho_1")
      cesModCSP$coefficients <- c(coef(cesModCSP), c(delta_1=alphaCSP, delta=1))
      attr(cesModCSP, "naturalCoeffs") <- EconModels:::makeNatCoef(cesModCSP)
      cesModCSP$formula <- form
      cesModCSP$data <- sdata
      modelsCSP[[country]][[adj]][["noE"]][["CES"]][["kl"]] <- cesModCSP
    }
  }
  # Save cost-share theorem models to disk.
  saveRDS(modelsCSP, file=fileNameCSP)

  #
  # Models where all parameters are estimated (models don't adhere to the cost share theorem)
  # 
  
  models <- list()
  for(country in countries){
    for (flavor in flavors){
      fnoE <- keep_summands(formulas[[country]][[flavor]], -3) # Drop the energy term (3rd term on RHS)
      fwithE <- formulas[[country]][[flavor]]
      # CD models
      models[[country]][[flavor]][["noE"]][["CD"]]   <- cdModel(fnoE, data = historicalData[[country]])
      models[[country]][[flavor]][["withE"]][["CD"]] <- cdModel(fwithE, data = historicalData[[country]])
      # CES models
      models[[country]][[flavor]][["noE"]][["CES"]][["kl"]] <- cesModel(fnoE, 
                                                                        data = historicalData[[country]], 
                                                                        nest=c(1,2), digits = 10)
      nestsWithE <- list(kle=c(1,2,3), lek=c(2,3,1), ekl=c(3,1,2))
      models[[country]][[flavor]][["withE"]][["CES"]] <- lapply(nestsWithE, function(nest){
          cesModel(formula=fwithE, data=historicalData[[country]], nest=nest, digits = 10)
        })
    }      
  }
  # Save models to disk.
  saveRDS(models, file=fileNameCDCES)
}  ### END ELSE FROM WAY UP THERE???
@

<<Models2>>=
### TIME FOR A NEW R CHUNK -- That helps detect the end of that long code chunk

### This function is the same in each model group below.  DRY (Don't repeat yourself).
### Using this makes it (a) easier to see what's going on, and (b) easier to make adjustments
### that affect all of the situations simultaneously.

### General hint:  If you find yourself wanting to copy and paste a chunk of code, there is usually
### a better way to do what you are about to do.

model2df <- function(mod, id){
  # Parse the id to find out whether this is quality-adjusted data, etc.
  ### Don't name non-lists with variables whose names sound like a list.
  ### I'm guessing you just didn't know what kind of data you were working with here. 
  ### Either way, it's a bad thing.
  id_components <- strsplit(id, split = "[.]")[[1]]
  
  # return this data frame 
  ### NOTE: ifelse() and [ ] handle NAs the way we want here
  ### The former use of [[ ]] was unnecessary and would break things in the new code
  ### I'm guessing you had [[ ]] because you thought you had a list when you did not.
  
  ### NOTE: data_frame does not auto-convert to factors.  It leaves things as strings.
  data_frame(
    Country = id_components[1], 
    flavor  = ifelse(id_components[2]=="unadjusted", "Unadjusted", "Quality-adjusted"),
    energy  = ifelse(id_components[3]=="noE", "Without energy", "With energy"),
    model   = id_components[4], 
    nest    = id_components[5]) %>%  
  cbind(naturalCoef(mod)) %>% 
  cbind(data.frame(sse = sum(resid(mod)^2)))
} 

### AH: So much tidier here :-)
### NOTE: dplyr::bind_rows() can replace plyr::rbind.fill() in most (all?) situations
###       plyr should probably not be used for data frame level operations anymore.

# Put all exponential model coefficients into a data frame
AllCoeffsExp <- 
  leaf_apply(modelsExp, class = c("lm"), f = model2df) %>%
  bind_rows() %>%
  mutate(model = "exp", CSP = NA)  

# Put all the cost-share theorem (CSP) model coefficients into a data frame
AllCoeffsCSP <- 
  leaf_apply(modelsCSP, class = c("lm"), f = model2df) %>% 
  bind_rows() %>%
  mutate(CSP = "w/ CSP")

# Put all CD and CES model coefficients into a data frame.  
AllCoeffsNoCSP <- 
  leaf_apply(models, class = c("CDEmodel", "cesModel", "LINEXmodel"), f = model2df) %>%
  bind_rows() %>%
  mutate(CSP="w/o CSP")


AllCoeffs <- bind_rows(AllCoeffsExp, AllCoeffsCSP, AllCoeffsNoCSP)

AllCoeffs <-
  AllCoeffs %>% 
  mutate( 
    nest = ifelse(is.na(nest), "", nest),
    CSP = ifelse( CSP == "w/ CSP", "w/ CSP", "w/o CSP")
    )
    

### It looks like this could also be done the otehr way arround:  We could scoop up all the models
### into AllCoeffs and then filter to the subsets.

# Get reference values for lambda and sse.
### This could be done without saving ref if we have no other need for it
### I've renamed ref to Ref since it is a data frame.
Ref <- 
  AllCoeffs %>% 
  filter(model=="exp") %>% 
  select(Country, sse, lambda) %>%
  rename(sse_ref = sse, lambda_ref = lambda)
AllCoeffs <- merge(AllCoeffs, Ref)

# Calculate differences relative to the reference model
### If all we need are the differences, we could skip the part where we put the intermediate stuff 
### into AllCoefs

AllCoeffs <- 
  AllCoeffs %>%
  mutate(
    Dlambda = abs(lambda) - abs(lambda_ref), 
    Dsse = sse - sse_ref,
    percDlambda = Dlambda / abs(lambda_ref) * 100, 
    percDsse = Dsse / sse_ref * 100
  )

# Relevel factors and re-order data
### NOTE:  Need to convert from strings to factors to use relevelFactor()
###        We could modify relevelFacotr() to accept character inputs
AllCoeffs <- 
  AllCoeffs %>%
  mutate(
    Country = relevelFactor(factor(Country), c("PT", "UK")),
    flavor = relevelFactor(factor(flavor), c("Unadjusted", "Quality-adjusted")),
    energy = relevelFactor(factor(energy), c("Without energy", "With energy")),
    model = relevelFactor(factor(model), c("exp", "CD", "CES")),
    nest = relevelFactor(factor(nest), c("kl", "kle", "lek", "ekl")),
    CSP = relevelFactor(factor(CSP), c("w/ CSP", "w/o CSP"))
  ) %>% 
  arrange(Country, model, flavor, energy, nest, CSP)
@

<<Resampling>>=
resampleFilename <- "EcolEcon2015kleResamples.rds"
if (rerunResampling){
  # Run some resampling on the PT and UK models that adhere to the cost-share theorem,
  # includes energy, uses quality-adjusted variables, and employs the (kl)e nesting.
  # This is u-g-l-y code. Just getting something running for now.
  modPT <- models$PT$adjusted$withE$CES$kle
  modUK <- models$UK$adjusted$withE$CES$kle
  resamplesPT <- resampledFits(modPT, method = "wild", n = nResamples)
  resamplesUK <- resampledFits(modUK, method = "wild", n = nResamples)
  resampleCoeffs <- rbind(cbind(resamplesPT$coeffs, Country="PT"), cbind(resamplesUK$coeffs, Country="UK"))
  resampleCoeffs$energy <- TRUE
  resampleCoeffs$nest <- "(kl)e"
  saveRDS(resampleCoeffs, file = resampleFilename)
} else {
  resampleCoeffs <- readRDS(resampleFilename)
}
@


<<Fitted_and_Residuals>>=
### Why are we going back and forth between CamelCase and interspersed_underscores?
### If there isn't a reason, probably we should stick with one naming convention.

temp_data_exp <- 
  leaf_apply(
    modelsExp, class=c("lm"), 
    f = function(model, id){
      ### Why wrap in data.frame() something that already is a tbl_df?  If this is necessary, say why.
      #  df <- data.frame(select(model$data, Year, Country))
      ### Also: let's use a consistent style for the dplyr commands, prefering to use %>% in most cases.
      ### Also: The following use of white space makes it clearer what is going on (and how many steps 
      ###       are involved.  I'm going to change A LOT of code to this format.
      ### In this format, there is no name to create a temporary variable (or to use return())
      
      model$dat %>% 
        select(Year, Country) %>%
        mutate(
          Country = as.character(Country),  # to avoid warning about unmatched levels of factors
          fittedExp = exp(fitted(model)), # exp accounts for the fact that the model was fitted in log space.
          ResidualsExp = resid(model)     ### Why is this capitalized?
        )
    }
  ) %>% 
  bind_rows()

### If the function is this long, it should be separated out and named rather than embedded in another
### function call.  
### But this looks like model2df from above.  Let's use that instead.

### Probably just junk now.
# function_that_was_here_before <- function(model, id){
#   df <- data.frame(select(model$data, Year, Country, iGDP))
#   df$fitted <- exp(fitted(model)) # fitted is in log space. Return to regular space.
#   df$Residuals <- resid(model) # residuals are in log space, and that is what we want.
#   # Now add meta information
#   id_list <- strsplit(id, split = "[.]")[[1]]
#   df$flavor <- if (id_list[[2]] ==  "unadjusted") "Unadjusted" else "Quality-adjusted"
#   df$energy <- if (id_list[[3]] == "noE") "Without energy" else "With energy"
#   df$model <- id_list[[4]]
#   df$nest <- if (length(id_list) > 4) id_list[[5]] else NA
#   return(df)
# }

### One line for each operation:  first leaf_apply, then rbind, then mutate -- Clarity by Code Convention
temp_data_CSP <- 
  leaf_apply(modelsCSP, class=c("plm", "lm"), model2df) %>% 
  bind_rows() %>%
  mutate(CSP = "w/ CSP")

### This looks like a candidate for clean up a la model2df

function_that_was_here_before <- function(model, id){
  df <- data.frame(select(model$data, Year)) 
  # By including [c(1:length(df$Year))] on the end, we 
  # add NAs (as appropriate) to the end of these columns
  # if data do not exist.
  df$fitted <- yhat(model)[c(1:length(df$Year))]
  df$Residuals <- resid(model)[c(1:length(df$Year))]
  # Now add the response, using the original variable name.
  df[[summands(model$formula, right = FALSE)]] <- response(model)[c(1:length(df$Year))]
  # Now add meta information
  id_list <- strsplit(id, split = "[.]")[[1]]
  len <- length(id_list)
  df$Country <- id_list[[1]]
  df$flavor <- if (id_list[[2]] ==  "unadjusted") "Unadjusted" else "Quality-adjusted"
  df$energy <- if (id_list[[3]] == "noE") "Without energy" else "With energy"
  df$model <- id_list[[4]]
  df$nest <- if (length(id_list) > 4) id_list[[5]] else NA
  return(df)  
}

temp_data_noCSP <- 
  leaf_apply(models, class=c("CDEmodel", "cesModel", "LINEXmodel"), function_that_was_here_before) %>% 
  bind_rows() %>%
  mutate(CSP = "w/o CSP")

temp_data_noExp <- 
  bind_rows( temp_data_CSP, temp_data_noCSP )

# Now merge the exponential-only model with the CSP and noCSP models. 
# Doing this, because the exponential-only model is kind-of like iY:
# it applies to all situations.
fitted_and_resid_data <- 
  merge(temp_data_noExp, temp_data_exp) %>% 
  mutate( Dr = abs(Residuals) - abs(ResidualsExp) )  
### Caps in bad places?

# Create a column containing ∆r, the difference between a residual value
# and the residual value in the same year for the reference model
### BREAK LONG LINES IN REASONABLE PLACES
### BUT better to use mutate here.  See above.
# fitted_and_resid_data[["Dr"]] <- 
#   abs(fitted_and_resid_data[["Residuals"]]) - abs(fitted_and_resid_data[["ResidualsExp"]])

# Relevel factors before plotting
### Use mutate for this stuff!
### Align = to make similarities between successive lines stand out.

fitted_and_resid_data <-
  fitted_and_resid_data %>% 
  mutate(
    Country = relevelFactor(factor(Country), c("PT", "UK")),
    flavor  = relevelFactor(factor(flavor), c("Unadjusted", "Quality-adjusted")),
    energy  = relevelFactor(factor(energy), c("Without energy", "With energy")),
    nest    = relevelFactor(factor(nest), c("kl", "kle", "lek", "ekl"))
  ) %>%
  arrange(Country, CSP, model, flavor, energy, nest)
@



%++++++++++++++++++++++++++++++
\subsection{Fitting residuals} 
\label{sec:fitting_residuals}
%++++++++++++++++++++++++++++++



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results}
\label{sec:results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The primary results from this paper involve the effects of
the following modeling decisions:
rejecting (or adhering to) the cost share theorem,
quality-adjusting (or not) the factors of production,
including energy (or not) in the production function, and
nesting (in the CES model).





We evaluate the effects of these modeling decisions 
first on goodness of fit and Solow residual,
next on factor shares, and 
finally on factor substitutability.


%++++++++++++++++++++++++++++++
\subsection{Goodness of fit and Solow residual} 
\label{sec:fit_and_sr}
%++++++++++++++++++++++++++++++

%
We can evaluate the effect of modeling decisions on 
goodness of fit and Solow residual by
calculating values relative to the reference model.
To do so, we define 
$\Delta \lambda$ and $\Delta sse$, where
%
\begin{equation} \label{eq:delta_lambda}
  \Delta \lambda \equiv \lambda - \lambda_{ref}
\end{equation}
%
and
%
\begin{equation} \label{eq:delta_sse}
  \Delta sse \equiv sse - sse_{ref},
\end{equation}
%
with~$\lambda_{ref}$ and $sse_{ref}$ being the values 
of the Solow residual and $sse$ for the reference model, respectively.
On a percentage basis,
%
\begin{equation} \label{eq:delta_lambda_perc}
  \Delta \lambda \, [\%] = \frac{100 \, \Delta \lambda}{\lambda_{ref}} 
            = \frac{100 \, \lambda}{\lambda_{ref}} - 1 \; ,
\end{equation}
%
and
%
\begin{equation} \label{eq:delta_sse_perc}
  \Delta sse \, [\%] = \frac{100 \, \Delta sse}{sse_{ref}} 
            = \frac{100 \, sse}{sse_{ref}} - 1 \; .
\end{equation}

When $\Delta \lambda$, $\Delta \lambda \, [\%]$, or $\Delta sse$ are negative, 
we observe reduction in the Solow residual ($\lambda$) or
the fitting residuals ($sse$)
relative to the reference model.

Figure~\ref{fig:DSRsse_CES_graph} summarizes 
$\lambda$ and $sse$ 
results for CES models.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tables for paper} 
\label{sec:tables_for_paper}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Table~\ref{tab:CES_sr_gof} shows estimated values of
the scale parameter~($\theta$),
the Solow residual~($\lambda$), and
goodness of fit~(SSE)
for all modeling choices.

<<Table_data>>=
table_data <- 
  AllCoeffs %>%
  plyr::rename(c(model = "Model", energy = "Energy", nest = "Nest")) %>%
  mutate(Nest = 
           plyr::mapvalues(
             Nest,
             from=c("kl", "kle", "lek", "ekl"),
             to=c("$kl$", "$(kl)e$", "$(le)k$", "$(ek)l$")),
         CSP =  
           plyr::mapvalues(
             CSP, 
             from=c("w/ CSP", "w/o CSP"), 
             to=c("Adhere", "Reject")),
         Energy =
           plyr::mapvalues(
             Energy, 
             from=c("Without energy", "With energy"), 
             to=c("Without", "With")),
         Model = 
           plyr::mapvalues(
             Model, 
             from=c("exp"), 
             to=c("Ref."))
  )
@


<<CES_sr_gof, results="asis">>=
data_CES_SR_gof <- 
  table_data %>% 
  filter(Model=="CES" | Model=="Ref.") %>% 
  select(Country, Model, CSP, flavor, Energy, Nest, scale, lambda, sse) %>%
  plyr::rename(c("flavor" = "Factors of prod.",
                  "scale" = "$\\theta$",
                  "lambda" = "$\\lambda$"))

myXTable(data_CES_SR_gof,
         caption="Scale parameter~($\\theta$), Solow residual~($\\lambda$), and sum of squared errors~($sse$) for all modeling choices.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=4)
@

Table~\ref{tab:CES_alpha} shows 
output elasticities~($\alpha$) for all modeling choices.

<<CES_alpha, results="asis">>=
data_CES_alpha <- 
  table_data %>% 
  filter(Model=="CES" | Model=="Ref.") %>% 
  select(Country, Model, CSP, flavor, Energy, Nest, alpha_1, alpha_2, alpha_3) %>%
  plyr::rename(c("flavor" = "Factors of prod.",
                 "alpha_1" = "$\\alpha_k$",
                 "alpha_2" = "$\\alpha_l$",
                 "alpha_3" = "$\\alpha_e$"))
myXTable(data_CES_alpha,
         caption="Output elasticities~($\\alpha$) for all models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=2)
@

Table~\ref{tab:CES_sigma_nest_aware_inner} shows elasticity of substitution~($\sigma$)
for inner nests.
Note that the row with 
``PT, Quality-adjusted, With energy, $(ek)l$ nesting, Rejecting the CSP''
is, in fact, a boundary model that does not include energy.
As such, the only knowable elasticity is $\sigma_{kl}$.

<<CES_sigma_nest_aware_inner, results="asis">>=
sigma_inner_data <- 
  table_data %>% 
  filter(Model=="CES") %>% 
  select(Country, CSP, flavor, Energy, Nest, sigma_12, sigma_23, sigma_13) %>%
  plyr::rename( c("flavor" = "Factors of prod.",
                  "sigma_12" = "$\\sigma_{kl}$",
                  "sigma_23" = "$\\sigma_{le}$",
                  "sigma_13" = "$\\sigma_{ek}$"))
#
myXTable(sigma_inner_data,
         caption="Elasticities of substitution~($\\sigma$) for inner nests of CES models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=2)
@

Table~\ref{tab:CES_sigma_nest_aware_outer} shows elasticity of substitution~($\sigma$)
for outer nests.
Rows with the $kl$ nesting are blank, because they have no outer nest.
The row with
``PT, Quality-adjusted, With energy, $(ek)l$ nesting, Rejecting the CSP''
has no values for $\sigma$, because it has no outer nest, being a boundary model
that includes only~$k$ and~$l$.

<<CES_sigma_nest_aware_outer, results="asis">>=
sigma_outer_data <- 
  table_data %>% 
  filter(Model=="CES") %>% 
  select(Country, CSP, flavor, Energy, Nest, sigma_12_3, sigma_23_1, sigma_13_2) %>%
  plyr::rename(c("flavor" = "Factors of prod.", 
                 "sigma_12_3" = "$\\sigma_{(kl)e}$",
                 "sigma_23_1" = "$\\sigma_{(le)k}$",
                 "sigma_13_2" = "$\\sigma_{(ek)l}$"))
myXTable(sigma_outer_data,
         caption="Elasticities of substitution~($\\sigma$) for outer nests of CES models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=2)
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graphs for paper} 
\label{sec:graphs_for_paper}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%++++++++++++++++++++++++++++++
\subsection{Historical data} 
\label{sec:historical_data_graph}
%++++++++++++++++++++++++++++++

Unadjusted and quality-adjusted data for both Portugal and the United Kingdom 
are shown in Figure~\ref{fig:Historical_Data_Graph}.

<<Historical_Data_Graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Historical data.", warning=FALSE>>=

### Also, I find tidyr::gather() and tidyr::spread() easier to work with than melt() and cast()

histDataForGraph <- 
  leaf_apply(formulas, class = "formula", f=function(form, name){
    meta <- strsplit(name, split="[.]")[[1]]
    Country <- meta[1]
    flavor <- meta[2]
    measure.vars <- c(summands(form, right=FALSE), summands(form, 1:3))
    ### Is there any reason to select away some of the columns?
    trimmed_historical_data <- historicalData[[Country]][c("Year", measure.vars)]
    
    # return this.
    melt(
      trimmed_historical_data, 
      measure.vars = measure.vars, 
      value.name = "value",
      variable.name = "variable") %>%
    mutate(
      variable = as.character(variable), # eliminate factors, which cause warnings with bind_rows() below.
      Country = Country,
      flavor =  ifelse (flavor == "adjusted", "Quality-adjusted", "Unadjusted")
      )
  }
  ) %>% bind_rows() %>%
  
  mutate( 
    # Change variable names to make a nicer-looking graph and relevel factors before plotting
    variable = plyr::mapvalues(variable,
                               from=c("iGDP", 
                                      "iKstkS.L", "iKservS.L", "iKstkO.WwithRD", "iKservO.WwithRD",
                                      "iL", "ihLest",
                                      "iXpMP", "iXp", "iUMP", "iU"),
                               to=c("y", 
                                    "k", "k", "k", "k",
                                    "l", "l",
                                    "e", "e", "e", "e")),
    Country = relevelFactor(factor(Country), c("PT", "UK")), # Adjusts facet order
    flavor = relevelFactor(factor(flavor), c("Unadjusted", "Quality-adjusted")) # Adjusts facet order
  )

historicalPlot(
  histDataForGraph, 
  mapping=aes(x=Year, y=value, group=variable, linetype=variable), 
  facet_formula = flavor ~ Country, 
  line_types = c(1,2,4,3,2,4,3,2,3,2,3)) + 
xlab("") + 
scale_y_continuous(breaks=c(1, 2, 4, 6, 8, 10, 12), limits=c(0.5, 12)) +
ylab("Indexed (1960=1)") +
scale_fill_discrete(breaks=c("y", "k", "l", "e"))
@


%++++++++++++++++++++++++++++++
\subsection{Fits to historical data} 
\label{sec:fits_to_historical_data}
%++++++++++++++++++++++++++++++

<<Fitted_and_Residual_Graph_Functions>>=

### Can fittedGraphNoCSP and fittedGraphCSP be combined into one function with an argument?
### Or can the data filtering happen outside and everything else be the same?
### Did you copy and paste to make one from the other?  That should be a sign...
fittedGraphNoCSP <- function(data){
  fittedGraphData <- 
    data %>% 
    select(Year, Country, iGDP, fitted, fittedExp, flavor, energy, CSP, nest) %>%
    melt(measure.vars = c("iGDP", "fitted", "fittedExp"), 
         value.name = "value", variable.name = "variable") %>%
    mutate(label = paste(variable, energy)) %>%
    # Now collapse some of the information. Don't need multiple versions of the exponential model, e.g.
    filter(label %in% c("iGDP With energy", "fittedExp With energy", 
                        "fitted With energy", "fitted Without energy")
    ) %>% 
    mutate(
      label = plyr::mapvalues(label, 
                              from = c("iGDP With energy",  "fittedExp With energy",
                                       "fitted With energy", "fitted Without energy"), 
                              to = c("GDP",  "Ref. model",
                                     "w/ energy", "w/o energy")),
      label = relevelFactor(factor(label), 
                            c("GDP", "Ref. model", "w/o energy", "w/ energy"))
    )
  
  # Make (and return) the graph
  ggplot() +
    geom_line(data=fittedGraphData, mapping=aes(x=Year, y=value, group=label, linetype=label)) +
    scale_linetype_manual(values=c(1,4,2,3), name="") +
    facet_grid(flavor ~ Country) +
    scale_x_continuous(breaks=c(1960, 1980, 2000)) +
    scale_y_continuous(breaks=c(1, 2, 4, 6, 8, 10, 12)) +
    xlab("") +
    ylab("Indexed GDP (1960=1)") +
    xy_theme()
}
@

Both historical GDP and fitted GDP are shown in 
Figures~\ref{fig:Graphs_CESkle-fitted}--\ref{fig:Graphs_CESekl-fitted}.
%
<<Graphs_CESkle-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="CES models with $kl$ and ($kl$)$e$ nesting that reject the CSP. Solid line is historical GDP.">>=
fittedGraphData_kle <- 
  fitted_and_resid_data %>% 
  filter(model=="CES" & CSP=="w/o CSP" & (nest == "kl" | nest == "kle"))

fittedGraphNoCSP(fittedGraphData_kle)
@


%++++++++++++++++++++++++++++++
\subsection{Residual plot} 
\label{sec:residual_plot}
%++++++++++++++++++++++++++++++

<<ResidualPlotFunction>>=
residualPlot <- function(data, withEnergyShape = 0){
  ggplot() +
    geom_point(data=data, mapping=aes(x=Year, y=Residuals, shape=energy, color=energy, size=energy)) +
    scale_shape_manual(values=c(1, withEnergyShape)) +
    scale_size_manual(values=c(4,4)) +
    facet_grid(flavor ~ Country) +
    geom_hline(yintercept = 0, colour="gray50", size=0.1) +
    scale_x_continuous(breaks=c(1960, 1980, 2000)) +
    xlab("") +
    ylab("r") + 
    xy_theme() +
    theme(legend.title=element_blank())
}

residualPlot2 <- function(data){
  dataToPlot <- 
    data %>%
    mutate(nest = 
             plyr::mapvalues(
               nest, 
               from=c("kl", "kle", "lek", "ekl"), 
               to=c("kl", "(kl)e", "(le)k", "(ek)l")
               ),
           Model = interaction(nest, CSP, sep = " ", drop=TRUE),
           Inputs = flavor)

  ggplot() +
    geom_point(
      data=dataToPlot, 
      mapping=aes(
        x=Year, 
        y=Residuals, 
        fill=Model, 
        shape=Model, 
        size=Model
        )
      ) +
    facet_grid(flavor ~ Country) +
    geom_hline(yintercept = 0, colour="gray50", size=0.1) +
    scale_x_continuous(breaks=c(1960, 1980, 2000)) +
    xlab("") +
    ylab("r") + 
    xy_theme() +
    labs(color = "Factors of production") +
    # This is custom stuff here to match the model_points_style function. 
    # We can't use model_points_style, because the aesthetics are different here
    # with only two series (kl w/o CSP and (kl)e w/o CSP) in the graph.
    scale_size_manual(values = c(3, 3)) +
    scale_fill_manual(values = c("transparent", "transparent")) +
    scale_shape_manual(values = c(21, 23)) +
  theme(legend.title=element_blank())
}
@

<<Resid_plot_with_ref, eval=FALSE, include=FALSE>>=
# This version of the residual plot includes reference model residuals.
# But the reference model dwarfs all other residuals and looks bad on the graph.
# So, I decided not to use this. ---MKH, 14 Aug 2015

# residualPlot <- function(data, withEnergyShape = 0){
#   # Keep only the data we need
#   residGraphData <- select(data, Year, Country, Residuals, flavor, energy, model, nest, CSP, ResidualsExp)
#   # Melt the data so that we can include the reference model, too.
#   residGraphData <- melt(residGraphData, 
#                          measure.vars=c("Residuals", "ResidualsExp"),
#                          value.name="value",
#                          variable.name="variable")
#   residGraphData$label <- with(residGraphData, paste(variable, energy))
#   
#   # Now collapse some of the information. Don't need multiple versions of the exponential model, e.g.
#   residGraphData <- filter(residGraphData, label=="Residuals With energy" | label=="Residuals Without energy" |
#                              label=="ResidualsExp Without energy")
#   
#   residGraphData$label <- plyr::mapvalues(residGraphData$label, 
#                                           from = c("Residuals With energy", 
#                                                    "Residuals Without energy",
#                                                    "ResidualsExp Without energy"), 
#                                           to = c("With energy", 
#                                                  "Without energy",
#                                                  "Reference model"))
#   # Relevel factors
#   residGraphData$label <- relevelFactor(as.factor(residGraphData$label), 
#                                          c("Without energy", "With energy", "Reference model"))
#   
#   ggplot() +
#     geom_point(data=residGraphData, mapping=aes(x=Year, y=value, shape=label, color=label, size=label)) +
#     scale_shape_manual(values=c(1, withEnergyShape, 5)) +
#     scale_size_manual(values=c(4, 4, 2)) +
#     # scale_color_manual(values=c("gray50", "green", "red")) +
#     facet_grid(Country ~ flavor) +
#     geom_hline(yintercept = 0, colour="gray50", size=0.1) +
#     scale_x_continuous(breaks=c(1960, 1980, 2000)) +
#     xlab("") +
#     ylab("r") + 
#     xy_theme() +
#     theme(legend.title=element_blank())
# }
@

Because we fit in log-space, fitting residuals ($r_i$) are defined as
%
\begin{equation} \label{eq:log-residuals}
  r_i \equiv \ln(y_i) - \ln(\hat{y}_i) =\ln\left( \frac{y_i}{\hat{y}_i} \right), 
\end{equation}
%
where $r_i$ will be zero when there is agreement between 
historical~($y_i$) and fitted~($\hat{y}_i$) economic output.

Figures~\ref{fig:Graphs CESkle-resid}--\ref{fig:Graphs CESekl-resid}
show fitting residuals for all CES models.
%
<<Graphs_CESkle-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for CES models with $(kl$)$e$ nesting.">>=
residualPlot(
  fitted_and_resid_data %>% 
    filter(model=="CES" & CSP=="w/o CSP" & (nest=="kle" | nest=="kl")), 
  withEnergyShape = 0) # square
@
%
<<Graphs_CESkle-resid_2, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for CES models with $(kl$)$e$ nesting. This is an alternative version that uses our new plot style.">>=
residualPlot2(
  fitted_and_resid_data %>% 
    filter(model=="CES" & CSP=="w/o CSP" & (nest=="kle" | nest=="kl"))
  )
@



%++++++++++++++++++++++++++++++
\subsection{SSE and Solow residual} 
\label{sec:SSE_and_SR_graphs}
%++++++++++++++++++++++++++++++

<<SRsse_CES_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Solow Residuals~($\\lambda$) and mean squared error~($sse$). $\\lambda$ and $sse$ values for the reference (exponential-only) model are shown as gridlines.">>=
data_sr_sse <- 
  AllCoeffs %>% 
  filter(model=="CES") %>% 
  mutate(nest = 
           plyr::mapvalues(
             nest, 
             from=c("kl", "kle", "lek", "ekl"), 
             to=c("kl", "(kl)e", "(le)k", "(ek)l")
             ),
         Model = interaction(nest, CSP, sep = " ", drop=TRUE),
         Inputs = flavor
  )
ggplot() +
  geom_point(data=data_sr_sse, mapping=aes(x=sse, y=lambda, color=energy, size=CSP, shape=nest)) +
  geom_vline(aes(xintercept = sse), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, sse), 
             colour="gray50", size=0.1) +
  geom_hline(aes(yintercept = lambda), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, lambda), 
             colour="gray50", size=0.1) +
  scale_size_manual(values=c(2,4)) +
  scale_shape_manual(values=c(1,0,3,4)) + 
  facet_grid(flavor ~ Country) +
  scale_y_continuous(breaks=c(0, 0.01, 0.02, 0.03), limits=c(0, 0.035)) +
  xlab("SSE") + 
  ylab(expression(lambda)) +
  xy_theme() +
  theme(legend.title=element_blank())

@


<<SRsse_CES_graph_2, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=2.5, fig.cap="Solow Residuals~($\\lambda$) and mean squared error~($sse$). $\\lambda$ and $sse$ values for the reference (exponential-only) model are shown as gridlines. This version uses our proposed new style.">>=
data_sr_sse <- 
  AllCoeffs %>% 
  filter(model=="CES") %>% 
  mutate(nest = 
           plyr::mapvalues(
             nest, 
             from=c("kl", "kle", "lek", "ekl"), 
             to=c("kl", "(kl)e", "(le)k", "(ek)l")
             ),
         Model = interaction(nest, CSP, sep = " ", drop=TRUE),
         Inputs = flavor
  )

p <- ggplot() +
  geom_point(
    data=data_sr_sse, 
    mapping=aes(
      x=lambda, 
      y=sse, 
      fill=Model, 
      shape=Model, 
      size=Model, 
      color=Inputs
      )) +
  geom_vline(aes(xintercept = lambda), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, lambda), 
             colour="gray50", size=0.1) +
  geom_hline(aes(yintercept = sse), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, sse), 
             colour="gray50", size=0.1) +
  facet_grid(. ~ Country) +
  scale_x_continuous(breaks=c(0, 0.01, 0.02, 0.03), limits=c(0, 0.035)) +
  xlab(expression(lambda)) +
  scale_y_continuous(limits=c(-0.05, 0.7)) +
  ylab("SSE") + 
  labs(color = "Factors of production") +
  xy_theme() # +
  # theme(legend.title=element_blank())

# Add our style
model_points_style(p)

@


<<SRsse_CES_graph_3, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Solow Residuals~($\\lambda$) and mean squared error~($sse$). $\\lambda$ and $sse$ values for the reference (exponential-only) model are shown as gridlines. This version uses our proposed new style.">>=
data_sr_sse <- 
  AllCoeffs %>% 
  filter(model=="CES") %>% 
  mutate(nest = 
           plyr::mapvalues(
             nest, 
             from=c("kl", "kle", "lek", "ekl"), 
             to=c("kl", "(kl)e", "(le)k", "(ek)l")
             ),
         Model = interaction(nest, CSP, sep = " ", drop=TRUE),
         Inputs = flavor
  )

p <- ggplot() +
  geom_point(
    data=data_sr_sse, 
    mapping=aes(
      x=lambda, 
      y=sse, 
      fill=Model, 
      shape=Model, 
      size=Model #, 
      # color=Inputs
      )) +
  geom_vline(aes(xintercept = lambda), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, lambda), 
             colour="gray50", size=0.1) +
  geom_hline(aes(yintercept = sse), 
             AllCoeffs %>% filter(model=="exp") %>% select(Country, sse), 
             colour="gray50", size=0.1) +
  facet_grid(flavor ~ Country) +
  scale_x_continuous(breaks=c(0, 0.01, 0.02, 0.03), limits=c(0, 0.035)) +
  xlab(expression(lambda)) +
  scale_y_continuous(limits=c(-0.05, 0.7)) +
  ylab("SSE") + 
  labs(color = "Factors of production") +
  xy_theme() # +
  # theme(legend.title=element_blank())

# Add our style
model_points_style_quad(p)

@


%++++++++++++++++++++++++++++++
\subsection{Output elasticities} 
\label{sec:output_elasticities_graph}
%++++++++++++++++++++++++++++++

Figures~\ref{fig:Factor_shares_graph_PT} and~\ref{fig:Factor_shares_graph_UK}
show factor shares ($\alpha$ values) for CES models for
Portugal and the UK, respectively.
See Table~\ref{tab:CES_abg_equations} for details on the calculation
of factor shares from fitted values of $\delta_1$ and $\delta$.
%
<<Factor_shares_bar_graph_function>>=
fsbg <- function(coun, mod){
  bar_chart_data <- 
    AllCoeffs %>% 
    filter(Country==coun & model==mod) %>% 
    select(Country, model, flavor, energy, nest, CSP, alpha_1, alpha_2, alpha_3) %>%
    mutate(nest =   # Change nest to a nicer-looking nest string
             plyr::mapvalues(nest, 
                             from=c("kl", "kle", "lek", "ekl"), 
                             to=c("kl", "(kl)e", "(le)k", "(ek)l")),
           label = # Add a label column
              paste(CSP, flavor, energy, nest, sep=", "),
           label =  # Add row numbers to the label column
              paste(paste0(1:length(label), ". "), label)
    )
  # Capture the order that we want for the models on the vertical axis.
  order <- bar_chart_data$label
  # Now melt the data
  ### tidyr::spread and tidyr::gather are preferred in most cases now
#   bar_chart_data <- melt(bar_chart_data, 
#                          measure.vars = c("alpha_1", "alpha_2", "alpha_3"), 
#                          value.name = "value", 
#                          variable.name = "variable")
  bar_chart_data <-
    bar_chart_data %>% gather( key=variable, value=value, alpha_1 : alpha_3 )

  # Make the plot
  plot <- ggplot(bar_chart_data, mapping=aes(x=label, y=value, fill=variable, width=0.4)) + 
    geom_bar(stat="identity") + 
    xlab("") +
    scale_x_discrete(limits=rev(order)) +
    ylab("") +
    scale_y_continuous(breaks=c(0, 0.5, 1)) + 
    guides(fill=guide_legend(title=NULL)) +
    coord_flip() + 
    scale_fill_brewer(palette="OrRd", 
                      labels=c(expression(alpha[k]), expression(alpha[l]), expression(alpha[e]))) +
    xy_theme() +
    theme(axis.ticks.y = element_blank())
  return(plot)
}
@

<<Factor_shares_graph_PT, fig.pos="H", fig.align='center', fig.width=7.5, fig.height=2.5, fig.cap="Factor shares ($\\alpha$ values) for CES models for Portugal.">>=
fsbg(coun = "PT", mod = "CES")
@

<<Factor_shares_graph_UK, fig.pos="H", fig.align='center', fig.width=7.5, fig.height=2.5, fig.cap="Factor shares ($\\alpha$ values) for CES models for the UK.">>=
fsbg(coun = "UK", mod = "CES")
@

<<output_elasticities_graph_ternary, fig.pos="H", fig.align="center", fig.width=7.5, fig.height=2.8, fig.cap="Ternary graph of output elasticities~($\\alpha$). This version shows all Unadjusted and Quality-adjusted points on the same graph. Perhaps it is easier to see the effect of quality-adjustment of data this way.">>=
p <- triPlot(
  data=
    AllCoeffs %>% filter(model == "CES") %>%
    mutate( nest = plyr::mapvalues(nest, 
                                   from=c("kle", "lek", "ekl"), 
                                   to=c("(kl)e", "(le)k", "(ek)l")),
            Model = interaction(nest, CSP, sep = " ", drop=TRUE),
            Inputs = flavor
            ), 
  grid_lines = 5,
  labels = c("alpha[k]", "alpha[l]", "alpha[e]"),
  aes(x = alpha_1, y = alpha_2, z = alpha_3, 
      fill  = Model, 
      shape = Model,
      size = Model,
      color = Inputs)
  ) +
  labs(color = "Factors of production") +
  facet_grid(. ~ Country)
  model_points_style(p)
@

<<output_elasticities_graph_ternary_2, fig.pos="H", fig.align="center", fig.width=7.5, fig.height=5, fig.cap="Ternary graph of output elasticities~($\\alpha$). This version splits the Unadjusted and Quality-adjusted values on their own graphs. This approach is parallel to the previous figures (historical data, fitted GDP, and residuals.">>=
p <- triPlot(
  data=
    AllCoeffs %>% filter(model == "CES") %>%
    mutate( nest = plyr::mapvalues(nest, 
                                   from=c("kle", "lek", "ekl"), 
                                   to=c("(kl)e", "(le)k", "(ek)l")),
            Model = interaction(nest, CSP, sep = " ", drop=TRUE),
            Inputs = flavor), 
  grid_lines = 5,
  labels = c("alpha[k]", "alpha[l]", "alpha[e]"),
  aes(x = alpha_1, y = alpha_2, z = alpha_3, 
      fill  = Model, 
      shape = Model,
      size = Model
      # color = Inputs
      )
  ) +
  facet_grid(Inputs ~ Country)
    
  model_points_style_quad(p)
@


%++++++++++++++++++++++++++++++
\subsection{$\sigma$ graphs} 
\label{sec:sigma_graphs}
%++++++++++++++++++++++++++++++

<<sigma_graph>>=
sigma_graph <- function(data){
  sigma_graph_data <- 
    data %>% 
    select(Country, CSP, flavor, energy, nest, 
           sigma_12, sigma_23, sigma_13, 
           sigma_12_3, sigma_23_1, sigma_13_2) %>%
    mutate(nest = plyr::mapvalues( # Change nest to a nicer-looking nest string
      nest, 
      from=c("kl", "kle", "lek", "ekl"), 
      to=c("kl", "(kl)e", "(le)k", "(ek)l"))
    ) %>%
    gather(variable, value, sigma_12, sigma_23, sigma_13, sigma_12_3, sigma_23_1, sigma_13_2) %>%
    mutate(label = paste(CSP, flavor, energy, nest, variable, sep=", ")) %>%
    na.omit()
  
  # return(sigma_graph_data)
  
  # Make the plot
  plot <- ggplot(sigma_graph_data, mapping=aes(x=label, y=value, fill=variable, width=0.4)) + 
    geom_bar(stat="identity") + 
    xlab("") +
    # scale_x_discrete(limits=rev(order)) +
    scale_x_discrete(labels=sigma_graph_data$label) +
    geom_hline(aes(yintercept = 1), colour="gray50", size=0.1) +
    ylab("") +
    # coord_trans(y="sigma") +
    scale_y_continuous(limits=c(0, 10), breaks=c(0, 1.0, 10)) +
    guides(fill=guide_legend(title=NULL)) +
    scale_fill_brewer(palette="OrRd") +
#     scale_fill_brewer(palette="OrRd",
#                       labels=c(expression(sigma[kl]), 
#                                expression(sigma[le]), 
#                                expression(sigma[ek]),
#                                expression(sigma["(kl)e"]),
#                                expression(sigma["(le)k"]),
#                                expression(sigma["(ek)l"]))) +
    coord_flip() + 
    xy_theme() +
    theme(axis.ticks.y = element_blank())
  return(plot)
}
@

<<sigma_graph_PT, fig.pos="H", fig.align='center', fig.width=7.5, fig.height=3.3, fig.cap="Elasticities of substitution~($\\sigma$) for Portugal.">>=
sigma_graph(AllCoeffs %>% filter(model=="CES", Country=="PT"))
@

<<sigma_graph_UK, fig.pos="H", fig.align='center', fig.width=7.5, fig.height=3.3, fig.cap="Elasticities of substitution~($\\sigma$) for the UK.">>=
sigma_graph(AllCoeffs %>% filter(model=="CES", Country=="UK"))
@

<<sigma_graph_2, fig.pos="H", fig.align='center', fig.width=8.5, fig.height=5, fig.cap="Elasticities of substitution~($\\sigma$).">>=
breaks_labels = c(0.01, 0.1, 1, 10, 100)
p <- 
ggplot(
  AllCoeffs %>% 
    gather(type, value, matches("sigma")) %>% 
    filter(!is.na(value)) %>% 
    filter(! type %in% c("sigma", "sigma_1")) %>%
    mutate(nest = plyr::mapvalues(nest, 
                                  from=c("kle", "lek", "ekl"), 
                                  to=c("(kl)e", "(le)k", "(ek)l")),
           type = relevelFactor(type, c("sigma_12", "sigma_23", "sigma_13", "sigma_12_3", "sigma_23_1", "sigma_13_2")),
           Model = interaction(nest, CSP, sep = " ", drop=TRUE),
           Inputs = flavor
           )
  ) + 
  geom_point(aes(x=value, y=type, 
                 shape = Model, fill=Model, size=Model,
                 color=Inputs
                 )
                 # position = position_jitter(height=0.2, width=0)
             ) + 
  facet_grid( type ~ Country, scales = "free_y" ) + 
  scale_x_log10(limits = c(0.001,2000), breaks=breaks_labels, labels=breaks_labels) +
  xlab("") +
  geom_vline(xintercept = 1, color="gray50", size=0.2) +
  scale_y_discrete(labels = c(
    sigma_12 = expression(sigma[kl]),
    sigma_23 = expression(sigma[le]),
    sigma_13 = expression(sigma[ek]),
    sigma_12_3 = expression(sigma["(kl)"*e]),
    sigma_23_1 = expression(sigma["(le)"*k]),
    sigma_13_2 = expression(sigma["(ek)"*l]))
    ) +
  ylab("") +
  labs(color = "Factors of production") +
  xy_theme() +
  theme(
    legend.position="top",
    strip.text.y = element_blank())

model_points_style(p)
@

<<sigma_graph_3, fig.pos="H", fig.align='center', fig.width=8.5, fig.height=5, fig.cap="Elasticities of substitution~($\\sigma$) with factors of production on the vertical facet.">>=
breaks_labels = c(0.01, 0.1, 1, 10, 100)
p <- 
  ggplot(
    AllCoeffs %>% 
      gather(type, value, matches("sigma")) %>% 
      filter(!is.na(value)) %>% 
      filter(! type %in% c("sigma", "sigma_1")) %>%
      mutate(nest = plyr::mapvalues(nest, 
                                    from=c("kle", "lek", "ekl"), 
                                    to=c("(kl)e", "(le)k", "(ek)l")),
             Model = interaction(nest, CSP, sep = " ", drop=TRUE),
             Inputs = flavor,
             type = relevelFactor(type, rev(c("sigma_12", "sigma_23", "sigma_13", "sigma_12_3", "sigma_23_1", "sigma_13_2")))
             )
    ) + 
  geom_point(aes(x=value, 
                 y=type, 
                 shape = Model, 
                 fill=Model, 
                 size=Model
                 )
             ) + 
  facet_grid( Inputs ~ Country) + 
  scale_x_log10(limits = c(0.001,2000), breaks=breaks_labels, labels=breaks_labels) +
  xlab("") +
  geom_vline(xintercept = 1, color="gray50", size=0.2) +
  ylab("") +
  scale_y_discrete(labels = c(
    sigma_12 = expression(sigma[kl]),
    sigma_23 = expression(sigma[le]),
    sigma_13 = expression(sigma[ek]),
    sigma_12_3 = expression(sigma["(kl)"*e]),
    sigma_23_1 = expression(sigma["(le)"*k]),
    sigma_13_2 = expression(sigma["(ek)"*l]))
    ) +
  xy_theme()

model_points_style_quad(p)
@


%++++++++++++++++++++++++++++++
\subsection{Resampling} 
\label{sec:resampling}
%++++++++++++++++++++++++++++++

<<resample_graph_lambda_theta, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.5, fig.cap="$\\lambda$ and $\\theta$ values for resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardScatterPlot(data=resampleCoeffs, mapping=aes(scale, lambda), facet_formula=~Country, alpha=0.05, orig_color = "black") +
    scale_x_continuous(breaks=c(0.95, 1.0, 1.05)) + 
    scale_y_continuous(breaks=c(0, 0.005, 0.01), limits=c(0, 0.01)) +
    labs(x=expression(theta), y=expression(lambda))
@

<<resample_graph_sigma1_delta1, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.5, fig.cap="$\\sigma_{(kl)}$ and $\\delta_1$ values for resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardScatterPlot(data=resampleCoeffs, mapping=aes(delta_1, sigma_1), 
                    facet_formula=~Country, alpha=0.1) +
    coord_trans(y="sigma2") +
    scale_x_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0,1)) +
    scale_y_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0, 1e6)) +
    labs(x=expression(delta[1]), y=expression(sigma[kl]))
@

<<resample_graph_sigma_delta, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.5, fig.cap="$\\sigma_{(kl)e}$ and $\\delta$ values for resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardScatterPlot(data=resampleCoeffs, mapping=aes(delta, sigma), 
                    facet_formula=~Country, alpha=0.1) +
    coord_trans(y="sigma2") +
    scale_x_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0,1)) +
    scale_y_continuous(breaks=c(0, 0.5, 1.0, 2.0), limits=c(0, 1e6)) +
    labs(x=expression(delta), y=expression(sigma["(kl)"*e]))
@

<<resample_graph_alpha, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=3.0, fig.cap="$\\alpha_k$, $\\alpha_l$, and $\\alpha_e$ values for CES resample models that adhere to the cost share theorem, include energy, use quality-adjusted factors of production, and employ the ($kl$)$e$ nesting.">>=
standardTriPlot(data=resampleCoeffs, facet_formula=~Country, alpha=0.1,
                labels=c("alpha[k]", "alpha[l]", "alpha[e]"), size=2.0)
@




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
\label{sec:Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future Work}
\label{sec:FutureWork}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}
\label{sec:Acknowledgements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section*{Reproducible Research}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% In the spirit of Reproducible Research \citep{Gandrud:2013vx}, 
% all data, spreadsheets, \texttt{R} code \citep{R}, and other materials 
% associated with this paper can be found at\\*
% \protect\url{https://github.com/MatthewHeun/Econ-Growth-R-Analysis}.



%% References
%%
%% Following citation commands can be used in the body text:
%%
%%  \citet{key}  ==>>  Jones et al. (1990)
%%  \citep{key}  ==>>  (Jones et al., 1990)
%%
%% Multiple citations as normal:
%% \citep{key1,key2}         ==>> (Jones et al., 1990; Smith, 1989)
%%                            or  (Jones et al., 1990, 1991)
%%                            or  (Jones et al., 1990a,b)
%% \cite{key} is the equivalent of \citet{key} in author-year mode
%%
%% Full author lists may be forced with \citet* or \citep*, e.g.
%%   \citep*{key}            ==>> (Jones, Baker, and Williams, 1990)
%%
%% Optional notes as:
%%   \citep[chap. 2]{key}    ==>> (Jones et al., 1990, chap. 2)
%%   \citep[e.g.,][]{key}    ==>> (e.g., Jones et al., 1990)
%%   \citep[see][pg. 34]{key}==>> (see Jones et al., 1990, pg. 34)
%%  (Note: in standard LaTeX, only one note is allowed, after the ref.
%%   Here, one note is like the standard, two make pre- and post-notes.)
%%
%%   \citealt{key}          ==>> Jones et al. 1990
%%   \citealt*{key}         ==>> Jones, Baker, and Williams 1990
%%   \citealp{key}          ==>> Jones et al., 1990
%%   \citealp*{key}         ==>> Jones, Baker, and Williams, 1990
%%
%% Additional citation possibilities
%%   \citeauthor{key}       ==>> Jones et al.
%%   \citeauthor*{key}      ==>> Jones, Baker, and Williams
%%   \citeyear{key}         ==>> 1990
%%   \citeyearpar{key}      ==>> (1990)
%%   \citetext{priv. comm.} ==>> (priv. comm.)
%%   \citenum{key}          ==>> 11 [non-superscripted]
%% Note: full author lists depends on whether the bib style supports them;
%%       if not, the abbreviated list is printed even when full requested.
%%
%% For names like della Robbia at the start of a sentence, use
%%   \Citet{dRob98}         ==>> Della Robbia (1998)
%%   \Citep{dRob98}         ==>> (Della Robbia, 1998)
%%   \Citeauthor{dRob98}    ==>> Della Robbia


%% References with bibTeX database:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{References}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \bibliographystyle{model2-names}
%%\bibliography{<your-bib-database>}
% \bibliography{Paper2.bib}

%% Authors are advised to submit their bibtex database files. They are
%% requested to list a bibtex style file in the manuscript if they do
%% not want to use model2-names.bst.

%% References without bibTeX database:

% \begin{thebibliography}{00}

%% \bibitem must have one of the following forms:
%%   \bibitem[Jones et al.(1990)]{key}...
%%   \bibitem[Jones et al.(1990)Jones, Baker, and Williams]{key}...
%%   \bibitem[Jones et al., 1990]{key}...
%%   \bibitem[\protect\citeauthoryear{Jones, Baker, and Williams}{Jones
%%       et al.}{1990}]{key}...
%%   \bibitem[\protect\citeauthoryear{Jones et al.}{1990}]{key}...
%%   \bibitem[\protect\astroncite{Jones et al.}{1990}]{key}...
%%   \bibitem[\protect\citename{Jones et al., }1990]{key}...
%%   \harvarditem[Jones et al.]{Jones, Baker, and Williams}{1990}{key}...
%%

% \bibitem[ ()]{}

% \end{thebibliography}


%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix
%% \section{}
%% \label{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Correlograms} 
\label{sec:correlograms}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This appendix contains correlograms for all models.
But, they are not included for now.

%++++++++++++++++++++++++++++++
\subsection{Correlograms for the reference models} 
\label{sec:correlograms_ref}
%++++++++++++++++++++++++++++++

In this section we present correlograms for the reference (exponential-only) models. 

<<Correlograms_Exp, echo=FALSE, message=FALSE, include=FALSE>>=
leaf_apply(l = modelsExp, class = c("lm"), f = function(model, name){
  acf(resid(model), main=name)
})
@


%++++++++++++++++++++++++++++++
\subsection{Correlograms for models that adhere to the cost-share theorem} 
\label{sec:correlograms_CSP}
%++++++++++++++++++++++++++++++

In this section we present correlograms for all models that adhere to the cost-share theorem.

<<Correlograms_CSP, echo=FALSE, message=FALSE, include=FALSE>>=
leaf_apply(l = modelsCSP, class = c("lm", "plm"), f = function(model, name){
  acf(resid(model), main=name)
})
@


%++++++++++++++++++++++++++++++
\subsection{Correlograms for models that reject the cost-share theorem} 
\label{sec:correlograms_noCSP}
%++++++++++++++++++++++++++++++

In this section we present correlograms for all models that reject the cost-share theorem.

<<Correlograms_noCSP, echo=FALSE, message=FALSE, include=FALSE>>=
leaf_apply(l = models, class = c("CDEmodel", "cesModel", "LINEXmodel"), f = function(model, name){
  acf(resid(model), main=name)
})
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Statistical details on all models} 
\label{sec:staistical_details}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section, we present statistical details of all models.

At the moment, this is a simple example of two models.
I hope to develop a table later, after I figure out some things.
Both models are CES models with energy fitted to Quality-adjusted data using the ($kl$)($e$) nesting.
In Table~\ref{tab:stat_details_table}, Model 1 is for Portugal, and Model 2 is for the UK.

This information is not included at present.

<<stat_details_table, results="asis", include=FALSE>>=
texreg(list(models$PT$adjusted$withE$CES$kle, models$UK$adjusted$withE$CES$kle), 
       dcolumn = TRUE, 
       booktabs = TRUE, 
       use.packages = FALSE, 
       label=paste0("tab:", opts_current$get("label")), 
       caption = "Example output from \\texttt{texreg}.",
       caption.above = TRUE, 
       digits = 6,
       fontsize = "tiny",
       float.pos = "hb")
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pre-econometrics graph} 
\label{sec:pre-econometric_graph}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<Pre-econometric_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Pre-econometric data.", warning=FALSE>>=
pre_econometric_data <- 
  leaf_apply(
    formulas, class = "formula", 
    f=function(form, name){
      meta <- strsplit(name, split="[.]") %>% unlist
      Country <- meta[1]
      flavor <- meta[2]
      nums <- summands(form, n=1:3)
      denom <- summands(form, n=1, right=FALSE)
      ratios <- lapply(nums, function(num) {paste(num, denom, sep="/")}) %>% unlist
      coltemplate <- build_formula(NULL, c("Year", ratios))
      trimmed_historical_data <- historicalData[[Country]][all.vars(coltemplate)]
      ratio_data <- evalFormula(coltemplate, data=trimmed_historical_data)$right
      mratio_data <- melt(ratio_data, measure.vars = ratios, value.name = "ratio", variable.name = "variable")
      mratio_data$Country <- Country
      mratio_data$flavor <- if (flavor == "adjusted") "Quality-adjusted" else "Unadjusted"
      return(mratio_data)
    }
  ) %>%  
  bind_rows() 

# Fix levels
pre_econometric_data$flavor <- relevelFactor(as.factor(as.character(pre_econometric_data$flavor)), 
                                               c("Unadjusted", "Quality-adjusted"))
pre_econometric_data$Country <- relevelFactor(as.factor(pre_econometric_data$Country), 
                                              c("PT", "UK"))
pre_econometric_data$variable <- relevelFactor(as.factor(pre_econometric_data$variable),
                                               unique(pre_econometric_data$variable))
# Now make the plot of pre-econometric data
historicalPlot(pre_econometric_data, 
               mapping=aes(x=Year, y=ratio, group=variable, linetype=variable), 
               facet_formula = Country ~ flavor, 
               line_types = c(2,4,3, 2,4,3, 2,3,2, 3)) + 
  xlab("") + 
  ylab("Indexed (1960=1)")
@




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cobb-Douglas Graveyard} 
\label{sec:cd_graveyard}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section is the graveyard for information pertaining to the Cobb-Douglas model.

%------------------------------
\subsubsection{Cobb-Douglas Production Function} 
\label{sec:CDe}
%------------------------------

The Cobb-Douglas production function can be expressed as
%
\begin{equation} \label{eq:CD}
  y = \theta A k^{\alpha_1} l^{\alpha_2} \; ; \; A \equiv \mathrm{e}^{\lambda(t-t_0)} \; ,
\end{equation}
%
where 

Constant returns to scale are represented by the constraint
$\alpha_1 + \alpha_2 = 1$.

The capital-labor Cobb-Douglas production function shown in Equation~\ref{eq:CD}
can be augmented to include an energy term:
%
\begin{equation} \label{eq:CDe}
  y = \theta A k^{\alpha_1} l^{\alpha_2} e^{\alpha_3} \; ; \; A \equiv \mathrm{e}^{\lambda(t-t_0)} \; ,
\end{equation}
%
where $e \equiv E/E_0$, and $E$ is in units of energy per time, typically TJ/year.
The energy-augmented Cobb-Douglas production function 
is often assumed to have constant returns to scale for the three factors 
of production: $\alpha_1 + \alpha_2 + \alpha_3 = 1$.
The term $A$ is known as total factor productivity,
and $\lambda$ is the Solow residual. 

The Cobb-Douglas production function can be expressed as
%
\begin{equation} \label{eq:CD}
  y = \theta A k^{\alpha_1} l^{\alpha_2} \; ; \; A \equiv \mathrm{e}^{\lambda(t-t_0)} \; ,
\end{equation}
%
where 
$y \equiv Y/Y_{0}$,
$\theta$ is a scale parameter,
e is the base of the natural logarithm, 
$\lambda$ is represents the pace of technological progress,
$t$ (time) is measured in years,
$k \equiv K/K_{0}$, 
$l \equiv L/L_{0}$, 
$Y$ (economic output) is represented by GDP, 
$K$ (capital) is expressed in currency units, 
$L$ (labor) is expressed in workers or work-hours/year, and
the 0 subscript indicates values at an initial year.%
  \footnote{Dimensionless, indexed quantities are represented by 
  lower-case symbols 
  ($y$, $k$, $l$, $e$, $q$, $x$, and $u$), and dimensional 
  quantities are represented by upper-case symbols 
  ($Y$, $K$, $L$, $E$, $Q$, $X$, and $U$). 
  Model parameters are represented by Greek letters
  ($\alpha_1$, $\alpha_2$, $\lambda$, $\theta$).
  }
Constant returns to scale are represented by the constraint
$\alpha_1 + \alpha_2 = 1$.

The capital-labor Cobb-Douglas production function shown in Equation~\ref{eq:CD}
can be augmented to include an energy term:
%
\begin{equation} \label{eq:CDe}
  y = \theta A k^{\alpha_1} l^{\alpha_2} e^{\alpha_3} \; ; \; A \equiv \mathrm{e}^{\lambda(t-t_0)} \; ,
\end{equation}
%
where $e \equiv E/E_0$, and $E$ is in units of energy per time, typically TJ/year.
The energy-augmented Cobb-Douglas production function 
is often assumed to have constant returns to scale for the three factors 
of production: $\alpha_1 + \alpha_2 + \alpha_3 = 1$.
The term $A$ is known as total factor productivity,
and $\lambda$ is the Solow residual. 
%
<<Graphs_CD-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Cobb-Douglas models that reject the cost-share theorem. Solid line is historical GDP.">>=
fittedGraphNoCSP(fitted_and_resid_data %>% filter(model=="CD" & CSP=="w/o CSP"))
@

%
<<Graphs_CD-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for Cobb-Douglas models.">>=
residualPlot(fitted_and_resid_data %>% filter(model=="CD" & CSP=="w/o CSP"))
@


Table~\ref{tab:Effect_of_CSP_CD} shows the effect of the CSP 
on fitted parameters for the Cobb-Douglas model and the exponential-only model.
The Cobb-Douglas models show lower $sse$ than the exponential-only models.
The Cobb-Douglas models also reduce solow residual ($\lambda$) relative
to the exponential-only case.
%
<<Effect_of_CSP_CD, results="asis">>=
data_CSP_CD <- 
  AllCoeffs %>%
  filter((model=="CD" & flavor=="Unadjusted" & energy=="Without energy") | model=="exp") %>% 
  select(Country, model, CSP, scale, lambda, alpha_1, alpha_2, sse)

data_CSP_CD <- plyr::rename(data_CSP_CD, c("alpha_1" = "$\\alpha_1$", "alpha_2" = "$\\alpha_2$"))

myXTable(data_CSP_CD,
         caption="Model parameters for Cobb-Douglas models with unadjusted factors of production, without energy.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@
%
Table~\ref{tab:CD_coeffs} shows coefficients for all fitted Cobb-Douglas models
and the reference model (exponential-only).
%
<<CD_coeffs, results="asis">>=
data_CD_exp <- 
  AllCoeffs %>% 
  filter(model=="CD" | model=="exp") %>% 
  select(Country, model, flavor, energy, CSP, scale, lambda, alpha_1, alpha_2, alpha_3, sse)

data_CD_exp <- plyr::rename(data_CD_exp, c("alpha_1" = "$\\alpha_1$", 
                                           "alpha_2" = "$\\alpha_2$", 
                                           "alpha_3" = "$\\alpha_3$"))
myXTable(data_CD_exp,
         caption="Model parameters for all Cobb-Douglas models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@
%

Table~\ref{tab:DSRsse_CD} shows $\Delta \lambda$ and $\Delta sse$ results for the Cobb-Douglas models.
%
<<DSRsse_CD, results="asis">>=
myXTable(AllCoeffs %>% 
           filter(model=="CD") %>% 
           select(Country, model, flavor, energy, CSP, Dlambda, Dsse),
         caption="$\\Delta \\lambda$ and $\\Delta sse$ for Cobb-Douglas models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@
% 

%
Figures~\ref{fig:DSRsse_CD_graph} and~\ref{fig:percDSRsse_CD_graph} summarize 
$\Delta \lambda$ and $\Delta sse$ 
results for the Cobb-Douglas model.
%
<<DSRsse_CD_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Change in Solow Residuals~($\\Delta\\lambda$) and mean squared error~($\\Delta sse$) for the Cobb-Douglas model relative to the exponential-only model.">>=
ggplot() +
  geom_point(data=AllCoeffs %>% filter(model=="CD"), 
             mapping=aes(x=Dsse, y=Dlambda, color=energy, size=CSP)) +
  facet_grid(Country ~ flavor) +
  scale_size_manual(values=c(2,3.5)) +
  xlab(expression(Delta * sse)) + 
  ylab(expression(Delta * lambda)) +
  scale_y_continuous(limits=c(-0.04, 0)) +
  xy_theme() + 
  theme(legend.title=element_blank())
@
%
<<percDSRsse_CD_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Percentage change in Solow Residuals~($\\Delta\\lambda \\, [\\%]$) and mean squared error~($\\Delta sse \\, [\\%]$) for the Cobb-Douglas model relative to exponential-only models.">>=
ggplot() +
  geom_point(data=AllCoeffs %>% filter(model=="CD"), 
             mapping=aes(x=percDsse, y=percDlambda, color=energy, size=CSP)) +
  facet_grid(Country ~ flavor) +
  scale_size_manual(values=c(2,3.5)) +
  xlab(expression(paste(Delta * sse, " [%]"))) + 
  scale_x_continuous(breaks=seq(-50, 50, 50), limits=c(-90, 50)) +  
  ylab(expression(paste(Delta * lambda, " [%]"))) +
  scale_y_continuous(breaks=seq(-80, 0, 20), limits=c(-100, 10)) +  
  xy_theme() + 
  theme(legend.title=element_blank())
@
%
<<DSRsse_CES_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Change in Solow Residuals~($\\Delta\\lambda$) and mean squared error~($\\Delta sse$) for the CES modles relative to the exponential-only model.">>=
ggplot() +
  geom_point(data=AllCoeffs %>% filter(model=="CES"), 
             mapping=aes(x=Dsse, y=Dlambda, color=energy, size=CSP, shape=nest)) +
  scale_size_manual(values=c(2,3.5)) +
  scale_shape_manual(values=c(16,17,18,15)) +
  facet_grid(Country ~ flavor) +
  xlab(expression(Delta * sse)) + 
  scale_x_continuous(breaks=seq(-0.005, 0, 0.005)) +  
  ylab(expression(Delta * lambda)) +
  xy_theme() +
  theme(legend.title=element_blank())
@
%
<<percDSRsse_CES_graph, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Percentage change in Solow Residuals~($\\Delta\\lambda \\, [\\%]$) and mean squared error~($\\Delta sse \\, [\\%]$) for the CES models relative to the exponential-only model.">>=
ggplot() +
  geom_point(data=AllCoeffs %>% filter(model=="CES"), 
             mapping=aes(x=percDsse, y=percDlambda, color=energy, size=CSP, shape=nest)) +
  scale_size_manual(values=c(2,3.5)) +
  scale_shape_manual(values=c(16,17,18,15)) +
  facet_grid(Country ~ flavor) +
  xlab(expression(paste(Delta * SSE, " [%]"))) + 
  scale_x_continuous(breaks=seq(-80, 0, 20)) +  
  ylab(expression(paste(Delta * lambda, " [%]"))) +
  scale_y_continuous(breaks=seq(-80, 0, 20), limits=c(-100, 10)) +  
  xy_theme() +
  theme(legend.title=element_blank())
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{CES Graveyard} 
\label{sec:ces_graveyard}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Here is a table of the raw CES coefficient values. 
This table is not used in the paper, so I'm putting it in the graveyard.
<<CES_sigma, results="asis">>=
### Is sigma_data defined anywhere?

# data_CES_sigma_raw <- sigma_data %>% select(Country, Model, flavor, Energy, Nest, CSP, sigma_1, sigma)
# data_CES_sigma_raw <- plyr::rename(data_CES_sigma_raw, c("sigma" = "$\\sigma$",
#                                                          "sigma_1" = "$\\sigma_1$"))
# data_CES_sigma_raw <- plyr::rename(data_CES_sigma_raw, c("flavor" = "Factors of prod."))
# data_CES_sigma_raw$CSP <- plyr::mapvalues(data_CES_sigma_raw$CSP, 
#                                          from=c("w/ CSP", "w/o CSP"), 
#                                          to=c("Adhere", "Reject"))
# data_CES_sigma_raw$Energy <- plyr::mapvalues(data_CES_sigma_raw$Energy, 
#                                          from=c("Without energy", "With energy"), 
#                                          to=c("Without", "With"))

data_CES_sigma_raw <- AllCoeffs %>%
  filter(model=="CES") %>%
   mutate(
     Nest = plyr::mapvalues(nest,
                            from=c("kl", "kle", "lek", "ekl"),
                            to=c("$kl$", "$(kl)e$", "$(le)k$", "$(ek)l$")),
     CSP = plyr::mapvalues(CSP, 
                           from=c("w/ CSP", "w/o CSP"), 
                           to=c("Adhere", "Reject")),
     Energy = plyr::mapvalues(energy, 
                              from=c("Without energy", "With energy"), 
                              to=c("Without", "With"))
     ) %>%
  select(Country, flavor, Energy, Nest, CSP, sigma_1, sigma) %>%
  plyr::rename(
    c("sigma" = "$\\sigma$",
      "sigma_1" = "$\\sigma_1$",
      "flavor" = "Factors of Prod."))

myXTable(data_CES_sigma_raw,
         caption="Factor substitution~($\\sigma$) for CES models.",
         label=paste0("tab:", opts_current$get("label")), 
         digits=6)
@





<<Graphs_CESlek-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for CES models with ($le$)$k$ nesting.">>=
residualPlot(fitted_and_resid_data %>% 
               filter(model=="CES" & CSP=="w/o CSP" & (nest == "lek" | nest=="kl")),
             withEnergyShape = 3) # plus
@
%
<<Graphs_CESekl-resid, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="Fitting residuals for CES models with $(ek$)$l$ nesting.">>=
residualPlot(fitted_and_resid_data %>% 
               filter(model=="CES" & CSP=="w/o CSP" & (nest=="ekl" | nest=="kl")),
             withEnergyShape = 4) # times
@


%
<<Graphs_CESlek-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="CES models with $kl$ and ($le$)$k$ nesting that reject the CSP. Solid line is historical GDP.">>=
fittedGraphData_lek <- fitted_and_resid_data %>% filter(model=="CES" & CSP=="w/o CSP" & (nest == "kl" | nest == "lek"))
fittedGraphNoCSP(fittedGraphData_lek)
@
%
<<Graphs_CESekl-fitted, fig.pos="H", fig.align='center', fig.width=6.5, fig.height=4, fig.cap="CES models with $kl$ and ($ek$)$l$ nesting that reject the CSP. Solid line is historical GDP.">>=
fittedGraphData_ekl <- 
  fitted_and_resid_data %>% 
  filter(model=="CES" & CSP=="w/o CSP" & (nest == "kl" | nest == "ekl"))
fittedGraphNoCSP(fittedGraphData_ekl)
@




\end{document}

%%
%% End of file `elsarticle-template-2-harv.tex'.
