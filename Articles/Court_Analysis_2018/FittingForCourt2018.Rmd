---
title: "US CES Analysis for Victor Court"
author: "Matthew Kuperus Heun, Calvin College"
date: "11 July 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
library(dplyr)
library(EconModels)
library(ggplot2)
library(magrittr)
library(tidyr)
```

## Analysis for Victor Court

Victor Court has asked me to fit US energy and economic data
using the CES aggregate production function. 
The energy and economic data have been supplied by Victor.
I will use the fitting code that was created for the ``Cautionary Tales'' paper.


## Load and sanitize data

First, load the data.

```{r}
USData_raw <- read.csv(file = "CES_USA.csv", sep = ";")
head(USData_raw, n = 3) # Show the first 3 rows
```

Next, sanitize the data a bit
by removing non-indexed columns and
renaming the columns.
Lower-case variable names indicate indexing to 1 in 1960.

```{r}
USData <- USData_raw %>% 
  select(-K.L...US.2010.per.hour., 
         -Capital...US.2010., 
         -Labor..millions.of.hours., 
         -Primary.exergy..TJ.,
         -GDP....US.2010.) %>% 
  rename(
    k = K..1960...1.,
    l = L..1960...1.,
    e = E..1960...1.,
    y = Y..1960...1.
  ) %>% 
  mutate(
    Country = "US",
    time = Year - min(Year)
  ) %>% 
  select(Country, Year, time, y, k, l, e) # Re-order the columns
head(USData, n = 3)
```

Now review the data in graphical form.

```{r}
USData %>% 
  gather(key = variable, value = value, k, l, e, y) %>% 
  mutate(
    # Put variables in a reasonable order for the graph legend
    variable = factor(variable, levels = c("y", "k", "e", "l"))
  ) %>% 
  ggplot(mapping = aes(x = Year, y = value, linetype = variable)) +
  geom_line() +
  geom_hline(yintercept = 1, colour = "gray50", size = 0.1) +
  labs(y = NULL, x = NULL, linetype = NULL) +
  
  xy_theme()
```



## Perform the fit

We'll fit with the $(kl)e$ nesting.
The warning occurs in one of the many trials and can be ignored.

```{r}
kleModel <- cesModel(y ~ k + l + e + time, data = USData)
kleModel
```
Note that $\rho_1 = -1$ (therefore, $\sigma_1 = \infty$). 
Therefore, this is a boundary model.

We can query which boundary model we have obtained: 
```{r}
kleModel$bname
```
So this is boundary model 20 of Table 2 in the ``Cautionary Tales'' paper.

We can see the "natural" coefficients for the model,
which shows that the "scale" parameter ($\theta$) is close to 1, as expected.
```{r}
naturalCoef(kleModel)
```

We can also try other nestings of the CES model, 
which provide three degenerate cases: $(kl)$, $(le)$, and $(ek)$ nestings.
In all of these, `delta` is 1 and `sigma` and `rho` are `NA`, 
because the third factor of production is missing.

```{r}
klModel <- cesModel(y ~ k + l + time, data = USData)
naturalCoef(klModel)
leModel <- cesModel(y ~ l + e + time, data = USData)
naturalCoef(leModel)
ekModel <- cesModel(y ~ e + k + time, data = USData)
naturalCoef(ekModel)
```


## Compare with historical data

We can compare the fitted models against the historical data
as shown in the following graph.
```yhat``` is a function that extracts the fitted values.

```{r}
USData %>% 
  mutate(
    `y fitted kle` = yhat(kleModel) %>% as.numeric(), # avoids an attributes warning
    `y fitted kl` = yhat(klModel),
    `y fitted le` = yhat(leModel),
    `y fitted ek` = yhat(ekModel)
  ) %>% 
  select(Year, y, `y fitted kle`, `y fitted kl`, `y fitted le`, `y fitted ek`) %>% 
  gather(key = var, value = value, y, 
         `y fitted kle`, `y fitted kl`, `y fitted le`, `y fitted ek`) %>% 
  mutate(
    var = factor(var, levels = c("y", "y fitted kle", 
                                 "y fitted kl", "y fitted le", "y fitted ek"))
  ) %>% 
  ggplot(mapping = aes(x = Year, y = value, linetype = var, colour = var)) +
  geom_line() +
  geom_hline(yintercept = 1, colour = "gray50", size = 0.1) +
  labs(x = NULL, y = NULL, linetype = NULL, colour = NULL) +
  xy_theme()
```

We can also plot all of the residuals (which are calculated in log space).

```{r}
resids <- USData %>% 
  select(Year) %>% 
  mutate(
    r_y = 0,
    r_kle = residuals(kleModel) %>% as.numeric(),
    r_kl = residuals(klModel) %>% as.numeric(),
    r_le = residuals(leModel) %>% as.numeric(),
    r_ek = residuals(ekModel) %>% as.numeric()
  ) %>% 
  gather(key = var, value = value, r_y, r_kle, r_kl, r_le, r_ek) %>% 
  mutate(
    var = factor(var, levels = c("r_y", "r_kle", "r_kl", "r_le", "r_ek"))
  ) 
resids %>% 
  ggplot(mapping = aes(x = Year, y = value, linetype = var, colour = var)) +
  geom_line() + 
  labs(x = NULL, y = NULL, linetype = NULL, colour = NULL) +
  
  xy_theme()
```

The sum of squared residuals (in log space) can be used to compare the models.

```{r}
SSE <- resids %>% 
  mutate(
    r2 = value^2
  ) %>% 
  select(-value) %>% 
  spread(key = var, value = r2) %>% 
  summarise(
    sse_kle = sum(r_kle), 
    sse_kl = sum(r_kl),
    sse_le = sum(r_le),
    sse_ek = sum(r_ek)
  )
SSE
```

## Comments

Visually, the fit is quite good for all models. 
It is difficult to say that one model is vastly superior to any other model.
According to SSE, the $(kl)e$ model fits best, as would be expected.
 
